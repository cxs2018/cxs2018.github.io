<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DOMContentLoaded和load</title>
    <url>/2020/10/04/DOMContentLoaded%E5%92%8Cload/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h2><p>MDN的解释：当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。</p>
<a id="more"></a>
<p>通俗点说，DOMContentLoaded 事件在 html 文档加载完毕，并且 html 所引用的内联 js、以及外链 js 的同步代码都执行完毕后触发。</p>
<blockquote>
<p>注意如果 js 采用 async 和 defer 链接时，此时 js 会异步下载，并不会阻塞页面 DOM 解析，async 是下载完立即执行，而defer 则会按照顺序在 DOMContentLoaded 前按照页面出现顺序依次执行。</p>
</blockquote>
<h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><p>MDN的解释：load 应该仅用于检测一个完全加载的页面，当一个资源及其依赖资源已完成加载时，将触发load事件。</p>
<p>也就是当页面 DOM 结构中的 js、css、图片，以及 js 异步加载的 js、css 、图片都加载完成之后，才会触发 load 事件。所以 DOMContentLoaded 事件触发在 load 事件之前。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>link和import</title>
    <url>/2020/10/04/link%E5%92%8Cimport/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="HTML引入CSS样式的四种方式"><a href="#HTML引入CSS样式的四种方式" class="headerlink" title="HTML引入CSS样式的四种方式"></a>HTML引入CSS样式的四种方式</h2><p>内联样式、内部样式和外部样式我们就不多说了，下面来看看 @import 引入 CSS 样式的方法：</p>
<ul>
<li><p>在内部样式中使用 @import：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="keyword">@import</span> url(style.css);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a></li>
<li><p>在外部样式中使用 @import：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* style.css */</span></span><br><span class="line"><span class="comment">/* @charset &quot;utf-8&quot;; */</span></span><br><span class="line"><span class="keyword">@import</span> url(style.css);</span><br><span class="line">* &#123; </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从属关系的区别"><a href="#从属关系的区别" class="headerlink" title="从属关系的区别"></a>从属关系的区别</h2></li>
<li><p>link 是 HTML 提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。</p>
</li>
<li><p>@import 是 CSS 提供的语法规则，只有导入样式表的作用。</p>
</li>
</ul>
<h2 id="加载顺序的区别"><a href="#加载顺序的区别" class="headerlink" title="加载顺序的区别"></a>加载顺序的区别</h2><ul>
<li>加载页面时，link标签引入的 CSS 被同时加载。</li>
<li>@import引入的 CSS 将在页面加载完毕后被加载。</li>
</ul>
<h2 id="兼容性的区别"><a href="#兼容性的区别" class="headerlink" title="兼容性的区别"></a>兼容性的区别</h2><ul>
<li>link 标签作为 HTML 元素，不存在兼容性问题。</li>
<li>@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别。</li>
</ul>
<h2 id="DOM可控性的区别"><a href="#DOM可控性的区别" class="headerlink" title="DOM可控性的区别"></a>DOM可控性的区别</h2><ul>
<li>可以通过 JS 操作 DOM ，动态插入 link 标签来改变样式。</li>
<li>由于 DOM 方法是基于文档的，无法使用 @import 的方式插入样式。</li>
</ul>
<h2 id="复用率的区别"><a href="#复用率的区别" class="headerlink" title="复用率的区别"></a>复用率的区别</h2><ul>
<li>link 只能一次引用一个文件，每一个 link 只是一个 http 请求。</li>
<li>@import 可以复用之前的 CSS 文件，当然，@import 复用文件时，在浏览器实际上是加载了多个文件，会有多个请求。</li>
</ul>
<h2 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h2><p>link 引入的样式权重大于 @import 引入的样式？我们在网上搜索关于这两者的区别的时候通常会看见有上面这种说法，难道真的是这样吗？有待商榷。</p>
<p>经过测试，我发现 link 和 @import 这两种引入 CSS 的方式并没有权重方面概念，只是单纯的展示出 CSS 的层叠顺序罢了，即写在后边的样式会覆盖前面的样式。</p>
<p>在加载页面的时候，在link引入的css样式的时候会先于@import加载，但是 link 引入的样式会覆盖掉 @import 引入的样式，这是为什么呢？让我们先来回顾一下关于浏览器执行过程的一些概念：</p>
<ul>
<li>加载：根据请求的 url 进行域名解析，然后向服务器发送请求，接收响应文件（如 HTML、CSS、JS、图片等）。</li>
<li>解析：对加载到的资源（HTML、CSS、JS等）进行语法解析，构建响应的内部数据结构（如 HTML 的 DOM 树，JS 对象的属性表，CSS 样式规则等）。</li>
<li>渲染：构建渲染树，对各个元素进行位置计算、样式计算等，然后根据渲染树完成页面的布局及绘制的过程（产生页面的元素）。</li>
</ul>
<p>link 先于 @import 加载，是不是也先于 @import 渲染呢？</p>
<p>实际上，浏览器渲染的动作一般会执行多次的。最后一次渲染，一定是基于之前加载过的所有样式整合后渲染树进行绘制页面的，已经被渲染过的页面元素，也会被重新渲染。那么我们就可以把 @import 这种导入 CSS 文件的方式理解成一种替换，CSS 解析引擎在对一个 CSS 文件进行解析时，如在文件顶部遇到 @import，将被替换为该 @import 导入的 CSS 文件中的全部样式。现在我们明白了为何  @import 引入的样式，会被层叠掉了，虽然它后被加载，却会在加载完毕后置于样式表顶部，最终渲染时自然会被下面的同名样式层叠。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>async和defer</title>
    <url>/2020/10/04/async%E5%92%8Cdefer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="普通script"><a href="#普通script" class="headerlink" title="普通script"></a>普通script</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;script.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。</p>
<a id="more"></a>
<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">&quot;script.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。</p>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script defer src=<span class="string">&quot;script.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>来看下面两张图，可以清晰的看到三种方式的区别：<br><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/defer.jpg" alt="alt"><br><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/defer.png" alt="alt"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>普通script会阻塞DOM的解析，async和defer都会并行下载，不会影响页面的解析，async 是下载完立即执行，而defer 则会按照顺序在 DOMContentLoaded 前按照页面出现顺序依次执行。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2020/10/05/HTML/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h2><p>DOCTYPE 是一种标准通用标记语言（SGML）的文档类型声明，目的是告诉浏览器的解析器要使用什么样的文档类型定义（DTD）来解析文档。目前浏览器的文档解析类型有三种：</p>
<ul>
<li>Quirks mode（怪异模式）：在怪异模式下，排版会模拟 Navigator 4 与 Internet Explorer 5 的非标准行为。如果没有声明DOCTYPE，默认就是这个模式。</li>
<li>Almost standards mode（接近标准模式）：只有少数的怪异行为被实现。</li>
<li>Standard mode（标准模式）：浏览器使用 W3C 的标准解析渲染页面。</li>
</ul>
<p><code>&lt;!DOCTYPE&gt;</code>声明必须是 HTML 文档的第一行，位于 html 标签之前。HTML5只规定了一种格式<code>&lt;!DOCTYPE html&gt;</code></p>
<a id="more"></a>
<h2 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h2><p>meta 标签可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。</p>
<p>meta标签提供四个属性：</p>
<ul>
<li>name：名称/值对中的名称。author、description、keywords、generator、revised、others。把 content 属性关联到一个名称。</li>
<li>http-equiv：没有name时，会采用这个属性的值。content-type、expires、refresh、set-cookie。把content属性关联到http头部。</li>
<li>content：名称/值对中的值，可以是任何有效的字符串。始终要和 name 属性或 http-equiv 属性一起使用。</li>
<li>schema：用于指定要用来翻译属性值的方案</li>
</ul>
<p>name 中有一个重要的属性值：viewport，用于适配移动端，进行响应式开发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">key</th>
<th align="center">mean</th>
<th align="center">example</th>
</tr>
</thead>
<tbody><tr>
<td align="center">width</td>
<td align="center">视口的宽度</td>
<td align="center">width=device-width 指缩放为 100% 时以 CSS 像素计量的屏幕宽度</td>
</tr>
<tr>
<td align="center">initial-scale</td>
<td align="center">初始化缩放比例</td>
<td align="center">initial-scale=1.0 初始化不进行缩放</td>
</tr>
<tr>
<td align="center">maximum-scale</td>
<td align="center">用户最大缩放比例</td>
<td align="center">maximum-scale=1.0 不允许用户缩放</td>
</tr>
</tbody></table>
<h2 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h2><ul>
<li>用正确的标签做正确的事情。</li>
<li>HTML 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；</li>
<li>即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的；</li>
<li>搜索引擎的爬虫也依赖于 HTML 标记确定上下文和各个关键字的权重，利于 SEO ;</li>
<li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</li>
</ul>
<h2 id="常见的浏览器内核"><a href="#常见的浏览器内核" class="headerlink" title="常见的浏览器内核"></a>常见的浏览器内核</h2><table>
<thead>
<tr>
<th align="center">浏览器</th>
<th align="center">内核</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IE</td>
<td align="center">Trident</td>
<td align="center">国内浏览器如猎豹安全、360极速浏览器、百度浏览器等也在使用 Trident 内核</td>
</tr>
<tr>
<td align="center">Firefox</td>
<td align="center">Gecko</td>
<td align="center">近几年逐渐没落</td>
</tr>
<tr>
<td align="center">Safari</td>
<td align="center">Webkit</td>
<td align="center">从Safari推出之时起，它的渲染引擎就是Webkit</td>
</tr>
<tr>
<td align="center">Chrome</td>
<td align="center">Chromium/Blink</td>
<td align="center">Chromium 是谷歌的一款开源项目，而Chrome 是 Chromium 的稳定版。在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用Blink内核二次开发</td>
</tr>
<tr>
<td align="center">Opera</td>
<td align="center">Blink</td>
<td align="center">刚开始使用Presto，后来跟随谷歌使用Blink</td>
</tr>
</tbody></table>
<h2 id="对浏览器内核的理解"><a href="#对浏览器内核的理解" class="headerlink" title="对浏览器内核的理解"></a>对浏览器内核的理解</h2><p>浏览器内核主要分成两部分：渲染引擎和 JS 引擎。渲染引擎：将代码转换成页面，负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等）、以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其他需要编辑、显示网络内容的应用程序都需要内核。JS 引擎：解析和执行 javascript 来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分得很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>
<h2 id="HTML5有增加了哪些新特性，移除了哪些元素？如何处理HTML5新标签的浏览器兼容问题？"><a href="#HTML5有增加了哪些新特性，移除了哪些元素？如何处理HTML5新标签的浏览器兼容问题？" class="headerlink" title="HTML5有增加了哪些新特性，移除了哪些元素？如何处理HTML5新标签的浏览器兼容问题？"></a>HTML5有增加了哪些新特性，移除了哪些元素？如何处理HTML5新标签的浏览器兼容问题？</h2><p>新特性：</p>
<ul>
<li>用于绘画的 canvas 元素；</li>
<li>用于媒体播放的 video 和 audio 元素；</li>
<li>对本地离线存储有更好的支持，localStorage 长期存储数据，浏览器关闭后数据不丢失，sessionStorage 的数据在浏览器关闭后自动删除；</li>
<li>语意化更好的内容元素，比如 header、nav、section、article、footer；</li>
<li>新的表单控件：calendar、date、time、email、url、search；</li>
<li>新的技术 webworker、websocket、Geolocation。</li>
</ul>
<p>移除了：</p>
<ul>
<li>纯表现的元素：basefont、big、center、font、s、strike、tt、u;</li>
<li>对可用性产生负面影响的元素：frame、frameset、noframes。</li>
</ul>
<p>处理兼容性问题：<br>IE8/IE7/IE6支持 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。</p>
<h2 id="HTML5哪些标签可以做SEO优化？"><a href="#HTML5哪些标签可以做SEO优化？" class="headerlink" title="HTML5哪些标签可以做SEO优化？"></a>HTML5哪些标签可以做SEO优化？</h2><p>title、meta、header、footer、nav、article、aside。</p>
<h2 id="src和href的区别"><a href="#src和href的区别" class="headerlink" title="src和href的区别"></a>src和href的区别</h2><ul>
<li>src 是指向外部资源的位置，指向的内容会嵌入到文档中当前标签所在的位置，在请求 src 资源时会将其指向的资源下载并应用到文档内，如 js 脚本，img 图片和 iframe 等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，知道将该资源加载、编译、执行完毕，所以一般 js 脚本会放在底部而不是头部。</li>
<li>href 是指网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。</li>
</ul>
<h2 id="渐进增强和优雅降级"><a href="#渐进增强和优雅降级" class="headerlink" title="渐进增强和优雅降级"></a>渐进增强和优雅降级</h2><ul>
<li>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能，达到更好的用户体验。</li>
<li>优雅降级：一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</li>
</ul>
<h2 id="async和defer的区别"><a href="#async和defer的区别" class="headerlink" title="async和defer的区别"></a>async和defer的区别</h2><p>详见<a href="https://www.cuixuesen.icu/2020/10/04/async%E5%92%8Cdefer/">async和defer</a></p>
<h2 id="描述一下-cookie、sessionStorage和localStorage的区别"><a href="#描述一下-cookie、sessionStorage和localStorage的区别" class="headerlink" title="描述一下 cookie、sessionStorage和localStorage的区别"></a>描述一下 cookie、sessionStorage和localStorage的区别</h2><p>详见<a href="https://www.cuixuesen.icu/2020/09/29/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/">本地存储</a></p>
<h2 id="如何实现浏览器内多个标签页之间的通信？"><a href="#如何实现浏览器内多个标签页之间的通信？" class="headerlink" title="如何实现浏览器内多个标签页之间的通信？"></a>如何实现浏览器内多个标签页之间的通信？</h2><ul>
<li>使用 localStorage: localStorage.setItem(key,value)、 localStorage.getItem(key)</li>
<li>websocket协议</li>
<li>webworker</li>
</ul>
<p>详见<a href="https://juejin.im/post/6844903589924569101">多个标签页之间的通信</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hooks</title>
    <url>/2021/01/27/React-Hooks/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h2><p>Hooks 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>
<a id="more"></a>
<p>下面链接是我做的一个关于 Hooks 的 PPT ，较为全面的介绍了Hooks，希望帮助大家入门 Hooks。</p>
<p><a href="https://raw.githubusercontent.com/cxs2018/blog/master/img/Hooks.pptx">Hooks</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>一株赶考的麦子</title>
    <url>/2021/02/21/%E4%B8%80%E6%A0%AA%E8%B5%B6%E8%80%83%E7%9A%84%E9%BA%A6%E5%AD%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><center><font color=#ccc>作者：洛水&emsp;来源：《意林》</font></center>

<p>&emsp;&emsp;怪我，直到那年高考，我才明白，他对我有着别样的期待，在他人生的麦田里，我是一株赶考的麦子。</p>
<a id="more"></a>
<p>&emsp;&emsp;高考前两天，学校让我们自己调整。我掉转方向，打道回家。半年的闭关苦读，我和时节完全脱钩。回到家才发现，满地金黄，漫天麦香，已到收麦季节。时间过得真快，更让我措手不及的是，在我面前巍峨多年的父亲，已经没有我高了！<br>&emsp;&emsp;对于我的火线回归，父亲很欣慰。“上阵父子兵”，麦收是父亲最重要的战役，多年来，我们一直并肩作战，把时光打得颗粒归仓。父亲拿起一把镰刀，试试锋刃，递给我：今年麦倒伏，要用手割了。我心生忐忑——过去割麦，是跟在收割机后，零打碎敲，对抗性为零；现在回到冷兵器时代，和麦子打“阵地战”，我还真有些力不从心的感觉。<br>&emsp;&emsp;我接过镰刀，掂了掂，我明白，我再怎么做也做不到像父亲那样游刃有余。<br>&emsp;&emsp;六月，阳光如炽，我是条落网的鱼。<br>&emsp;&emsp;我不时直起腰，沿着脊梁沟，汗水一泻而下，酸痛逆流而上。我低估了弱不禁风的小麦，那把镰刀也临阵倒戈，把我的掌心磨满水泡。我暴露在麦芒般刺眼的阳光里，孤立无援。父亲却像个无坚不摧的坦克，所向披靡。在这里，父亲总是火力十足。我不得不承认，这片麦田是父亲的主场，我则是他一个人的啦啦队。<br>&emsp;&emsp;这是场父亲的“战争”，我无法提供“火力”支持，但可供奉茶水。父亲看看我的手：“使不惯？别攥太紧，和拿笔一样。”我点点头。镰刀是父亲的笔，麦子是墨，他可以在田野上挥毫泼墨，只是他没能教会我，而我也从没用心学过。<br>&emsp;&emsp;喝罢水，父亲问我，快高考了吧？我说，后天。父亲怔住，满身的汗珠也如麦粒般静止。父亲拿毛巾擦拭着我的额头，似乎要把我湿漉漉的疲惫赶走。很快，他督促道：“快回家歇着吧！别累着，高考才是你该干的事。养足精神去收你的麦子吧，那个老子帮不上。”<br>&emsp;&emsp;父亲又开始埋首割麦，把对我的歉意，肆虐在麦子身上。我如遇大赦，赶紧以备战高考的名义溜号。<br>&emsp;&emsp;阳光烘烤着麦田，父亲伫立着，像一株硕大的麦穗，满身滚圆的汗珠，如麦子般饱满，灼灼其华，刺痛着我的眼。麦子是父亲的汗珠，我是其中最大的一颗吧。<br>&emsp;&emsp;正如麦田是父亲一个人的战场，高考是我一个人的麦田。看着同学被父母簇拥着走向考场，我没有丝毫嫉妒和埋怨。我并不孤独，从故乡到小城，我和父亲在并肩作战。我学着父亲，以笔为镰，以墨为麦，在我的麦田里恣意挥毫。<br>&emsp;&emsp;那年，我考取一所重点高校。以后，求学，工作，一路颠沛流离。我始终没有忘记，我是一株赶考的麦子，我要考取的不是功名，而是把父亲的期望，颗粒归仓。</p>
]]></content>
      <categories>
        <category>文摘</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/2020/09/23/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。而二叉搜索树（BST）是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值。</p>
<a id="more"></a>
<h2 id="BinarySearchTree类的模拟实现"><a href="#BinarySearchTree类的模拟实现" class="headerlink" title="BinarySearchTree类的模拟实现"></a>BinarySearchTree类的模拟实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建节点Node类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(key) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Compare = &#123;</span><br><span class="line">    LESS_THAN: <span class="number">-1</span>,</span><br><span class="line">    BIGGER_THAN: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultCompare</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(compareFn = defaultCompare) &#123;</span><br><span class="line">        <span class="built_in">this</span>.compareFn = compareFn;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 向二叉搜索树中插入一个值 - 辅助方法</span></span><br><span class="line">    insertNode(node, key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> Node(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.insertNode(node.left, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> Node(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.insertNode(node.right, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向二叉搜索树中插入一个值</span></span><br><span class="line">    insert(key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root = <span class="keyword">new</span> Node(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.insertNode(<span class="built_in">this</span>.root, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中序遍历 - 辅助方法</span></span><br><span class="line">    inOrderTraverseNode(node, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.inOrderTraverseNode(node.left, callback);</span><br><span class="line">            callback(node.key);</span><br><span class="line">            <span class="built_in">this</span>.inOrderTraverseNode(node.right, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    inOrderTraverse(callback) &#123;</span><br><span class="line">        <span class="built_in">this</span>.inOrderTraverseNode(<span class="built_in">this</span>.root, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先序遍历 - 辅助方法</span></span><br><span class="line">    preOrderTraverseNode(node, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            callback(node.key);</span><br><span class="line">            <span class="built_in">this</span>.preOrderTraverseNode(node.left, callback);</span><br><span class="line">            <span class="built_in">this</span>.preOrderTraverseNode(node.right, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先序遍历</span></span><br><span class="line">    preOrderTraverse(callback) &#123;</span><br><span class="line">        <span class="built_in">this</span>.preOrderTraverseNode(<span class="built_in">this</span>.root, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序遍历 - 辅助方法</span></span><br><span class="line">    postOrderTraverseNode(node, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.postOrderTraverseNode(node.left, callback);</span><br><span class="line">            <span class="built_in">this</span>.postOrderTraverseNode(node.right, callback);</span><br><span class="line">            callback(node.key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    postOrderTraverse(callback) &#123;</span><br><span class="line">        <span class="built_in">this</span>.postOrderTraverseNode(<span class="built_in">this</span>.root, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搜索最小值 - 辅助方法</span></span><br><span class="line">    minNode(node) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = node;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 搜索最小值</span></span><br><span class="line">    min() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.minNode(<span class="built_in">this</span>.root);</span><br><span class="line">    &#125;          </span><br><span class="line">    <span class="comment">// 搜索最大值 - 辅助方法</span></span><br><span class="line">    maxNode(node) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = node;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 搜索最大值</span></span><br><span class="line">    max() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.maxNode(<span class="built_in">this</span>.root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搜索特定的值 - 辅助方法</span></span><br><span class="line">    searchNode(node, key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.searchNode(node.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.searchNode(node.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 搜索特定的值</span></span><br><span class="line">    search(key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.searchNode(<span class="built_in">this</span>.root, key);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 移除一个节点 - 辅助方法</span></span><br><span class="line">    removeNode(node, key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">            node.left = <span class="built_in">this</span>.removeNode(node.left, key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">            node.right = <span class="built_in">this</span>.removeNode(node.right, key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第一种情况：移除一个叶节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                node = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第二种情况：移除有一个左侧或右侧子节点的节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第三种情况：移除有两个子节点的节点</span></span><br><span class="line">            <span class="keyword">const</span> aux = <span class="built_in">this</span>.minNode(node.right);</span><br><span class="line">            node.key = aux.key;</span><br><span class="line">            node.right = <span class="built_in">this</span>.removeNode(node.right, aux.key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 移除一个节点</span></span><br><span class="line">    remove(key) &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="built_in">this</span>.removeNode(<span class="built_in">this</span>.root, key);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不再演示BinarySearchTree类中方法的使用了，有兴趣的可以自己做个demo测试一下，如果有任何的问题，欢迎评论区留言。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>onward and upward</title>
    <url>/2021/02/07/onward-and-upward/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h2><a id="more"></a>
<p>西平高中校号：</p>
<p><strong>相信自己，我是最好，追求卓越，成就自我。</strong></p>
<p>2014级宏志班班号：</p>
<p><strong>拼搏进取，斗志昂扬，全力以赴，宏志辉煌。</strong></p>
<h2 id="onward-and-upward"><a href="#onward-and-upward" class="headerlink" title="onward and upward"></a>onward and upward</h2><p><strong>生如蝼蚁，当立鸿鹄之志；命薄似纸，应有不屈之心。</strong></p>
<p><strong>乾坤未定，你我皆是黑马；以梦为马，不负豆蔻年华。</strong></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>从闭包说起</title>
    <url>/2020/09/18/%E4%BB%8E%E9%97%AD%E5%8C%85%E8%AF%B4%E8%B5%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure>
<p>输出结果为:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>只要对同步和异步的区别、变量块级作用域、闭包等关键知识理解到位，得出正确答案就不难，但这道题远没有这么简单，来看面试官的继续追问。</p>
<a id="more"></a>
<h2 id="追问1"><a href="#追问1" class="headerlink" title="追问1"></a>追问1</h2><p>如果我们约定，用箭头（-&gt;）表示其前后的两次输出之间有1秒的时间间隔，而逗号（,）表示其前后的两次输出之间的时间间隔可以忽略，代码实际运行的结果该如何描述？</p>
<ul>
<li>A: 5-&gt;5-&gt;5-&gt;5-&gt;5-&gt;5</li>
<li>B: 5-&gt;5,5,5,5,5</li>
</ul>
<p>选A还是选B呢，这就要求面试者对定时器的工作机制非常熟悉，在循环执行过程中，几乎同时设置了 5 个定时器，一般情况下，这些定时器都会在 1 秒之后同时触发，而循环完的输出是立即执行的，显而易见，正确的描述是 B 。</p>
<h2 id="追问2"><a href="#追问2" class="headerlink" title="追问2"></a>追问2</h2><p>如果期望代码的输出变成：5-&gt;0,1,2,3,4，该怎么改造代码？熟悉闭包的同学很快能给出下面的解决办法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123; </span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure>
<p>巧妙的利用 IIFE（Immediately Invoked Function Expression：声明即执行的函数表达式）来解决闭包造成的问题。但这对于初学者来说可能不太好懂，有没有更直观的做法？当然有，我们只需要对循环体稍做手脚，让负责输出的那段代码能拿到每次循环的 i 值即可。该怎么做呢？利用 JS 中基本类型（Primitive Type）的参数传递是按值传递（Pass by Value）的特征，不难改造出下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> output = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    output(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure>
<h2 id="追问3"><a href="#追问3" class="headerlink" title="追问3"></a>追问3</h2><p>还是最初的那道题，如果将var改成let，会发生什么？</p>
<p>let是ES6块级作用域中的概念，用let代替var后，会发现代码在实际运行中报错，这是因为最后那个输出使用的 i 在其所在的作用域中并不存在，i 只存在于for循环内部。</p>
<h2 id="追问4"><a href="#追问4" class="headerlink" title="追问4"></a>追问4</h2><p>如果期望代码的输出变成 0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5，并且要求原有的代码块中的循环和两处console.log不变，该怎么改造代码？新的需求可以精确的描述为：代码执行时，立即输出 0，之后每隔 1 秒依次输出 1,2,3,4，循环结束后在大概第 5 秒的时候输出 5（这里使用大概是为了避免钻牛角尖的同学陷进去，因为 JS 中的定时器触发时机有可能是不确定的）。</p>
<p>看到这里，有些同学会给出下面的可行解：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j);</span><br><span class="line">        &#125;, <span class="number">1000</span> * j));  <span class="comment">// 这里修改 0~4 的定时器时间</span></span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 这里增加定时器，超时设置为 5 秒</span></span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;, <span class="number">1000</span> * i);</span><br></pre></td></tr></table></figure>
<p>不得不承认，这种做法虽然粗暴有效，但是不算是能额外加分的方案。如果把这次的需求抽象为：在系列异步操作完成（每次循环都产生了 1 个异步操作）之后，再做其他的事情，代码该怎么组织？聪明的你是不是想起了什么？对，就是 Promise，来看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;   <span class="comment">// 这里 i 的声明不能改成 let，如果要改该怎么做？</span></span><br><span class="line">    (<span class="function">(<span class="params">j</span>) =&gt;</span> &#123;</span><br><span class="line">        tasks.push(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(j);</span><br><span class="line">                resolve();  <span class="comment">// 这里一定要 resolve，否则代码不会按预期 work</span></span><br><span class="line">            &#125;, <span class="number">1000</span> * j);   <span class="comment">// 定时器的超时时间逐步增加</span></span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);   </span><br></pre></td></tr></table></figure>
<p>当然，上面的代码还能进一步简化，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []; <span class="comment">// 这里存放异步操作的 Promise</span></span><br><span class="line"><span class="keyword">const</span> output = <span class="function">(<span class="params">i</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, <span class="number">1000</span> * i);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 生成全部的异步操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    tasks.push(output(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步操作完成之后，输出最后的 i</span></span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样看是不是逻辑清楚多了，使用 Promise 处理异步代码比回调机制让代码可读性更高，但是使用 Promise 的问题也很明显，即如果没有处理 Promise 的 reject，会导致错误被丢进黑洞，这显然是我们不愿看到的。</p>
<h2 id="追问5"><a href="#追问5" class="headerlink" title="追问5"></a>追问5</h2><p>既然Promise已经被拿下，能否使用 ES7 中的 async/await 特性来让这段代码变的更简洁？答案是肯定的，来看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟其他语言中的 sleep，实际上可以是任何异步操作</span></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">timeountMS</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, timeountMS);</span><br><span class="line">&#125;);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;  <span class="comment">// 声明即执行的 async 函数表达式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>好了，到这里，这道经典面试题我们已经剖析完毕了，相信读到这里，你收获的不仅仅是用 JS 精确控制代码输出的各种技巧，更是对于前端工程师的成长期许：扎实的语言基础、与时俱进的能力、强大的技术自驱力。生命不息，学习不止，让我们用知识不断充实丰富自己，如果你有任何的问题，也欢迎评论区留言，你的支持是我前进的最大动力！</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化</title>
    <url>/2020/09/18/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前端性能优化七大手段"><a href="#前端性能优化七大手段" class="headerlink" title="前端性能优化七大手段"></a>前端性能优化七大手段</h2><ul>
<li><p>减少请求数量</p>
</li>
<li><p>减小资源大小</p>
</li>
<li><p>优化网络连接</p>
</li>
<li><p>优化资源加载</p>
</li>
<li><p>减少重绘回流</p>
</li>
<li><p>使用性能更好的API</p>
</li>
<li><p>webpack优化</p>
<a id="more"></a>
<h2 id="减小请求资源大小或数量"><a href="#减小请求资源大小或数量" class="headerlink" title="减小请求资源大小或数量"></a>减小请求资源大小或数量</h2></li>
<li><p>尽量和并压缩css和js文件，例如将css文件和并为一个，将js合并为一个。<br>原因：主要是为了减少http请求次数以及减少请求资源的大小。<br>打包工具：webpack、gulp、grunt……</p>
</li>
<li><p>尽量使用字体图标或者SVG图标来代替传统png图，因为字体图标或者SVG图标是矢量图，是代码编写出来的，放大缩小不会变形，而且渲染速度快。</p>
</li>
<li><p>采用图片的懒加载（延迟加载）。<br>目的：为了减少页面第一次加载过程中http的请求次数。<br>具体步骤：<br>1、页面开始加载时不去发送http请求，而是放置一张占位图;<br>2、当页面加载完时，并且图片在可视区域再去请求加载图片信息.</p>
</li>
<li><p>能用css做的效果，不要用js做，能用原生js做的，不要轻易去使用第三方插件，避免引入第三方大量的库，而自己却只是用里面的一个小功能。</p>
</li>
<li><p>使用雪碧图（精灵图），把所有相对较小的资源图片，绘制在一张大图上，只需要将大图下载下来，然后利用，使用图片定位来将小图展现在页面中（background-position: 百分比, 数值）。</p>
</li>
<li><p>减少对cookie的使用，最主要的就是要减少本地cookie存储内容的大小，因为客户端操作cookie的时候，这些信息总是在客户端和服务端传递，如果设置不当，每次发送一个请求都会携带cookie。</p>
</li>
<li><p>前端与后端进行数据交互时，对于多项数据尽可能基于json格式来进行传送，相对于使用xml来说传输更有优势，因为json格式数据处理方便，资源偏小。</p>
</li>
<li><p>前端与后端协商，合理使用keep-alive。</p>
</li>
<li><p>前端与服务器协商，使用响应资源的压缩。</p>
</li>
<li><p>避免使用iframe，因为使用iframe不仅不好管控样式，而且相当于在本页面又嵌套其他页面，还要加载这些嵌套页面的资源，使得性能消耗变大。</p>
</li>
<li><p>在基于ajax的get请求进行数据交互的时候，根据需求可以让其产生缓存（注意：这个缓存不是我们常看到的304状态码，去浏览器本地取数据），这样在下一次从相同地址获取是数据时，取得就是上一次缓存的数据（注意：很少使用，一般都会清空，根据需求来做）。</p>
</li>
</ul>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><ul>
<li>在js中尽量减少闭包的使用，因为使用闭包后，闭包所在的上下文不会被释放。</li>
<li>减少对DOM操作，主要是减少DOM的重绘与回流（重排）。<br>关于重排（回流）的分离读写：如果需要设置多个样式，把设置样式全放在一起设置，不要一条一条的设置，使用文档碎片或者字符串拼接做数据绑定（DOM的动态创建）。</li>
<li>在js中避免嵌套循环和“死循环”，因为一旦遇到死循环，浏览器就会直接卡掉。</li>
<li>减少css表达式的使用。</li>
<li>减少元素标签作为最后一个选择对象，因为css选择器解析规则是从右往左解析的。</li>
<li>尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小），注意：图层不要过多设置，否则不但效果没有达到反而更差了。</li>
<li>在js封装过程中，尽量做到低耦合高内聚，减少页面的冗余代码。</li>
<li>css中设置定位后，最好使用z-index改变盒子的层级，让盒子不在相同的平面上。</li>
<li>css导入的时候尽量减少@import导入式，因为@import是同步操作，只有把对应的样式导入后，才会继续向下执行其他的代码，而link是异步的操作。</li>
<li>使用window.requestAnimationFrame(js的帧动画)代替传统的定时器动画，如果想使用每隔一段时间执行动画，应该避免使用setInterval，尽量使用setTimeout代替setInterval定时器，因为setInterval定时器存在弊端：可能造成两个动画间隔时间缩短。</li>
<li>尽量减少使用递归，避免死递归，如果一定要使用递归建议使用尾递归。</li>
<li>基于script标签引用js文件时，可以使用defer或者async来异步加载。</li>
<li>在事件绑定中，尽可能使用事件委托，减少循环给DOM元素绑定事件处理函数。</li>
<li>减少Flash的使用。</li>
</ul>
<h2 id="存储优化"><a href="#存储优化" class="headerlink" title="存储优化"></a>存储优化</h2><ul>
<li>结合后端，利用浏览器的缓存技术，做一些缓存（让后端返回304，告诉浏览器去本地拉取数据，可以让一些不太会改变的静态资源做缓存，比如一些图片，js文件，css文件</li>
<li>利用h5的新特性（localStorage、sessionStorage）做一些简单数据的存储，避免向后台请求数据或者说在离线状态下做一些数据展示。</li>
</ul>
<h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><ul>
<li>采用异步编程和延迟分批加载获取页面中的数据，使用异步加载是数据主要是为了避免浏览器失去响应，如果你使用同步，加载数据很大并且很慢，那么页面会在一段时间内处于阻塞状态。<br>目的：为了解决请求数据不耽搁渲染，提高页面的渲染效率。<br>解决方法：动态绑定数据区域，先隐藏，等数据返回并且绑定后再让其显示，延迟分批加载类似图片懒加载，以减少第一次页面加载时候的http请求次数。</li>
<li>如果页面有出现音视频标签，可以不让页面加载的时候去加载这些资源（将音视频的preload设置为none即可），否则第一次加载会很慢，在页面加载完成后，并且音视频要播放的时候再去加载音视频资源。</li>
</ul>
<p>如果你有任何的问题，欢迎评论区留言，你的支持是我前进的最大动力。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第10天-No.456 132模式</title>
    <url>/2021/03/24/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC10%E5%A4%A9-No-456-132%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i] &lt; nums[k] &lt; nums[j] 。</p>
<a id="more"></a>
<p>如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。</p>
<p>示例：</p>
<pre>
输入：nums = [1,2,3,4]
输出：false
解释：序列中不存在 132 模式的子序列。

输入：nums = [3,1,4,2]
输出：true
解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。

输入：nums = [-1,3,2,0]
输出：true
解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。
</pre>

<p>注意：</p>
<pre>
n == nums.length
1 <= n <= 104
-10^9 <= nums[i] <= 10^9
</pre>

<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>暴力破解</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> find132pattern = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> min = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (min &gt; nums[i]) &#123;</span><br><span class="line">      min = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (min &lt; nums[j] &amp;&amp; nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>单调栈</p>
<p>维护一个从栈底到栈顶单调递减的栈，对于遍历到的每一个元素，判断是否大于栈顶元素，是则持续弹出栈顶元素，直到栈顶元素小于等于正在遍历的元素，将弹出的元素记为 k，最后将遍历元素推入栈中，进行下一轮for循环。每轮for循环都将判断此时遍历的元素 i 是否小于 k，小于则说明找到了132模式的子序列。</p>
<blockquote>
<p>存在 k（<em>非-Infinity</em>） 则必然是由大于 k 的 j 将 k 弹出。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> find132pattern = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> k = -<span class="literal">Infinity</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt; k) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (stack.length !== <span class="number">0</span> &amp;&amp; stack[stack.length - <span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">      k = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第10天-No.893特殊等价字符串</title>
    <url>/2021/03/24/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC10%E5%A4%A9-No-893%E7%89%B9%E6%AE%8A%E7%AD%89%E4%BB%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你将得到一个字符串数组 A。</p>
<p>每次移动都可以交换 S 的任意两个偶数下标的字符或任意两个奇数下标的字符。</p>
<a id="more"></a>
<p>如果经过任意次数的移动，S == T，那么两个字符串 S 和 T 是特殊等价的。</p>
<p>例如，S = “zzxy” 和 T = “xyzz” 是一对特殊等价字符串，因为可以先交换 S[0] 和 S[2]，然后交换 S[1] 和 S[3]，使得 “zzxy” -&gt; “xzzy” -&gt; “xyzz” 。</p>
<p>现在规定，A 的一组特殊等价字符串就是 A 的一个同时满足下述条件的非空子集：</p>
<ul>
<li>该组中的每一对字符串都是特殊等价的</li>
<li>该组字符串已经涵盖了该类别中的所有特殊等价字符串，容量达到理论上的最大值（也就是说，如果一个字符串不在该组中，那么这个字符串就不会与该组内任何字符串特殊等价）</li>
</ul>
<p>返回 A 中特殊等价字符串组的数量。</p>
<p>示例：</p>
<pre>
输入：["abcd","cdab","cbad","xyzz","zzxy","zzyx"]
输出：3
解释：
其中一组为 ["abcd", "cdab", "cbad"]，因为它们是成对的特殊等价字符串，且没有其他字符串与这些字符串特殊等价。
另外两组分别是 ["xyzz", "zzxy"] 和 ["zzyx"]。特别需要注意的是，"zzxy" 不与 "zzyx" 特殊等价。

输入：["abc","acb","bac","bca","cab","cba"]
输出：3
解释：3 组 ["abc","cba"]，["acb","bca"]，["bac","cab"]
</pre>

<p>注意：</p>
<pre>
1 <= A.length <= 1000
1 <= A[i].length <= 20
所有 A[i] 都具有相同的长度。
所有 A[i] 都只由小写字母组成。
</pre>

<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>每个特殊等价字符串组中的字符串都具有这样一个特征：它们的奇数位上的每个字符的数量都相等，偶数位也是，只有这样，有限次奇数位或者偶数位的交换后也会使得它们相等。</p>
<p>因而，我们可以统计一下奇数位和偶数位字符数量，然后利用 Set 去重。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">A</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> numSpecialEquivGroups = <span class="function"><span class="keyword">function</span> (<span class="params">A</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> A) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">52</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> len = item.length;</span><br><span class="line">    <span class="keyword">let</span> aCode = <span class="string">&#x27;a&#x27;</span>.charCodeAt(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      count[item.charCodeAt(i) - aCode + <span class="number">26</span> * (i % <span class="number">2</span>)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    set.add(count.toString());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> set.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>每个特殊等价字符串组中的字符串，它们的奇数位的字符其实都是一样的，只是顺序不同，偶数位也是。</p>
<p>所以，我们可以提取出每个字符串的奇数位和偶数位字符，排序后进行拼接，然后使用 Set 去重。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">A</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> numSpecialEquivGroups = <span class="function"><span class="keyword">function</span> (<span class="params">A</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> list = A.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = item.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> odd = arr.filter(<span class="function">(<span class="params">t, i</span>) =&gt;</span> i % <span class="number">2</span> === <span class="number">1</span>).sort().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> even = arr.filter(<span class="function">(<span class="params">t, i</span>) =&gt;</span> i % <span class="number">2</span> === <span class="number">0</span>).sort().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> odd + even;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(list)].length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 耍个帅，一行搞定！</span></span><br><span class="line">  <span class="comment">// return [...new Set(A.map(item =&gt; item.split(&#x27;&#x27;).filter((t, i) =&gt; i % 2 === 1).sort().join(&#x27;&#x27;) + item.split(&#x27;&#x27;).filter((t, i) =&gt; i % 2 === 0).sort().join(&#x27;&#x27;)))].length;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第11天-No.275H指数2</title>
    <url>/2021/03/25/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC11%E5%A4%A9-No-275H%E6%8C%87%E6%95%B02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照 升序排列 。编写一个方法，计算出研究者的 h 指数。</p>
<a id="more"></a>
<p>h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）”</p>
<p>如果 h 有多有种可能的值 ，h 指数是其中最大的那个。</p>
<p>示例：</p>
<pre>
输入: citations = [0,1,3,5,6]
输出: 3 
解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。
     由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。
</pre>

<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>线性搜索</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">citations</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> hIndex = <span class="function"><span class="keyword">function</span> (<span class="params">citations</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = citations.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (citations[i] &gt;= len - i) &#123;</span><br><span class="line">      <span class="keyword">return</span> len - i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>二分查找</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">citations</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> hIndex = <span class="function"><span class="keyword">function</span> (<span class="params">citations</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = citations.length;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = len - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (citations[mid] &gt;= len - mid) &#123;</span><br><span class="line">      ret = len - mid;</span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第12天-No.2两数相加</title>
    <url>/2021/03/26/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC12%E5%A4%A9-No-2%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<a id="more"></a>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<pre>
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.

输入：l1 = [0], l2 = [0]
输出：[0]

输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
</pre>

<p>注意：</p>
<pre>
每个链表中的节点数在范围 [1, 100] 内
0 <= Node.val <= 9
题目数据保证列表表示的数字不含前导零
</pre>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>模拟</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> addTwoNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="keyword">new</span> ListNode();</span><br><span class="line">  <span class="keyword">let</span> carryFlag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = ret;</span><br><span class="line">  <span class="keyword">while</span> (l1 || l2 || carryFlag) &#123;</span><br><span class="line">    temp = (l1 ? l1.val : <span class="number">0</span>) + (l2 ? l2.val : <span class="number">0</span>) + (carryFlag ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (temp &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      sum.next = <span class="keyword">new</span> ListNode(temp - <span class="number">10</span>);</span><br><span class="line">      carryFlag = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sum.next = <span class="keyword">new</span> ListNode(temp);</span><br><span class="line">      carryFlag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = sum.next;</span><br><span class="line">    l1 = l1 ? l1.next : <span class="literal">null</span>;</span><br><span class="line">    l2 = l2 ? l2.next : <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第11天-No.82删除排序链表中的重复元素2</title>
    <url>/2021/03/25/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC11%E5%A4%A9-No-82%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。</p>
<a id="more"></a>
<p>返回同样按升序排列的结果链表。</p>
<p>示例：</p>
<pre>
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]

输入：head = [1,1,1,2,3]
输出：[2,3]
</pre>

<p>注意：</p>
<pre>
链表中节点数目在范围 [0, 300] 内
-100 <= Node.val <= 100
题目数据保证链表已经按升序排列
</pre>

<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>迭代</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> deleteDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dummyNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">  <span class="keyword">let</span> cur = dummyNode;</span><br><span class="line">  <span class="keyword">while</span> (cur.next &amp;&amp; cur.next.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur.next.val === cur.next.next.val) &#123;</span><br><span class="line">      <span class="keyword">let</span> x = cur.next.val;</span><br><span class="line">      <span class="keyword">while</span> (cur.next &amp;&amp; cur.next.val === x) &#123;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>递归</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> deleteDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (head.val !== head.next.val) &#123;</span><br><span class="line">    head.next = deleteDuplicates(head.next);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> newNode = head.next.next;</span><br><span class="line">    <span class="keyword">while</span> (newNode &amp;&amp; head.val === newNode.val) &#123;</span><br><span class="line">      newNode = newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deleteDuplicates(newNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第12天-No.83删除排序链表中的重复元素</title>
    <url>/2021/03/26/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC12%E5%A4%A9-No-83%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素只出现一次 。</p>
<a id="more"></a>
<p>返回同样按升序排列的结果链表。</p>
<p>示例：</p>
<pre>
输入：head = [1,1,2]
输出：[1,2]

输入：head = [1,1,2,3,3]
输出：[1,2,3]
</pre>

<p>注意：</p>
<pre>
链表中节点数目在范围 [0, 300] 内
-100 <= Node.val <= 100
题目数据保证链表已经按升序排列
</pre>

<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>迭代</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> deleteDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> cur = head;</span><br><span class="line">  <span class="keyword">while</span> (cur.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur.next.val === cur.val) &#123;</span><br><span class="line">      cur.next = cur.next.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>递归</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> deleteDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (head.val === head.next.val) &#123;</span><br><span class="line">    <span class="keyword">return</span> deleteDuplicates(head.next);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    head.next = deleteDuplicates(head.next);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第13天-No.19删除链表的倒数第N个结点</title>
    <url>/2021/03/27/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC13%E5%A4%A9-No-19%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<a id="more"></a>
<p>示例：</p>
<pre>
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]

输入：head = [1], n = 1
输出：[]

输入：head = [1,2], n = 1
输出：[1]
</pre>

<p>注意：</p>
<pre>
链表中结点的数目为 sz
1 <= sz <= 30
0 <= Node.val <= 100
1 <= n <= sz
</pre>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>双指针（快慢指针）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> removeNthFromEnd = <span class="function"><span class="keyword">function</span> (<span class="params">head, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head.next) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dummyNode = <span class="keyword">new</span> ListNode();</span><br><span class="line">  dummyNode.next = head;</span><br><span class="line">  <span class="keyword">let</span> slow = dummyNode;</span><br><span class="line">  <span class="keyword">let</span> fast = head;</span><br><span class="line">  <span class="keyword">while</span> (n - <span class="number">1</span>) &#123;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">    n--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (fast.next) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">  &#125;</span><br><span class="line">  slow.next = slow.next.next;</span><br><span class="line">  <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第14天-No.173二叉搜索树迭代器</title>
    <url>/2021/03/28/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC14%E5%A4%A9-No-173%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p>
<a id="more"></a>
<p>BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。<br>boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。<br>int next()将指针向右移动，然后返回指针处的数字。<br>注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。</p>
<p>你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。</p>
<p>示例：</p>
<pre>
输入
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
输出
[null, 3, 7, true, 9, true, 15, true, 20, false]

解释
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // 返回 3
bSTIterator.next();    // 返回 7
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 9
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 15
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 20
bSTIterator.hasNext(); // 返回 False
</pre>

<p>注意：</p>
<pre>
树中节点的数目在范围 [1, 105] 内
0 <= Node.val <= 106
最多调用 105 次 hasNext 和 next 操作
</pre>

<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>扁平化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> BSTIterator = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.index = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.list = [];</span><br><span class="line">  <span class="built_in">this</span>.LDR = <span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="built_in">this</span>.LDR(node.left);</span><br><span class="line">      <span class="built_in">this</span>.list.push(node.val);</span><br><span class="line">      <span class="built_in">this</span>.LDR(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.LDR(root);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BSTIterator.prototype.next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.list[<span class="built_in">this</span>.index++];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BSTIterator.prototype.hasNext = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.index &lt; <span class="built_in">this</span>.list.length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new BSTIterator(root)</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.next()</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.hasNext()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>栈</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> BSTIterator = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.cur = root;</span><br><span class="line">  <span class="built_in">this</span>.stack = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BSTIterator.prototype.next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">this</span>.cur) &#123;</span><br><span class="line">    <span class="built_in">this</span>.stack.push(<span class="built_in">this</span>.cur);</span><br><span class="line">    <span class="built_in">this</span>.cur = <span class="built_in">this</span>.cur.left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.cur = <span class="built_in">this</span>.stack.pop();</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="built_in">this</span>.cur.val;</span><br><span class="line">  <span class="built_in">this</span>.cur = <span class="built_in">this</span>.cur.right;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BSTIterator.prototype.hasNext = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.cur || <span class="built_in">this</span>.stack.length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new BSTIterator(root)</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.next()</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.hasNext()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第13天-No.61旋转链表</title>
    <url>/2021/03/27/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC13%E5%A4%A9-No-61%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p>
<a id="more"></a>
<p>示例：</p>
<pre>
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]

输入：head = [0,1,2], k = 4
输出：[2,0,1]
</pre>

<p>注意：</p>
<pre>
链表中节点的数目在范围 [0, 500] 内
-100 <= Node.val <= 100
0 <= k <= 2 * 10^9
</pre>

<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>闭合成环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> rotateRight = <span class="function"><span class="keyword">function</span> (<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (k === <span class="number">0</span> || !head || !head.next) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> cur = head;</span><br><span class="line">  <span class="keyword">while</span> (cur.next) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    cur = cur.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> step = count - k % count;</span><br><span class="line">  <span class="keyword">if</span> (step === count) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  cur.next = head;</span><br><span class="line">  <span class="keyword">while</span> (step) &#123;</span><br><span class="line">    cur = cur.next;</span><br><span class="line">    step--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ret = cur.next;</span><br><span class="line">  cur.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>双指针（快慢指针）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> rotateRight = <span class="function"><span class="keyword">function</span> (<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (k === <span class="number">0</span> || !head || !head.next) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> cur = head;</span><br><span class="line">  <span class="keyword">while</span> (cur.next) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    cur = cur.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> rk = k % count;</span><br><span class="line">  <span class="keyword">if</span> (rk === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> slow = head;</span><br><span class="line">  <span class="keyword">let</span> fast = head;</span><br><span class="line">  <span class="keyword">while</span> (rk &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">    rk--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (fast.next) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> newHead = slow.next;</span><br><span class="line">  slow.next = <span class="literal">null</span>;</span><br><span class="line">  fast.next = head;</span><br><span class="line">  <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第15天-No.190颠倒二进制位</title>
    <url>/2021/03/29/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC15%E5%A4%A9-No-190%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>颠倒给定的 32 位无符号整数的二进制位。</p>
<a id="more"></a>

<p>示例：</p>
<pre>
输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
</pre>

<p>注意：</p>
<pre>
输入是一个长度为 32 的二进制字符串
</pre>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>调用函数懒蛋法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span> - a positive integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>- a positive integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> reverseBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(n.toString(<span class="number">2</span>).padStart(<span class="number">32</span>, <span class="number">0</span>).split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>), <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>位运算</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span> - a positive integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>- a positive integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> reverseBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    ret = (ret &lt;&lt; <span class="number">1</span>) + (n &amp; <span class="number">1</span>);</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>分治</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span> - a positive integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>- a positive integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> reverseBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> M1 = <span class="number">0b01010101010101010101010101010101</span>;</span><br><span class="line">  <span class="keyword">let</span> M2 = <span class="number">0b00110011001100110011001100110011</span>;</span><br><span class="line">  <span class="keyword">let</span> M3 = <span class="number">0b00001111000011110000111100001111</span>;</span><br><span class="line">  <span class="keyword">let</span> M4 = <span class="number">0b00000000111111110000000011111111</span>;</span><br><span class="line">  n = n &gt;&gt;&gt; <span class="number">1</span> &amp; M1 | (n &amp; M1) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  n = n &gt;&gt;&gt; <span class="number">2</span> &amp; M2 | (n &amp; M2) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  n = n &gt;&gt;&gt; <span class="number">4</span> &amp; M3 | (n &amp; M3) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  n = n &gt;&gt;&gt; <span class="number">8</span> &amp; M4 | (n &amp; M4) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">return</span> (n &gt;&gt;&gt; <span class="number">16</span> | n &lt;&lt; <span class="number">16</span>) &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第14天-No.24两两交换链表中的节点</title>
    <url>/2021/03/28/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC14%E5%A4%A9-No-24%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<a id="more"></a>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例：</p>
<pre>
输入：head = [1,2,3,4]
输出：[2,1,4,3]

输入：head = []
输出：[]

输入：head = [1]
输出：[1]
</pre>

<p>注意：</p>
<pre>
链表中节点的数目在范围 [0, 100] 内
0 <= Node.val <= 100
</pre>

<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>迭代</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dummyNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">  <span class="keyword">let</span> cur = dummyNode;</span><br><span class="line">  <span class="keyword">while</span> (cur.next &amp;&amp; cur.next.next) &#123;</span><br><span class="line">    <span class="keyword">let</span> first = cur.next;</span><br><span class="line">    <span class="keyword">let</span> second = cur.next.next;</span><br><span class="line">    <span class="keyword">let</span> third = cur.next.next.next;</span><br><span class="line">    cur.next = second;</span><br><span class="line">    second.next = first;</span><br><span class="line">    first.next = third;</span><br><span class="line">    cur = cur.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>递归</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> swapPairs = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> needSwap = head.next;</span><br><span class="line">  head.next = swapPairs(needSwap.next);</span><br><span class="line">  needSwap.next = head;</span><br><span class="line">  <span class="keyword">return</span> needSwap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第1天-No.54螺旋矩阵</title>
    <url>/2021/03/15/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC1%E5%A4%A9-No-54%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 m 行 n 列的矩阵 matrix ，请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/spiral-matrix.png" alt="spiral-matrix"></p>
<blockquote>
<p>如遇图片无法显示请访问 <a href="https://leetcode-cn.com/problems/spiral-matrix/">力扣-螺旋矩阵</a></p>
</blockquote>
<p>示例：</p>
<pre>
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
</pre>
<p>注意：</p>
<pre>
m == matrix.length
n == matrix[i].length
1 <= m, n <= 10
-100 <= matrix[i][j] <= 100
</pre>

<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>模拟螺旋路径：从矩阵的左上角开始，初始向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> spiralOrder = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!matrix.length || !matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> rows = matrix.length;</span><br><span class="line">  <span class="keyword">const</span> columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">const</span> total = rows * columns;</span><br><span class="line">  <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Array</span>(rows).fill(<span class="number">0</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(columns).fill(<span class="literal">false</span>)); <span class="comment">// 访问数组</span></span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> row = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> column = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> directions = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">-1</span>], [<span class="number">-1</span>, <span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">    result.push(matrix[row][column]);</span><br><span class="line">    visited[row][column] = <span class="literal">true</span>; <span class="comment">// 为访问过的元素设置标志</span></span><br><span class="line">    <span class="comment">/* 获取下一个元素的行列坐标 */</span></span><br><span class="line">    <span class="keyword">let</span> nextRow = row + directions[directionIndex][<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">let</span> nextColumn = column + directions[directionIndex][<span class="number">1</span>]; </span><br><span class="line">    <span class="keyword">if</span> (!(nextRow &gt;= <span class="number">0</span> &amp;&amp; nextRow &lt; rows &amp;&amp; nextColumn &gt;= <span class="number">0</span> &amp;&amp; nextColumn &lt; columns &amp;&amp; !visited[nextRow][nextColumn])) &#123;</span><br><span class="line">      directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>; <span class="comment">// 顺时针旋转，利用 directions 和 directionIndex 控制元素行列坐标的变化</span></span><br><span class="line">    &#125;</span><br><span class="line">    row += directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">    column += directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>转圈遍历：四个方向循环进行遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> spiralOrder = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!matrix.length || !matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">      <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> bottom = matrix.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> total = matrix.length * matrix[<span class="number">0</span>].length;</span><br><span class="line">  <span class="comment">/* 顺时针螺旋遍历 */</span></span><br><span class="line">  <span class="keyword">while</span> (total &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right &amp;&amp; total &gt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">      result.push(matrix[top][i]);</span><br><span class="line">      total--;</span><br><span class="line">    &#125;</span><br><span class="line">    top++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = top; i &lt;= bottom &amp;&amp; total &gt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">      result.push(matrix[i][right]);</span><br><span class="line">      total--;</span><br><span class="line">    &#125;</span><br><span class="line">    right--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = right; i &gt;= left &amp;&amp; total &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">      result.push(matrix[bottom][i]);</span><br><span class="line">      total--;</span><br><span class="line">    &#125;</span><br><span class="line">    bottom--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = bottom; i &gt;= top &amp;&amp; total &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">      result.push(matrix[i][left]);</span><br><span class="line">      total--;</span><br><span class="line">    &#125;</span><br><span class="line">    left++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第2天-No.59螺旋矩阵2</title>
    <url>/2021/03/16/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC2%E5%A4%A9-No-59%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B52/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个正整数 n ，生成一个包含 1 到 n * n所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵。</p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/spiraln-matrix2.jpg" alt="spiral-matrix"></p>
<blockquote>
<p>如遇图片无法显示请访问 <a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">力扣-螺旋矩阵2</a></p>
</blockquote>
<p>示例：</p>
<pre>
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
</pre>

<p>注意：</p>
<pre>
1 <= n <= 20
</pre>

<h2 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h2><p>模拟螺旋路径：与螺旋矩阵的解法一类似，从矩阵的左上角开始，初始向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> generateMatrix = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="number">1</span>]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> row = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> column = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> directions = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">-1</span>], [<span class="number">-1</span>, <span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">while</span> (num &lt;= n * n) &#123;</span><br><span class="line">    result[row][column] = num++;</span><br><span class="line">    <span class="comment">/* 获取下一个元素的行列坐标 */</span></span><br><span class="line">    <span class="keyword">let</span> nextRow = row + directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> nextColumn = column + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (!(nextRow &gt;= <span class="number">0</span> &amp;&amp; nextRow &lt; n &amp;&amp; nextColumn &gt;= <span class="number">0</span> &amp;&amp; nextColumn &lt; n &amp;&amp; !result[nextRow][nextColumn])) &#123;</span><br><span class="line">      directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>; <span class="comment">// 顺时针旋转</span></span><br><span class="line">    &#125;</span><br><span class="line">    row += directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">    column += directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>转圈遍历：与螺旋矩阵的解法二类似，四个方向循环进行遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> generateMatrix = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="number">1</span>]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> bottom = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/* 顺时针螺旋遍历 */</span></span><br><span class="line">  <span class="keyword">while</span> (num &lt;= n * n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">      res[top][i] = num++;</span><br><span class="line">    &#125;</span><br><span class="line">    top++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = top; i &lt;= bottom; i++) &#123;</span><br><span class="line">      res[i][right] = num++;</span><br><span class="line">    &#125;</span><br><span class="line">    right--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = right; i &gt;= left; i--) &#123;</span><br><span class="line">      res[bottom][i] = num++;</span><br><span class="line">    &#125;</span><br><span class="line">    bottom--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = bottom; i &gt;= top; i--) &#123;</span><br><span class="line">      res[i][left] = num++;</span><br><span class="line">    &#125;</span><br><span class="line">    left++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第2天-No.8字符串转换整数</title>
    <url>/2021/03/16/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC2%E5%A4%A9-No-8%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</p>
<a id="more"></a>
<p>函数 myAtoi(string s) 的算法如下：</p>
<ol>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。如果两者都不存在，则假定结果为正。</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。<br>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</li>
<li>如果整数数超过 32 位有符号整数范围 [−2 ** 31,  2 ** 31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2 ** 31 的整数应该被固定为 −2 ** 31 ，大于 2 ** 31 − 1 的整数应该被固定为 2 ** 31 − 1 。</li>
<li>返回整数作为最终结果。</li>
</ol>
<p>示例：</p>
<pre>
输入：s = "4193 with words"
输出：4193
输入：s = "words and 987"
输出：0
输入：s = "   -42"
输出：-42
输入：s = "-91283472332"
输出：-2147483648（-2 ** 31）
</pre>

<p>注意：</p>
<pre>
本题中的空白字符只包括空格字符 ' ' 。
除前导空格或数字后的其余字符串外，请勿忽略任何其他字符。
0 <= s.length <= 200
s 由英文字母（大写和小写）、数字（0-9）、' '、'+'、'-' 和 '.' 组成
</pre>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>这里只介绍有限状态机（DFA），类似于编译原理：</p>
<p>状态转换表：<br><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/DFA_excel.png" alt="stateTurnExcel"></p>
<p>状态转换图：<br><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/DFA_pic.png" alt="stateTurnPic"></p>
<blockquote>
<p>如遇图片无法显示请访问 <a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">力扣-字符串转整数</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> myAtoi = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Automation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = <span class="string">&#x27;start&#x27;</span>; <span class="comment">// 开始状态</span></span><br><span class="line">      <span class="built_in">this</span>.sign = <span class="number">1</span>; <span class="comment">// 1代表正，0代表负</span></span><br><span class="line">      <span class="built_in">this</span>.res = <span class="number">0</span>; <span class="comment">// 初始数值为0</span></span><br><span class="line">      <span class="comment">/* 定义状态转换表 */</span></span><br><span class="line">      <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">        <span class="comment">//状态，遇到 =&gt; [空格，正负号，字符型数值，其他字符]，会跳到对应的状态</span></span><br><span class="line">        [<span class="string">&#x27;start&#x27;</span>, [<span class="string">&#x27;start&#x27;</span>, <span class="string">&#x27;signed&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>]],</span><br><span class="line">        [<span class="string">&#x27;signed&#x27;</span>, [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>]],</span><br><span class="line">        [<span class="string">&#x27;in_number&#x27;</span>, [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;in_number&#x27;</span>, <span class="string">&#x27;end&#x27;</span>]],</span><br><span class="line">        [<span class="string">&#x27;end&#x27;</span>, [<span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>, <span class="string">&#x27;end&#x27;</span>]]</span><br><span class="line">      ]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取每种字符对应的即将转换到的状态索引 */</span></span><br><span class="line">    getStateIndex(char) &#123;</span><br><span class="line">      <span class="keyword">if</span> (char === <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">// 空格</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&#x27;+&#x27;</span> || char === <span class="string">&#x27;-&#x27;</span>) &#123; <span class="comment">//正负号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">parseInt</span>(char) &gt;= <span class="number">0</span>) &#123; <span class="comment">// 字符型数值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 其他字符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 对输入的字符进行状态转换 并处理数据 */</span></span><br><span class="line">    turnAndHandle(char) &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = <span class="built_in">this</span>.map.get(<span class="built_in">this</span>.state)[<span class="built_in">this</span>.getStateIndex(char)];</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&#x27;in_number&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.res = <span class="built_in">this</span>.res * <span class="number">10</span> + (char - <span class="number">0</span>); <span class="comment">// 计算数值</span></span><br><span class="line">        <span class="built_in">this</span>.res = <span class="built_in">this</span>.sign === <span class="number">1</span> ? <span class="built_in">Math</span>.min(<span class="built_in">this</span>.res, <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) : <span class="built_in">Math</span>.min(<span class="built_in">this</span>.res, -<span class="built_in">Math</span>.pow(<span class="number">-2</span>, <span class="number">31</span>)); <span class="comment">// 判断是否溢出</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&#x27;signed&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sign = char === <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>; <span class="comment">// 设置正负号</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> automaton = <span class="keyword">new</span> Automation();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> s) &#123; <span class="comment">// 遍历字符串的每一个字符</span></span><br><span class="line">    automaton.turnAndHandle(char);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> automaton.sign * automaton.res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第3天-No.115不同的子序列</title>
    <url>/2021/03/17/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC3%E5%A4%A9-No-115%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<a id="more"></a>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
<p>示例：</p>
<pre>
输入：s = "babgbag", t = "bag"
输出：5
解释：
如下所示, 有 5 种可以从 s 中得到 "bag" 的方案。 
(上箭头符号 ^ 表示选取的字母)
babgbag
^^ ^
babgbag
^^    ^
babgbag
^    ^^
babgbag
  ^  ^^
babgbag
    ^^^
</pre>

<p>注意：</p>
<pre>
0 <= s.length, t.length <= 1000
s 和 t 由英文字母组成
</pre>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>动态规划：</p>
<p>假设 m = s.length，n = t.length，<br>创建二维数组 dp，dp[i][j] 表示在 s[i:] 的子序列中 t[j:] 出现的个数，<br>s[i:] 表示 s 从下标 i 到末尾的子字符串，t[j:] 表示 t 从下标 j 到末尾的子字符串，则有如下推断：</p>
<ul>
<li>当 m &lt; n 时，t 一定不是 s 的子序列；</li>
<li>当 j = n 时，t[j:] 为空字符串，因此对任意 0 &lt;= i &lt;= m，有 d[i][n] = 1;</li>
<li>当 i = m 时，s[i:] 为空字符串，因此对任意 0 &lt;= j &lt; n，dp[m][j] = 0;</li>
<li>当 i &lt; m 且 j &lt; n 时：<ol>
<li>如果 s[i] === s[j]，dp[i][j] 由两部分组成，选择 s[i]，则这部分的子序列数为 dp[i + 1][j + 1]，不选择 s[i]，则这部分的子序列数为 dp[i + 1][j]，因此，dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]；</li>
<li>如果 s[i] !== s[j]，则 dp[i][j] = dp[i + 1][j];</li>
</ol>
</li>
</ul>
<p>由此可得状态转移方程：</p>
<pre>
dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]  s[i] === s[j]
         = dp[i + 1][j]                     s[i] !== s[j]
</pre>

<p>最终 dp[0][0] 即为在 s 的子序列中 t 出现的个数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">t</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> numDistinct = <span class="function"><span class="keyword">function</span> (<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> m = s.length;</span><br><span class="line">  <span class="keyword">const</span> n = t.length;</span><br><span class="line">  <span class="keyword">if</span> (m &lt; n) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="number">0</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    dp[i][n] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] === t[j]) &#123;</span><br><span class="line">        dp[i][j] = dp[i + <span class="number">1</span>][j + <span class="number">1</span>] + dp[i + <span class="number">1</span>][j];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第1天-No.6 Z字形变换</title>
    <url>/2021/03/15/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC1%E5%A4%A9-No-6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 “PAYPALISHIRING” 行数为 4 时，排列如下：</p>
<a id="more"></a>
<pre>
P     I    N
A   L S  I G
Y A   H R
P     I
</pre>
<p>示例：</p>
<pre>
输入：s = "PAYPALISHIRING", numRows = 4
输出："PINALSIGYAHRPI"
</pre>

<p>注意：</p>
<pre>
1 <= s.length <= 1000
s 由英文字母（小写和大写）、',' 和 '.' 组成
1 <= numRows <= 1000
</pre>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>按行排序：从左到右迭代字符串，确定每个字符位于 Z 字形图案的哪一行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">numRows</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> convert = <span class="function"><span class="keyword">function</span> (<span class="params">s, numRows</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (numRows === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> rows = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.min(numRows, s.length); i++) &#123;</span><br><span class="line">    rows[i] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> curRow = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> goingDown = <span class="literal">false</span>; <span class="comment">// 控制方向</span></span><br><span class="line">  <span class="keyword">let</span> sLength = s.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; sLength; x++) &#123;</span><br><span class="line">    rows[curRow].push(s.charAt(x));</span><br><span class="line">    <span class="keyword">if</span> (curRow === <span class="number">0</span> || curRow === numRows - <span class="number">1</span>) &#123; <span class="comment">// 到达第一行和最后一行</span></span><br><span class="line">      goingDown = !goingDown; <span class="comment">// 调转方向</span></span><br><span class="line">    &#125;</span><br><span class="line">    curRow += goingDown ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> rowsLength = rows.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> row = <span class="number">0</span>; row &lt; rowsLength; row++) &#123;</span><br><span class="line">    result = result.concat(rows[row]); <span class="comment">// 连接各行</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第4天-No.1653使字符串平衡的最少删除次数</title>
    <url>/2021/03/18/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC4%E5%A4%A9-No-1653%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s ，它仅包含字符 ‘a’ 和 ‘b’​​​​ 。</p>
<a id="more"></a>
<p>你可以删除 s 中任意数目的字符，使得 s 平衡 。我们称 s 平衡的 当不存在下标对 (i,j) 满足 i &lt; j 且 s[i] = ‘b’ 同时 s[j]= ‘a’ 。</p>
<p>请你返回使 s 平衡 的 最少 删除次数。</p>
<p>示例：</p>
<pre>
输入：s = "aababbab"
输出：2
解释：你可以选择以下任意一种方案：
下标从 0 开始，删除第 2 和第 6 个字符（"aababbab" -> "aaabbb"），
下标从 0 开始，删除第 3 和第 6 个字符（"aababbab" -> "aabbbb"）。

输入：s = "bbaaaaabb"
输出：2
解释：唯一的最优解是删除最前面两个字符。
</pre>

<p>注意：</p>
<pre>
1 <= s.length <= 105
s[i] 要么是 'a' 要么是 'b'​ 。​
</pre>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>分析可得，最终得到的字符串如果从某处开始分割，左侧应全为’a’,右侧应全为’b’，且这个字符串在所有符合的结果中是最长的。</p>
<p>对于字符串中的每一个字符，统计它前面出现的’b’和后面出现的’a’，最少的总和即为最少的删除次数（或者统计前面’a’的数量和后面’b’的数量，用字符串长度减去最大总和即为最少的删除次数）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> minimumDeletions = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = s.length;</span><br><span class="line">  <span class="keyword">let</span> aCountBeforeI = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> bCountAfterI = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (s[<span class="number">0</span>] === <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">    aCountBeforeI[<span class="number">0</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s[len - <span class="number">1</span>] === <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">    bCountAfterI[len - <span class="number">1</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    aCountBeforeI[i] = (s[i] === <span class="string">&#x27;a&#x27;</span>) ? (aCountBeforeI[i - <span class="number">1</span>] + <span class="number">1</span>) : aCountBeforeI[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    bCountAfterI[i] = (s[i] === <span class="string">&#x27;b&#x27;</span>) ? (bCountAfterI[i + <span class="number">1</span>] + <span class="number">1</span>) : bCountAfterI[i + <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    res = <span class="built_in">Math</span>.max(res, aCountBeforeI[i] + bCountAfterI[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> len - res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第3天-No.1227飞机座位分配概率</title>
    <url>/2021/03/17/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC3%E5%A4%A9-No-1227%E9%A3%9E%E6%9C%BA%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D%E6%A6%82%E7%8E%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。</p>
<a id="more"></a>
<p>剩下的乘客将会：</p>
<ul>
<li>如果他们自己的座位还空着，就坐到自己的座位上，</li>
<li>当他们自己的座位被占用时，随机选择其他座位</li>
</ul>
<p>第 n 位乘客坐在自己的座位上的概率是多少？</p>
<p>示例：</p>
<pre>
输入：n = 1
输出：1.00000
解释：第一个人只会坐在自己的位置上。

输入: n = 2
输出: 0.50000
解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。
</pre>

<p>注意：</p>
<pre>
1 <= n <= 10^5
</pre>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>推导过程：</p>
<p>设第 n 位乘客坐在自己的座位上的概率为 f(n)</p>
<p>第一位乘客因票丢失，面临如下情况：</p>
<ul>
<li>他有 1 / n 的概率坐到正确的座位，则后面的乘客都会坐到自己的座位上，所以 f(n)’ = 1 / n；</li>
<li>他有 1 / n 的概率坐到第 n 位乘客的座位，则后面的乘客除了第 n 位都会坐到自己的座位上，而第 n 位乘客只能坐到第 1 位乘客的位置，所以 f(n)’ = 0；</li>
<li>他有 1 / n 的概率坐到第 i 位乘客的座位，其中 2 &lt;= i &lt;= n - 1，则第 2 到 i - 1 位乘客都能坐到自己的座位上，而当第 i 位乘客来到客舱，发现自己的座位被人（第 1 位乘客）占了，这时他会从剩下的 n - i + 1 随机选择一个座位坐下，因此他面临的情况和第 1 位乘客一样，只不过此时的第一种情况下，正确的座位是第 1 位乘客的座位，所以 f(n)’ = f(n - i + 1)；</li>
</ul>
<p>由此可以得到递推式：</p>
<p>f(n) = 1 / n * (1 + 0 + <strong>SUM[2, n-1] </strong>f(n - i + 1))，其中SUM[2, n-1]表示i从2到n-1对后面的式子进行求和</p>
<p>令 n = n - 1，则</p>
<p>f(n - 1) = 1 / (n - 1) * (1 + 0 + <strong>SUM[2, n-2] </strong>f(n - i))</p>
<p>两式相减得：n * f(n) - (n - 1) * f(n - 1) = f(n - 1)，即 f(n) = f(n - 1) = …… = f(2)</p>
<p>因此，对任意 n &gt;= 2，有 f(n) = f(2) = 0.5，当 n = 1，f(n) = 1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> nthPersonGetsNthSeat = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n === <span class="number">1</span> ? <span class="number">1</span> : <span class="number">.5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第4天-No.92反转链表2</title>
    <url>/2021/03/18/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC4%E5%A4%A9-No-92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<a id="more"></a>
<p>示例：</p>
<pre>
输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
</pre>

<p>注意：</p>
<pre>
1 <= m <= n <= 链表长度。
</pre>

<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>穿针引线：记录待反转区域的前一个节点和后一个节点，反转待反转区域，并调整指针指向。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">left</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">right</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> reverseBetween = <span class="function"><span class="keyword">function</span> (<span class="params">head, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reverseLinkList = <span class="function"><span class="keyword">function</span> (<span class="params">interHead</span>) </span>&#123; <span class="comment">// 反转链表</span></span><br><span class="line">    <span class="keyword">let</span> _prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> _curr = interHead;</span><br><span class="line">    <span class="keyword">while</span> (_curr) &#123;</span><br><span class="line">      <span class="keyword">let</span> _nextTemp = _curr.next;</span><br><span class="line">      _curr.next = _prev;</span><br><span class="line">      _prev = _curr;</span><br><span class="line">      _curr = _nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> dummyNode = <span class="keyword">new</span> ListNode(<span class="number">-1</span>); <span class="comment">// 设置虚拟节点</span></span><br><span class="line">  dummyNode.next = head;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 获取待反转区域的前一个节点 */</span></span><br><span class="line">  <span class="keyword">let</span> prev = dummyNode;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    prev = prev.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 获取待反转区域中的最后一个节点 */</span></span><br><span class="line">  <span class="keyword">let</span> rightNode = prev;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    rightNode = rightNode.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> leftNode = prev.next; <span class="comment">// 获取待反转区域中的第一个节点</span></span><br><span class="line">  <span class="keyword">let</span> curr = rightNode.next; <span class="comment">//获取待反转区域的后一个节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 截断链表 */</span></span><br><span class="line">  prev.next = <span class="literal">null</span>;</span><br><span class="line">  rightNode.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  reverseLinkList(leftNode); <span class="comment">// 反转待反转区域</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将反转后的子链表连接回原来的链表中 */</span></span><br><span class="line">  prev.next = rightNode;</span><br><span class="line">  leftNode.next = curr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>穿针引线之原地反转：在遍历待反转区域时，原地调整节点的指针指向，详见：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/">一次遍历-反转链表</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">left</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">right</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> reverseBetween = <span class="function"><span class="keyword">function</span> (<span class="params">head, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dummyNode = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">  dummyNode.next = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> prev = dummyNode;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    prev = prev.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> curr = prev.next;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = curr.next;</span><br><span class="line">    curr.next = next.next;</span><br><span class="line">    next.next = prev.next;</span><br><span class="line">    prev.next = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第5天-No.1603设计停车系统</title>
    <url>/2021/03/19/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC5%E5%A4%A9-No-1603%E8%AE%BE%E8%AE%A1%E5%81%9C%E8%BD%A6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。</p>
<a id="more"></a>
<p>请你实现 ParkingSystem 类：</p>
<p>ParkingSystem(int big, int medium, int small) 初始化 ParkingSystem 类，三个参数分别对应每种停车位的数目。<br>bool addCar(int carType) 检查是否有 carType 对应的停车位。 carType 有三种类型：大，中，小，分别用数字 1， 2 和 3 表示。一辆车只能停在  carType 对应尺寸的停车位中。如果没有空车位，请返回 false ，否则将该车停入车位并返回 true 。</p>
<p>示例：</p>
<pre>
输入：
["ParkingSystem", "addCar", "addCar", "addCar", "addCar"]
[[1, 1, 0], [1], [2], [3], [1]]
输出：
[null, true, true, false, false]

解释：
ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);
parkingSystem.addCar(1); // 返回 true ，因为有 1 个空的大车位
parkingSystem.addCar(2); // 返回 true ，因为有 1 个空的中车位
parkingSystem.addCar(3); // 返回 false ，因为没有空的小车位
parkingSystem.addCar(1); // 返回 false ，因为没有空的大车位，唯一一个大车位已经被占据了
</pre>

<p>注意：</p>
<pre>
0 <= big, medium, small <= 1000
carType 取值为 1， 2 或 3
最多会调用 addCar 函数 1000 次
</pre>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>非常朴素的解法，也可以使用 carType 作为实例对象的键，或者将三个数量集中在一起管理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">big</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">medium</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">small</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> ParkingSystem = <span class="function"><span class="keyword">function</span>(<span class="params">big, medium, small</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.big = big;</span><br><span class="line">  <span class="built_in">this</span>.medium = medium;</span><br><span class="line">  <span class="built_in">this</span>.small = small;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">carType</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ParkingSystem.prototype.addCar = <span class="function"><span class="keyword">function</span>(<span class="params">carType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (carType === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.big &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.big--;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (carType === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.medium &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.medium--;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (carType === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.small &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.small--;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ParkingSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new ParkingSystem(big, medium, small)</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.addCar(carType)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第6天-No.150逆波兰表达式求值</title>
    <url>/2021/03/20/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC6%E5%A4%A9-No-150%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据 逆波兰表示法，求表达式的值。</p>
<a id="more"></a>
<p>有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p>示例：</p>
<pre>
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6

输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：
该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
</pre>

<p>注意：</p>
<pre>
1 <= tokens.length <= 104
tokens[i] 要么是一个算符（"+"、"-"、"*" 或 "/"），要么是一个在范围 [-200, 200] 内的整数
</pre>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><pre>
下面以(a+b)*c为例子进行说明：
(a+b)*c的逆波兰式为ab+c*，假设计算机把ab+c*按从左到右的顺序压入栈中，
并且按照遇到运算符就把栈顶两个元素出栈，执行运算，得到的结果再入栈的原则来进行处理，
那么ab+c*的执行结果如下：

1. a入栈（0位置）
2. b入栈（1位置）
3. 遇到运算符“+”，将a和b出栈，执行a+b的操作，得到结果d=a+b，再将d入栈（0位置）
4. c入栈（1位置）
5. 遇到运算符“d”，执行d*c的操作，得到结果e，再将e入栈（0位置）

经过以上运算，就可以得到(a+b)*c的运算结果e了。
</pre>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">tokens</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> evalRPN = <span class="function"><span class="keyword">function</span> (<span class="params">tokens</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 构建栈类，当然也可以使用数组，因为js中的数组也有push和pop方法 */</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向栈中插入元素</span></span><br><span class="line">    push(element) &#123;</span><br><span class="line">      <span class="built_in">this</span>.items[<span class="built_in">this</span>.count] = element;</span><br><span class="line">      <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取栈的大小</span></span><br><span class="line">    size() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从栈中弹出元素</span></span><br><span class="line">    pop() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.count--;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="built_in">this</span>.items[<span class="built_in">this</span>.count];</span><br><span class="line">      <span class="keyword">delete</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.count];</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">let</span> len = tokens.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tokens[i] !== <span class="string">&#x27;+&#x27;</span> &amp;&amp; tokens[i] !== <span class="string">&#x27;-&#x27;</span> &amp;&amp; tokens[i] !== <span class="string">&#x27;*&#x27;</span> &amp;&amp; tokens[i] !== <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">      stack.push(<span class="built_in">parseInt</span>(tokens[i]));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> operator2 = stack.pop();</span><br><span class="line">      <span class="keyword">let</span> operator1 = stack.pop();</span><br><span class="line">      <span class="keyword">let</span> result;</span><br><span class="line">      <span class="keyword">switch</span> (tokens[i]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">          result = operator1 + operator2;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">          result = operator1 - operator2;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">          result = operator1 * operator2;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">          result = <span class="built_in">parseInt</span>(operator1 /  operator2);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      stack.push(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第5天-No.77组合</title>
    <url>/2021/03/19/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC5%E5%A4%A9-No-77%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<a id="more"></a>
<p>示例：</p>
<pre>
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</pre>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>回溯法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> combine = <span class="function"><span class="keyword">function</span> (<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> resSet = [];</span><br><span class="line">  <span class="keyword">let</span> eachRes = [];</span><br><span class="line">  <span class="keyword">let</span> backtracking = <span class="function"><span class="keyword">function</span> (<span class="params">startIndex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eachRes.length === k) &#123;</span><br><span class="line">      resSet.push(eachRes.slice());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = startIndex; i &lt;= n - (k - eachRes.length) + <span class="number">1</span>; i++) &#123; <span class="comment">// 横向遍历并剪枝</span></span><br><span class="line">      eachRes.push(i);</span><br><span class="line">      backtracking(i + <span class="number">1</span>); <span class="comment">// 递归，纵向遍历</span></span><br><span class="line">      eachRes.pop(); <span class="comment">// 回溯，撤销之前的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  backtracking(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> resSet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第6天-No.1556千位分隔数</title>
    <url>/2021/03/20/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC6%E5%A4%A9-No-1556%E5%8D%83%E4%BD%8D%E5%88%86%E9%9A%94%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数 n，请你每隔三位添加点（即 “.” 符号）作为千位分隔符，并将结果以字符串格式返回。</p>
<a id="more"></a>
<p>示例：</p>
<pre>
输入：n = 987
输出："987"

输入：n = 1234
输出："1.234"

输入：n = 123456789
输出："123.456.789"

输入：n = 0
输出："0"
</pre>

<p>注意：</p>
<pre>
0 <= n < 2^31
</pre>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>反向遍历字符数组，每隔3个字符插入 ‘.’</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> thousandSeparator = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(n);</span><br><span class="line">  <span class="keyword">let</span> arr = str.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">let</span> i = len;</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    arr.splice(i, <span class="number">0</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    i -= <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  arr.pop();</span><br><span class="line">  <span class="keyword">return</span> arr.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第8天-No.191位1的个数</title>
    <url>/2021/03/22/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC8%E5%A4%A9-No-191%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（汉明重量）。</p>
<a id="more"></a>
<p>示例：</p>
<pre>
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
</pre>

<p>注意：</p>
<pre>
输入必须是长度为 32 的 二进制串
</pre>

<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>位运算</p>
<p>n &amp; n - 1，将会使 n 对应的二进制串的最低位 1 置为 0 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span> - a positive integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> hammingWeight = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (n) &#123;</span><br><span class="line">    n &amp;= n - <span class="number">1</span>;</span><br><span class="line">    ret++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>位运算 + 左移</p>
<p>将 n 对应的二进制串的每一位与 1 进行 &amp; 运算</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span> - a positive integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> hammingWeight = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">      ret++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>懒蛋法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hammingWeight = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n.toString(<span class="number">2</span>).split(<span class="string">&#x27;&#x27;</span>).filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item === <span class="string">&#x27;1&#x27;</span>).length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第7天-No.1701平均等待时间</title>
    <url>/2021/03/21/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC7%E5%A4%A9-No-1701%E5%B9%B3%E5%9D%87%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个餐厅，只有一位厨师。你有一个顾客数组 customers ，其中 customers[i] = [arrival<sub>i</sub>, time<sub>i</sub>] ：</p>
<a id="more"></a>
<p>arrival<sub>i</sub> 是第 i 位顾客到达的时间，到达时间按非递减顺序排列。<br>time<sub>i</sub> 是给第 i 位顾客做菜需要的时间。<br>当一位顾客到达时，他将他的订单给厨师，厨师一旦空闲的时候就开始做这位顾客的菜。每位顾客会一直等待到厨师完成他的订单。厨师同时只能做一个人的订单。厨师会严格按照订单给他的顺序做菜。</p>
<p>请你返回所有顾客需要等待的平均时间。与标准答案误差在 10^-5 范围以内，都视为正确结果。</p>
<p>示例：</p>
<pre>
输入：customers = [[5,2],[5,4],[10,3],[20,1]]
输出：3.25000
解释：
1) 第一位顾客在时刻 5 到达，厨师拿到他的订单并在时刻 5 立马开始做菜，并在时刻 7 完成，第一位顾客等待时间为 7 - 5 = 2 。
2) 第二位顾客在时刻 5 到达，厨师在时刻 7 开始为他做菜，并在时刻 11 完成，第二位顾客等待时间为 11 - 5 = 6 。
3) 第三位顾客在时刻 10 到达，厨师在时刻 11 开始为他做菜，并在时刻 14 完成，第三位顾客等待时间为 14 - 10 = 4 。
4) 第四位顾客在时刻 20 到达，厨师拿到他的订单并在时刻 20 立马开始做菜，并在时刻 21 完成，第四位顾客等待时间为 21 - 20 = 1 。
平均等待时间为 (2 + 6 + 4 + 1) / 4 = 3.25 。
</pre>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>模拟</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">customers</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> averageWaitingTime = <span class="function"><span class="keyword">function</span> (<span class="params">customers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = customers.length;</span><br><span class="line">  <span class="keyword">let</span> done = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> waiting = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> arrival = customers[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> time = customers[i][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (arrival &lt;= done) &#123;</span><br><span class="line">      done += time;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      done = arrival + time;</span><br><span class="line">    &#125;</span><br><span class="line">    waiting += done - arrival;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> waiting / len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第8天-No.354俄罗斯套娃信封问题</title>
    <url>/2021/03/22/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC8%E5%A4%A9-No-354%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。</p>
<a id="more"></a>
<p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p>
<p>请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p>
<p>不允许旋转信封。</p>
<p>示例：</p>
<pre>
输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出：3
解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。

输入：envelopes = [[1,1],[1,1],[1,1]]
输出：1
</pre>

<p>注意：</p>
<pre>
1 <= envelopes.length <= 5000
envelopes[i].length == 2
1 <= wi, hi <= 10^4
</pre>

<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>动态规划</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">envelopes</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> maxEnvelopes = <span class="function"><span class="keyword">function</span> (<span class="params">envelopes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = envelopes.length;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* w作为第一关键字升序排列，h作为第二关键字降序排列 */</span></span><br><span class="line">  envelopes.sort(<span class="function">(<span class="params">e1, e2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e1[<span class="number">0</span>] !== e2[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> e1[<span class="number">0</span>] - e2[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> e2[<span class="number">1</span>] - e1[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">/* dp[i]表示h的前i个元素可以组成的最长递增子序列的长度，且必须选择第i个元素 */</span></span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (envelopes[j][<span class="number">1</span>] &lt; envelopes[i][<span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.max(dp[i], dp[j] + <span class="number">1</span>); <span class="comment">// 状态转移</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">Math</span>.max(ret, dp[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>动态规划 + 二分查找</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">envelopes</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> maxEnvelopes = <span class="function"><span class="keyword">function</span> (<span class="params">envelopes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> binarySearch = <span class="function"><span class="keyword">function</span> (<span class="params">arr, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">      <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((high - low) / <span class="number">2</span>) + low;</span><br><span class="line">      <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        high = mid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> n = envelopes.length;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* w作为第一关键字升序排列，h作为第二关键字降序排列 */</span></span><br><span class="line">  envelopes.sort(<span class="function">(<span class="params">e1, e2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e1[<span class="number">0</span>] !== e2[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> e1[<span class="number">0</span>] - e2[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> e2[<span class="number">1</span>] - e1[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">/* dp数组存放着最长递归子序列 */</span></span><br><span class="line">  <span class="keyword">let</span> dp = [envelopes[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> e = envelopes[i][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (e &gt; dp[dp.length - <span class="number">1</span>]) &#123;</span><br><span class="line">      dp.push(e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> index = binarySearch(dp, e);</span><br><span class="line">      dp[index] = e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第7天-No.73矩阵置零</title>
    <url>/2021/03/21/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC7%E5%A4%A9-No-73%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用原地算法。</p>
<a id="more"></a>
<p>示例：</p>
<pre>
输入：matrix = [
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出：[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]

输入：matrix = [
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出：[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
</pre>

<p>注意：</p>
<pre>
m == matrix.length
n == matrix[0].length
1 <= m, n <= 200
-2 ** 31 <= matrix[i][j] <= 2 ** 31 - 1
</pre>

<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>三重遍历，先标记，再替换，时间复杂度较高，不推荐</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> setZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = matrix.length;</span><br><span class="line">  <span class="keyword">let</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (matrix[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; n; x++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (matrix[i][x] !== <span class="number">0</span>) &#123;</span><br><span class="line">            matrix[i][x] = <span class="string">&#x27;will&#x27;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; m; x++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (matrix[x][j] !== <span class="number">0</span>) &#123;</span><br><span class="line">            matrix[x][j] = <span class="string">&#x27;will&#x27;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (matrix[i][j] === <span class="string">&#x27;will&#x27;</span>) &#123;</span><br><span class="line">        matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>使用第一行和第一列来标记某个元素是否是 0，最后进行替换，不过需要两个标记变量来记录第一行和第一列是否原本就存在 0</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> setZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = matrix.length;</span><br><span class="line">  <span class="keyword">let</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">let</span> firstRow = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> firstColumn = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] === <span class="number">0</span>) &#123;</span><br><span class="line">      firstRow = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] === <span class="number">0</span>) &#123;</span><br><span class="line">      firstColumn = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (matrix[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">        matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] === <span class="number">0</span> || matrix[<span class="number">0</span>][j] === <span class="number">0</span>) &#123;</span><br><span class="line">        matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (firstRow) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (firstColumn) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>类似于解法二，不过只使用一个标记变量，记录第一列是否原本存在 0，而第一列的第一个元素用来记录第一行是否原本存在 0，注意，为防止每一列的第一个元素被提前更新，需要从最后一行开始，倒序地处理矩阵元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">matrix</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> setZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = matrix.length;</span><br><span class="line">  <span class="keyword">let</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">let</span> firstColumn = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] === <span class="number">0</span>) &#123;</span><br><span class="line">      firstColumn = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (matrix[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">        matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] === <span class="number">0</span> || matrix[<span class="number">0</span>][j] === <span class="number">0</span>) &#123;</span><br><span class="line">        matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (firstColumn) &#123;</span><br><span class="line">      matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第9天-No.1317将整数转换为两个无零整数的和</title>
    <url>/2021/03/23/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC9%E5%A4%A9-No-1317%E5%B0%86%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%A4%E4%B8%AA%E6%97%A0%E9%9B%B6%E6%95%B4%E6%95%B0%E7%9A%84%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>「无零整数」是十进制表示中 不含任何 0 的正整数。</p>
<a id="more"></a>
<p>给你一个整数 n，请你返回一个 由两个整数组成的列表 [A, B]，满足：</p>
<p>A 和 B 都是无零整数<br>A + B = n<br>题目数据保证至少有一个有效的解决方案。</p>
<p>如果存在多个有效解决方案，你可以返回其中任意一个。</p>
<p>示例：</p>
<pre>
输入：n = 69
输出：[1,68]
</pre>

<p>注意：</p>
<pre>
2 <= n <= 10^4
</pre>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>枚举</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> getNoZeroIntegers = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (a &lt;= b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="string">&#x27;&#x27;</span> + a).includes(<span class="string">&#x27;0&#x27;</span>) &amp;&amp; !(<span class="string">&#x27;&#x27;</span> + b).includes(<span class="string">&#x27;0&#x27;</span>)) &#123; <span class="comment">// 经测试，&#x27;&#x27; + a 比 String(a) 速度要快 </span></span><br><span class="line">      <span class="keyword">return</span> [a, b];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      a++;</span><br><span class="line">      b--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>原型与原型链</title>
    <url>/2020/10/05/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="谈谈你对-JS-原型和原型链的理解？"><a href="#谈谈你对-JS-原型和原型链的理解？" class="headerlink" title="谈谈你对 JS 原型和原型链的理解？"></a>谈谈你对 JS 原型和原型链的理解？</h2><p>JS 原型是指为其它对象提供共享属性访问的对象。在创建对象时，每个对象都包含一个隐式引用指向它的原型对象或者 null，原型也是对象，因此它也有自己的原型，这样构成一个原型链。</p>
<a id="more"></a>
<h2 id="原型链有什么作用？"><a href="#原型链有什么作用？" class="headerlink" title="原型链有什么作用？"></a>原型链有什么作用？</h2><p>在访问一个对象的属性时，实际上是在查询原型链，这个对象是原型链的第一个元素，先检查它是否包含属性名，如果包含则返回属性值，否则检查原型链上的第二个元素，以此类推。</p>
<h2 id="那如何实现原型继承呢？"><a href="#那如何实现原型继承呢？" class="headerlink" title="那如何实现原型继承呢？"></a>那如何实现原型继承呢？</h2><p>有两种方式：一种是通过 Object.create 或者 Object.setPrototypeOf 显式继承另一个对象，将它设置为原型。另一种是通过 constructor 构造函数，在使用 new 关键字实例化时，会自动继承 constructor 的 prototype 对象，作为实例的原型。在 ES2015 中提供了 class 的风格，背后跟 constructor 工作方式一样，写起来更内聚一些。</p>
<h2 id="constructorB-如何继承-constructorA-？"><a href="#constructorB-如何继承-constructorA-？" class="headerlink" title="constructorB 如何继承 constructorA ？"></a>constructorB 如何继承 constructorA ？</h2><p>JS 里的继承，是对象跟对象之间的继承。constructor 的主要用途是初始化对象的属性。因此，两个 constructor 之间的继承，需要分开两个步骤。第一步是，编写新的 constructor，将两个 constructor 通过 call/apply 的方式，合并它们的属性初始化，按照超类优先的顺序进行。第二步是，取出超类和子类的原型对象，通过 Object.create/Object.setPrototypeOf 显式原型继承的方式，设置子类的原型为超类原型。整个过程手动编写起来比较繁琐，因此建议通过 ES2015 提供的 class 和 extends 关键字去完成继承，它内置了上述两个步骤。</p>
<h2 id="你能说一个原型里比较少人知道的特性吗？"><a href="#你能说一个原型里比较少人知道的特性吗？" class="headerlink" title="你能说一个原型里比较少人知道的特性吗？"></a>你能说一个原型里比较少人知道的特性吗？</h2><p>在 ES3 时代，只有访问属性的 get 操作能触发对原型链的查找。在 ES5 时代，新增了 accessor property 访问器属性的概念。它可以定义属性的 getter/setter 操作。具有访问器属性 setter 操作的对象，作为另一个对象的原型的时候，设置属性的 set 操作，也能触发对原型链的查找。普通对象的 <code>__proto__</code> 属性，其实就是在原型链查找出来的，它定义在 Object.prototype 对象上。</p>
<h2 id="一张图"><a href="#一张图" class="headerlink" title="一张图"></a>一张图</h2><p><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/%E5%8E%9F%E5%9E%8B.jpg" alt="alt"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣挑战赛第9天-No.341扁平化嵌套列表迭代器</title>
    <url>/2021/03/23/%E5%8A%9B%E6%89%A3%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%AC9%E5%A4%A9-No-341%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。</p>
<a id="more"></a>
<p>列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。</p>
<p>示例：</p>
<pre>
输入: [[1,1],2,[1,1]]
输出: [1,1,2,1,1]
解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。

输入: [1,[4,[6]]]
输出: [1,4,6]
解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,4,6]。
</pre>

<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>DFS</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * function NestedInteger() &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> *     this.isInteger = function() &#123;</span></span><br><span class="line"><span class="comment"> *         ...</span></span><br><span class="line"><span class="comment"> *     &#125;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     Return null if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     <span class="doctag">@return <span class="type">&#123;integer&#125;</span></span></span></span><br><span class="line"><span class="comment"> *     this.getInteger = function() &#123;</span></span><br><span class="line"><span class="comment"> *         ...</span></span><br><span class="line"><span class="comment"> *     &#125;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     Return null if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     <span class="doctag">@return <span class="type">&#123;NestedInteger[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> *     this.getList = function() &#123;</span></span><br><span class="line"><span class="comment"> *         ...</span></span><br><span class="line"><span class="comment"> *     &#125;;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;NestedInteger[]&#125;</span> <span class="variable">nestedList</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> NestedIterator = <span class="function"><span class="keyword">function</span>(<span class="params">nestedList</span>) </span>&#123;</span><br><span class="line">  flattenList = [];</span><br><span class="line">  <span class="keyword">let</span> dfs = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> ele <span class="keyword">of</span> list) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ele.isInteger()) &#123;</span><br><span class="line">        flattenList.push(ele.getInteger());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dfs(ele.getList());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(nestedList);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@this <span class="variable">NestedIterator</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NestedIterator.prototype.hasNext = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flattenList.length &gt; <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@this <span class="variable">NestedIterator</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;integer&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NestedIterator.prototype.next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> flattenList.shift();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NestedIterator will be called like this:</span></span><br><span class="line"><span class="comment"> * var i = new NestedIterator(nestedList), a = [];</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) a.push(i.next());</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>栈</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * function NestedInteger() &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> *     this.isInteger = function() &#123;</span></span><br><span class="line"><span class="comment"> *         ...</span></span><br><span class="line"><span class="comment"> *     &#125;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     Return null if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     <span class="doctag">@return <span class="type">&#123;integer&#125;</span></span></span></span><br><span class="line"><span class="comment"> *     this.getInteger = function() &#123;</span></span><br><span class="line"><span class="comment"> *         ...</span></span><br><span class="line"><span class="comment"> *     &#125;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     Return null if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     <span class="doctag">@return <span class="type">&#123;NestedInteger[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> *     this.getList = function() &#123;</span></span><br><span class="line"><span class="comment"> *         ...</span></span><br><span class="line"><span class="comment"> *     &#125;;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;NestedInteger[]&#125;</span> <span class="variable">nestedList</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> NestedIterator = <span class="function"><span class="keyword">function</span>(<span class="params">nestedList</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.stack = nestedList;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@this <span class="variable">NestedIterator</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NestedIterator.prototype.hasNext = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">this</span>.stack.length !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.stack[<span class="number">0</span>].isInteger()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> curr = <span class="built_in">this</span>.stack[<span class="number">0</span>].getList();</span><br><span class="line">      <span class="built_in">this</span>.stack.shift();</span><br><span class="line">      <span class="built_in">this</span>.stack.unshift(...curr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@this <span class="variable">NestedIterator</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;integer&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NestedIterator.prototype.next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack.shift().getInteger();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NestedIterator will be called like this:</span></span><br><span class="line"><span class="comment"> * var i = new NestedIterator(nestedList), a = [];</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) a.push(i.next());</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>双向数据绑定</title>
    <url>/2020/09/27/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Vue中的双向数据绑定"><a href="#Vue中的双向数据绑定" class="headerlink" title="Vue中的双向数据绑定"></a>Vue中的双向数据绑定</h2><p> Vue 最核心的功能有两个，一是响应式的数据绑定系统，二是组件化。来看下面的代码：<br> <a id="more"></a><br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;text&quot;</span>&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123;text&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;node_modules/vue/dist/vue.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                text: <span class="string">&quot;hello, world!&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br> 在浏览器中运行可以看到，随文本框输入文字的变化，span 中会同步显示相同的文字内容.这就是 Vue 中 model =&gt; view 以及 view =&gt; model 的双向数据绑定，如下图所示：<br><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/data.png" alt="alt"></p>
<h2 id="实现简单的双向数据绑定"><a href="#实现简单的双向数据绑定" class="headerlink" title="实现简单的双向数据绑定"></a>实现简单的双向数据绑定</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;input&quot;</span>&gt;</span><br><span class="line">    &lt;span id=<span class="string">&quot;span&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">        <span class="keyword">let</span> inputEle = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> spanEle = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">        <span class="comment">// 数据劫持</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;text&#x27;</span>, &#123;</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            get() &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;获取数据了&#x27;</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            set(newVal) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;数据更新了&#x27;</span>);</span><br><span class="line">                inputEle.value = newVal;</span><br><span class="line">                spanEle.innerHTML = newVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 输入监听</span></span><br><span class="line">        inputEle.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">            obj.text = e.target.value;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>在浏览器中运行此代码可以看到：随文本框输入文字的变化，span 中会同步显示相同的文字内容；在js或控制台显式的修改 obj.text 的值，视图会相应更新。这样就实现了 model =&gt; view 以及 view =&gt; model 的双向数据绑定，如下图所示：<br><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/data2.png" alt="alt"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>回首2020，启航2021</title>
    <url>/2021/01/01/%E5%9B%9E%E9%A6%962020%EF%BC%8C%E5%90%AF%E8%88%AA2021/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="回首2020"><a href="#回首2020" class="headerlink" title="回首2020"></a>回首2020</h2><p>2020年，我们经历了一次全球流行的传染病，至今新冠病毒仍在国外肆虐，国内疫情也时有反复，在此艰难的环境下，我们每个人都在奋力前行。</p>
<a id="more"></a>
<p>回顾我的2020年，也感慨万千，简单总结一下：</p>
<ul>
<li>年初纠结考研还是就业，想了好久，终于在4月底确定，放弃考研，准备就业，很快就确定了以后工作的方向，即前端</li>
<li>5月开始学习HTML和CSS，在此感谢腾讯课堂渡一教育的袁进老师，是他带我入门前端，我也逐渐培养起对前端的兴趣</li>
<li>6月和其他三个好兄弟一起做企业实训项目，即使当时前端基础很差，也在尽力帮忙完善团队项目，感谢他们对我的帮助和包容</li>
<li>7月和8月在全力突击JavaScript，说实话这段时间其实每天挺枯燥的，基本都是看书学习，做Demo，每天学累了刷抖音时是我最开心的时候，好在坚持了下来，这两个月对我后续的找工作打下了坚实的基础</li>
<li>8月底返校后，开始准备秋招，9月其实没开始投简历，还在学习，这段时间主要在学习ES6/ES7、jQuery、Vue、Webpack、Node.js等前端进阶知识</li>
<li>10月份算是我秋招的高潮，这段时间大量投简历，估计投了有几十份，同时每天基本都是刷面经、笔试和面试，这大概总共最后也参加了几十场，其实有两家公司我特别在意，一个是小米，另一个是一加，一加从简历筛选到专业笔试到技术一面，最后技术二面，整个流程下来，也持续了好久，可能由于二面表现不好，最终被刷，小米整个应聘流程下来也持续了一个月，最终在11月初给我发了offer，这时其实也收到了其他两家公司的offer，一家在上海，一家在深圳，我就遵循内心的意愿，接受小米offer并在11月底顺利入职</li>
<li>12月在公司的这一个月收获很多，学到了很多新的东西，认识了很多新朋友，希望自己能越来越好的走下去</li>
</ul>
<p>2020年是很特别的一年，这一年有很多人帮助过我，关心过我，使我不断向前，无所畏惧，感谢父母，感谢辅导员，感谢身边的好兄弟，是你们在不断支持我，我也成长了许多，谢谢你们</p>
<h2 id="启航2021"><a href="#启航2021" class="headerlink" title="启航2021"></a>启航2021</h2><p>2021年是新征程的开始，愿我们不负韶华，砥砺前行。</p>
<p>在此，我也立一下flag：</p>
<ul>
<li>找一个女朋友（非常重要）</li>
<li>早睡早起，健身减肥（尽量）</li>
<li>深入学习React技术栈，掌握React Native跨端开发能力（必须）</li>
<li>阅读优秀的前端开源项目源码，如Vue、React等（必须）</li>
<li>深入学习数据结构与算法、设计模式、性能优化等（必须）</li>
<li>多读，多说，提升英文能力（重要）</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现一个new</title>
    <url>/2020/10/27/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAnew/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="new做了什么"><a href="#new做了什么" class="headerlink" title="new做了什么"></a>new做了什么</h2><p>官方的解释：</p>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">new 关键字会进行如下的操作：</span><br><span class="line">1. 创建一个空的简单JavaScript对象（即&#123;&#125;）；</span><br><span class="line">2. 链接该对象（设置该对象的constructor）到另一个对象；</span><br><span class="line">3. 将步骤1新创建的对象作为this的上下文；</span><br><span class="line">4. 如果该函数没有返回对象，则返回this。</span><br><span class="line"></span><br><span class="line">当代码 new Foo(...) 执行时，会发生以下事情：</span><br><span class="line">1. 一个继承自 Foo.prototype 的新对象被创建；</span><br><span class="line">2. 使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。</span><br><span class="line">3. 由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</span><br></pre></td></tr></table></figure>
<p>即 new 操作符其实做了这些事情：</p>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） ；</li>
<li>执行构造函数中的代码（为这个新对象添加属性） ；</li>
<li>如果构造函数没有显式返回一个对象，就返回步骤1创建的新对象，否则返回构造函数的结果。<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> constr = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(constr.prototype);</span><br><span class="line">    <span class="keyword">const</span> result = constr.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
测试如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.job = job;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// var person = new Person(&#x27;cxs&#x27;, 21, &#x27;Front-end developer&#x27;);</span></span><br><span class="line"><span class="keyword">var</span> person = myNew(Person, <span class="string">&#x27;cxs&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;Front-end developer&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// cxs</span></span><br><span class="line">person.sayName();        <span class="comment">// cxs</span></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
显式返回对象的情况：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.job = job;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        love: <span class="string">&quot;前端&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = myNew(Person, <span class="string">&#x27;cxs&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;Front-end developer&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(person.love); <span class="comment">// 前端</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现一个深拷贝</title>
    <url>/2020/10/27/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="深拷贝的简单实现"><a href="#深拷贝的简单实现" class="headerlink" title="深拷贝的简单实现"></a>深拷贝的简单实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">source, hash = new WeakMap()</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (source === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (source === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(source);</span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(source);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> source !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span> source;</span><br><span class="line">    <span class="keyword">if</span> (hash.has(source)) <span class="keyword">return</span> hash.get(source);</span><br><span class="line">    <span class="keyword">let</span> target = <span class="keyword">new</span> source.__proto__.constructor;</span><br><span class="line">    hash.set(source, target);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) </span><br><span class="line">            target[key] = cloneDeep(source[key], hash);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="特殊对象的拷贝例子"><a href="#特殊对象的拷贝例子" class="headerlink" title="特殊对象的拷贝例子"></a>特殊对象的拷贝例子</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">pname</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = pname;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> Bob = <span class="keyword">new</span> person(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;cxs&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a1: <span class="literal">undefined</span>,</span><br><span class="line">    a2: <span class="literal">null</span>,</span><br><span class="line">    a3: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">    a4: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;ab+c&#x27;</span>, <span class="string">&#x27;i&#x27;</span>),</span><br><span class="line">    a5: <span class="regexp">/^123$/</span>,</span><br><span class="line">    a6: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    a7: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    a8: Bob</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = cloneDeep(a);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: <span class="string">&#x27;cxs&#x27;</span>,</span><br><span class="line">  book: &#123; <span class="attr">title</span>: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>, <span class="attr">price</span>: <span class="string">&#x27;45&#x27;</span> &#125;,</span><br><span class="line">  a1: <span class="literal">undefined</span>,</span><br><span class="line">  a2: <span class="literal">null</span>,</span><br><span class="line">  a3: <span class="number">2020</span><span class="number">-10</span><span class="number">-27</span>T11:<span class="number">13</span>:<span class="number">03.510</span>Z,</span><br><span class="line">  a4: <span class="regexp">/ab+c/i</span>,</span><br><span class="line">  a5: <span class="regexp">/^123$/</span>,</span><br><span class="line">  a6: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line">  a7: [<span class="built_in">Function</span>: a7],</span><br><span class="line">  a8: person &#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  name: <span class="string">&#x27;cxs&#x27;</span>,</span><br><span class="line">  book: &#123; <span class="attr">title</span>: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>, <span class="attr">price</span>: <span class="string">&#x27;45&#x27;</span> &#125;,</span><br><span class="line">  a1: <span class="literal">undefined</span>,</span><br><span class="line">  a2: <span class="literal">null</span>,</span><br><span class="line">  a3: <span class="number">2020</span><span class="number">-10</span><span class="number">-27</span>T11:<span class="number">13</span>:<span class="number">03.510</span>Z,</span><br><span class="line">  a4: <span class="regexp">/ab+c/i</span>,</span><br><span class="line">  a5: <span class="regexp">/^123$/</span>,</span><br><span class="line">  a6: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line">  a7: [<span class="built_in">Function</span>: a7],</span><br><span class="line">  a8: person &#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到null、undefined、日期对象、正则对象、数组对象、普通函数对象、构造函数的实例对象都能被正确拷贝。<br>下面来尝试修改一下里面的数据，看是否达到了深拷贝的效果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a.name = <span class="string">&quot;lxm&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line">a.a6[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: <span class="string">&#x27;lxm&#x27;</span>,</span><br><span class="line">  book: &#123; <span class="attr">title</span>: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>, <span class="attr">price</span>: <span class="string">&#x27;55&#x27;</span> &#125;,</span><br><span class="line">  a1: <span class="literal">undefined</span>,</span><br><span class="line">  a2: <span class="literal">null</span>,</span><br><span class="line">  a3: <span class="number">2020</span><span class="number">-10</span><span class="number">-27</span>T11:<span class="number">20</span>:<span class="number">01.590</span>Z,</span><br><span class="line">  a4: <span class="regexp">/ab+c/i</span>,</span><br><span class="line">  a5: <span class="regexp">/^123$/</span>,</span><br><span class="line">  a6: [ <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line">  a7: [<span class="built_in">Function</span>: a7],</span><br><span class="line">  a8: person &#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  name: <span class="string">&#x27;cxs&#x27;</span>,</span><br><span class="line">  book: &#123; <span class="attr">title</span>: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>, <span class="attr">price</span>: <span class="string">&#x27;45&#x27;</span> &#125;,</span><br><span class="line">  a1: <span class="literal">undefined</span>,</span><br><span class="line">  a2: <span class="literal">null</span>,</span><br><span class="line">  a3: <span class="number">2020</span><span class="number">-10</span><span class="number">-27</span>T11:<span class="number">20</span>:<span class="number">01.590</span>Z,</span><br><span class="line">  a4: <span class="regexp">/ab+c/i</span>,</span><br><span class="line">  a5: <span class="regexp">/^123$/</span>,</span><br><span class="line">  a6: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line">  a7: [<span class="built_in">Function</span>: a7],</span><br><span class="line">  a8: person &#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，修改原始对象，不影响拷贝对象，因此是深拷贝。</p>
<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oldObj = &#123;&#125;;</span><br><span class="line">oldObj.a = oldObj;</span><br><span class="line"><span class="keyword">let</span> newObj = cloneDeep(oldObj);</span><br><span class="line"><span class="built_in">console</span>.log(oldObj);</span><br><span class="line"><span class="built_in">console</span>.log(newObj);</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">a</span>: [Circular] &#125;</span><br><span class="line">&#123; <span class="attr">a</span>: [Circular] &#125;</span><br></pre></td></tr></table></figure>
<p>我们解决循环引用所采用的方法是使用哈希表，其实就是循环检测，设置哈希表存储已拷贝过的对象，当检测到当前对象已存在于哈希表中时，取出该值并返回即可。除了用哈希表，也可以用数组。<br>下面来看看我们的深拷贝函数是否存在引用丢失的情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">a</span>: obj1, <span class="attr">b</span>: obj1&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.a === obj2.b);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> obj3 = cloneDeep(obj2);</span><br><span class="line"><span class="built_in">console</span>.log(obj3.a === obj3.b);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>obj2 的键值 a 和 b 同时引用了同一个对象 obj1，使用 cloneDeep 进行深拷贝后没有出现引用丢失的情况，因为我们使用了哈希表存储了已拷贝过的对象。</p>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>我们实现的深拷贝函数依然是不完善的，比如Symbol、Buffer对象、Promise、Set、Map等也都需要我们做特殊处理，而且由于使用了递归，可能会出现爆栈的问题，破解递归爆栈的方法是使用循环拷贝，详见<a href="https://github.com/yygmind/blog/issues/29">木易杨——实现深拷贝</a>。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>圣杯布局和双飞翼布局</title>
    <url>/2020/10/05/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>圣杯布局和双飞翼布局都是常见的<strong>两边定宽，中间自适应</strong>的三栏布局。这两种布局方式的关键是怎么样才能使得在伸缩浏览器窗口的时候让中间的子元素宽度改变。可以适应浏览器的宽度变化使用百分比设置宽度再合适不过，所以我们要将中间子元素的宽度设置为 100%，左边和右边的子元素设置为固定的宽度。这里我们要注意的是，<strong>中间栏要在放在文档流前面以优先渲染</strong>。</p>
<a id="more"></a>
<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.header</span>,</span></span><br><span class="line"><span class="css">        <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 30px;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">            overflow: hidden;</span><br><span class="line">            height: 100px;</span><br><span class="line">            padding: 0 100px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: green;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">            position: relative;</span><br><span class="line">            float: left;</span><br><span class="line">            left: -100px;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            margin-left: -100%;</span><br><span class="line">            background-color: blue;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">            position: relative;</span><br><span class="line">            float: left;</span><br><span class="line">            right: -100px;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            margin-left: -100px;</span><br><span class="line">            background-color: yellow;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.header</span>,</span></span><br><span class="line"><span class="css">        <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 30px;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">            overflow: hidden;</span><br><span class="line">            height: 100px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.middle-container</span> &#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: green;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line">            margin: 0 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            margin-left: -100%;</span><br><span class="line">            background-color: blue;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            margin-left: -100px;</span><br><span class="line">            background-color: yellow;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle-container&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="圣杯布局和双飞翼布局的异同"><a href="#圣杯布局和双飞翼布局的异同" class="headerlink" title="圣杯布局和双飞翼布局的异同"></a>圣杯布局和双飞翼布局的异同</h2><p>圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部 float 浮动，但左右两栏加上负 margin 让其跟中间栏 div 并排，以形成三栏布局。不同在于解决“中间栏div内容不被遮挡”问题的思路不一样：</p>
<ul>
<li>圣杯布局，为了中间 div 内容不被遮挡，将外层容器设置了左右 padding-left 和 padding-right 后，将左右两个 div 用相对布局position: relative 并分别配合 left 和 right 属性，以便左右两栏 div 移动后不遮挡中间 div 。</li>
<li>双飞翼布局，为了中间 div 内容不被遮挡，直接在中间 div 内部创建子 div 用于放置内容，在该子 div 里用 margin-left 和margin-right 为左右两栏 div 留出位置。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>字典</title>
    <url>/2020/09/21/%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>我们已经知道，集合表示一组互不相同的元素（不重复的元素）。在字典中，存储的是[键, 值]对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值, 值]的形式存储元素，字典则以[键, 值]的形式来存储元素。字典也称作<strong>映射</strong>、<strong>符号表</strong>或<strong>关联数组</strong>。</p>
<a id="more"></a>
<h2 id="Dictionary类的模拟实现"><a href="#Dictionary类的模拟实现" class="headerlink" title="Dictionary类的模拟实现"></a>Dictionary类的模拟实现</h2><p>与Set类类似，ECMAScript 2015同样包含了一个Map类的实现，即我们所说的字典，下面我们以ECMAScript 2015中Map类的实现为基础，模拟实现自己的Dictionary类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultToString</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NULL&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UNDEFINED&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">&quot;string&quot;</span> || item <span class="keyword">instanceof</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;item&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValuePair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(key, value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`[#<span class="subst">$&#123;<span class="built_in">this</span>.key&#125;</span>: <span class="subst">$&#123;<span class="built_in">this</span>.value&#125;</span>&#125;]`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dictionary</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(toStrFn = defaultToString) &#123;</span><br><span class="line">        <span class="built_in">this</span>.toStrFn = toStrFn;</span><br><span class="line">        <span class="built_in">this</span>.table = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测一个键是否存在于字典中</span></span><br><span class="line">    hasKey(key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.table[<span class="built_in">this</span>.toStrFn(key)] != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在字典和ValuePair类中设置键和值</span></span><br><span class="line">    set(key, value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> tableKey = <span class="built_in">this</span>.toStrFn(key);</span><br><span class="line">            <span class="built_in">this</span>.table[tableKey] = <span class="keyword">new</span> ValuePair(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从字典中移除一个值</span></span><br><span class="line">    remove(key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.hasKey(key)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.table[<span class="built_in">this</span>.toStrFn(key)];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从字典中检索一个值</span></span><br><span class="line">    get(key) &#123;</span><br><span class="line">        <span class="keyword">const</span> valuePair = <span class="built_in">this</span>.table[<span class="built_in">this</span>.toStrFn(key)];</span><br><span class="line">        <span class="keyword">return</span> valuePair == <span class="literal">null</span> ? <span class="literal">undefined</span> : valuePair.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将字典中所有[键, 值]对返回</span></span><br><span class="line">    keyValues() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.values(<span class="built_in">this</span>.table);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将字典所包含的所有键名以数组形式返回</span></span><br><span class="line">    keys() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.keyValues().map(<span class="function"><span class="params">valuePair</span> =&gt;</span> valuePair.key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将字典所包含的所有数值以数组形式返回</span></span><br><span class="line">    values() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.keyValues().map(<span class="function"><span class="params">valuePair</span> =&gt;</span> valuePair.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代字典中所有的键值对</span></span><br><span class="line">    forEach(callbackFn) &#123;</span><br><span class="line">        <span class="keyword">const</span> valuePairs = <span class="built_in">this</span>.keyValues();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; valuePairs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> result = callbackFn(valuePairs[i].key, valuePairs[i].value);</span><br><span class="line">            <span class="keyword">if</span> (result === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回字典所包含值的数量</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.table).length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检验字典是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size() === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空字典</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="built_in">this</span>.table = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将字典转换为字符串</span></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> valuePairs = <span class="built_in">this</span>.keyValues();</span><br><span class="line">        <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;valuePairs[<span class="number">0</span>].toString()&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; valuePairs.length; i++) &#123;</span><br><span class="line">            objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>, <span class="subst">$&#123;valuePairs[i].toString()&#125;</span>`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不再演示Dictionary类中方法的使用了，有兴趣的可以自己做个demo测试一下，如果有任何的问题，欢迎评论区留言。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>字节面试题1</title>
    <url>/2020/09/16/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E9%A2%981/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="用css2和css3分别写一下垂直居中和水平居中"><a href="#用css2和css3分别写一下垂直居中和水平居中" class="headerlink" title="用css2和css3分别写一下垂直居中和水平居中"></a>用css2和css3分别写一下垂直居中和水平居中</h2><p>css3新增了一些属性，像flex，这是css3中很重要的改变，所以除了flex以外的垂直水平居中的技巧都是属于css2的。</p>
<ul>
<li>css2的水平居中技巧<br>将元素display为行内元素，再text-align:center;即可<br>或者<br>将块级元素定义一个宽度，再margin: 0 auto;即可</li>
<li>css3的水平居中技巧<br>将元素display设为flex，再通过justify-content: center; 实现居中。</li>
<li>css2的垂直居中技巧<br>单行内容的垂直居中可以通过设置相同height值和line-height值来实现。<br>多行内容的垂直居中且高度可变可以通过设置上下相同的padding值来实现。<br>行级盒子：小图标和标题对齐设置vertical-align: middle。<br>绝对定位：top:50%; left:50%;的方法，需要已知块级的宽高</li>
<li>css3的垂直居中技巧<br>将元素display设为flex，再通过align-items:center;来实现。<a id="more"></a>
<h2 id="计算机网络的七层"><a href="#计算机网络的七层" class="headerlink" title="计算机网络的七层"></a>计算机网络的七层</h2>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层<br><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9128db37af494d42874fed85870f57ac~tplv-k3u1fbpfcp-zoom-1.image" alt="alt"><h2 id="TCP和UDP的区别是什么"><a href="#TCP和UDP的区别是什么" class="headerlink" title="TCP和UDP的区别是什么"></a>TCP和UDP的区别是什么</h2></li>
<li>TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)</li>
<li>UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快</li>
<li>TCP和UDP协议的一些应用例子：TCP一般用于文件传输（FTP HTTP 对数据准确性要求高，速度可以相对慢），发送或接收邮件（POP IMAP SMTP 对数据准确性要求高，非紧急应用），远程登录（TELNET SSH 对数据准确性有一定要求，有连接的概念）等等；UDP一般用于即时通信（QQ聊天 对数据准确性和丢包要求比较低，但速度必须快），在线视频（RTSP 速度一定要快，保证视频连续，但是偶尔花了一个图像帧，人们还是能接受的），网络语音电话（VoIP 语音数据包一般比较小，需要高速发送，偶尔断音或串音也没有问题）等等。<h2 id="TCP和UDP属于计算机网络的哪一层"><a href="#TCP和UDP属于计算机网络的哪一层" class="headerlink" title="TCP和UDP属于计算机网络的哪一层"></a>TCP和UDP属于计算机网络的哪一层</h2></li>
<li>网络层协议：IP协议、ICMP协议、ARP协议、RARP协议</li>
<li>传输层协议：TCP协议、UDP协议</li>
<li>应用层协议：FTP、Telnet、SMTP、HTTP、RIP、NFS、DNS<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2>HTTPS即加密的HTTP，HTTPS并不是一个新协议，而是HTTP+SSL（TLS）。原本HTTP先和TCP（假定传输层是TCP协议）直接通信，而加了SSL后，就变成HTTP先和SSL通信，再由SSL和TCP通信，相当于SSL被嵌在了HTTP和TCP之间。<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2></li>
<li>2XX系列：代表请求已成功被服务器接收、理解、并接受。</li>
<li>200状态码：表示请求已成功，请求所希望的响应头或数据体将随此响应返回</li>
<li>201状态码：表示请求成功并且服务器创建了新的资源，且其 URI 已经随Location 头信息返回。</li>
<li>3XX系列：代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。</li>
<li>301状态码：被请求的资源已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</li>
<li>302状态码：请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求。</li>
<li>304状态码：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</li>
<li>4XX系列：表示请求错误。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。</li>
<li>401状态码：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li>
<li>403状态码：服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。</li>
<li>404状态码：请求失败，请求所希望得到的资源未被在服务器上发现。</li>
<li>5xx系列：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。</li>
<li>500状态码：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。</li>
<li>503状态码：由于临时的服务器维护或者过载，服务器当前无法处理请求。<h2 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h2>闭包就是能够读取其他函数内部变量的函数。闭包的用途：可以读取函数内部的变量，并且让这些变量的值始终保持在内存中。<h2 id="NaN是什么，用typeof会输出什么"><a href="#NaN是什么，用typeof会输出什么" class="headerlink" title="NaN是什么，用typeof会输出什么"></a>NaN是什么，用typeof会输出什么</h2>Not a Number，Number。<h2 id="js的隐性转换和显性转换"><a href="#js的隐性转换和显性转换" class="headerlink" title="js的隐性转换和显性转换"></a>js的隐性转换和显性转换</h2></li>
<li>隐性转换： 1 + ‘1’ = ‘11’， 1 - ‘1’ = 0</li>
<li>显性转换：<br>Number(“24 cccc”);//结果：NaN<br>ParseInt(“24 cccc”);//结果：24<blockquote>
<p>注：Number的显性转换比较严格，若无法强转则直接报错</p>
</blockquote>
</li>
<li>1 + -‘1’ + 1 等于 0 ，’1’前面的负号把其数字化，变为-1，则后值为1</li>
<li>‘A’ - ‘B’ 等于 NaN<h2 id="跨域问题如何解决"><a href="#跨域问题如何解决" class="headerlink" title="跨域问题如何解决"></a>跨域问题如何解决</h2>同源策略：浏览器安全策略，同协议、ip、端口的脚本才会执行。只要协议、域名、端口有任何一个不同，都被当作是不同的域,js跨域是指通过js在不同的域之间进行数据传输或通信。</li>
<li>通过jsonp跨域：jsonp在页面上引入不同域上的js脚本文件实现请求不同域上的数据<br>(1) 通过script标签引入一个js文件<br>(2) js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入<blockquote>
<p>注：需要服务器端的页面进行相应的配合</p>
</blockquote>
</li>
<li>通过修改document.domain来跨子域</li>
<li>使用window.name来进行跨域: window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。<h2 id="babel是什么"><a href="#babel是什么" class="headerlink" title="babel是什么"></a>babel是什么</h2>可以实现将ES6编译为ES5代码。<h2 id="用js实现判断一个变量是否为整数的函数"><a href="#用js实现判断一个变量是否为整数的函数" class="headerlink" title="用js实现判断一个变量是否为整数的函数"></a>用js实现判断一个变量是否为整数的函数</h2>实现思路：先判断该变量是否为Number类型，以此来缩小范围，再判断该变量除以1后是否与原值全等，若全等则返回true，若不全等则返回false。<h2 id="进程和线程是什么"><a href="#进程和线程是什么" class="headerlink" title="进程和线程是什么"></a>进程和线程是什么</h2></li>
<li>线程是最小的执行单元，是操作系统能够进行运算调度的最小单位，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</li>
<li>进程指计算机中已运行的程序。<h2 id="死锁是什么"><a href="#死锁是什么" class="headerlink" title="死锁是什么"></a>死锁是什么</h2>当两个以上的运算单元，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，就称为死锁。<h2 id="Left-Join、Right-Join、Inner-Join-指的是什么"><a href="#Left-Join、Right-Join、Inner-Join-指的是什么" class="headerlink" title="Left Join、Right Join、Inner Join 指的是什么"></a>Left Join、Right Join、Inner Join 指的是什么</h2></li>
<li>Left Join关键字会从左表那里返回所有的行，即使在右表中没有匹配的行</li>
<li>Right Join关键字会右表那里返回所有的行，即使在左表中没有匹配的行</li>
<li>在表中存在至少一个匹配时，Inner Join关键字返回行<h2 id="js快速排序"><a href="#js快速排序" class="headerlink" title="js快速排序"></a>js快速排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">  if(arr.length&lt;&#x3D;1) &#123;</span><br><span class="line">  	return arr;</span><br><span class="line">  &#125;</span><br><span class="line">  var s &#x3D; Math.floor(arr.length&#x2F;2);</span><br><span class="line">  var temp &#x3D; arr.splice(s,1);</span><br><span class="line">  var left&#x3D;[];</span><br><span class="line">  var right&#x3D;[];</span><br><span class="line">  for(var i&#x3D;0;i&lt;arr.length;i++) &#123;</span><br><span class="line">    if(arr[i]&lt;temp) &#123;</span><br><span class="line">      left.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    if(arr[i]&gt;&#x3D;temp) &#123;</span><br><span class="line">      right.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return quickSort(left).concat(temp,quickSort(right));  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>尾调用和尾递归</title>
    <url>/2020/09/20/%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C%E5%B0%BE%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>尾调用是函数式编程中一个很重要的概念，当一个函数执行时的最后一个步骤是返回另一个函数的调用，这就叫做尾调用。函数调用可以是下面方式中的任意一种：</p>
<ul>
<li>函数调用：func(···)</li>
<li>方法调用：obj.method(···)</li>
<li>call调用：func.call(···)</li>
<li>apply调用：func.apply(···)</li>
</ul>
<p>并且只有下列表达式会包含尾调用：</p>
<ul>
<li>条件操作符：? :</li>
<li>逻辑或：||</li>
<li>逻辑与：&amp;&amp;</li>
<li>逗号：,<a id="more"></a>
来看下面的例子：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="params">x</span> =&gt;</span> x ? f() : g();</span><br></pre></td></tr></table></figure>
f() 和 g() 都在尾部。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function">() =&gt;</span> f() || g();</span><br></pre></td></tr></table></figure>
g() 有可能是尾调用，f() 不是，因为上述写法和下面的写法等效：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fResult = f(); <span class="comment">// not a tail call</span></span><br><span class="line">    <span class="keyword">if</span> (fResult) &#123;</span><br><span class="line">        <span class="keyword">return</span> fResult;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> g(); <span class="comment">// tail call</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
只有当 f() 的结果为false的时候，g() 才是尾调用。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function">() =&gt;</span> f() &amp;&amp; g();</span><br></pre></td></tr></table></figure>
g() 有可能是尾调用，f() 不是，因为上述写法和下面的写法等效：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fResult = f(); <span class="comment">// not a tail call</span></span><br><span class="line">    <span class="keyword">if</span> (fResult) &#123;</span><br><span class="line">        <span class="keyword">return</span> g(); <span class="comment">// tail call</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
只有当 f() 的结果为true的时候，g() 才是尾调用。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function">() =&gt;</span> (f() , g());</span><br></pre></td></tr></table></figure>
g() 是尾调用，因为上述写法和下面的写法等效：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> g();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
函数在调用的时候会在调用栈（call stack）中存有记录，每一条记录叫做一个调用帧（call frame），每调用一个函数，就向栈中push一条记录，函数执行结束后依次向外弹出，直到清空调用栈，参考下图：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">111</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123; foo(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span> (<span class="params"></span>) </span>&#123; bar(); &#125;</span><br><span class="line">baz();</span><br></pre></td></tr></table></figure>
<img src="https://s1.ax1x.com/2020/09/20/wTuuh6.png" alt="alt"><br>造成这种结果是因为每个函数在调用另一个函数的时候，并没有 return 该调用，所以JS引擎会认为你还没有执行完，会保留你的调用帧。</li>
</ul>
<p>baz() 里面调用了 bar() 函数，并没有 return 该调用，所以在调用栈中保持自己的调用帧，同时 bar() 函数的调用帧在调用栈中生成，同理，bar() 函数又调用了 foo() 函数，最后执行到 foo() 函数的时候，没有再调用其他函数，这里没有显示声明 return，所以这里默认 return undefined。</p>
<p>foo() 执行完了，销毁调用栈中自己的记录，依次销毁 bar() 和 baz() 的调用帧，最后完成整个流程。</p>
<p>如果对上面的例子做如下修改：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">111</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> foo(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> bar(); &#125;</span><br><span class="line">baz();</span><br></pre></td></tr></table></figure>
<p>这里要注意：<strong>尾调用优化只在严格模式下有效</strong>。</p>
<p>在非严格模式下，大多数引擎会包含下面两个属性，以便开发者检查调用栈：</p>
<ul>
<li>func.arguments: 表示对 func最近一次调用所包含的参数。</li>
<li>func.caller: 引用对 func最近一次调用的那个函数。</li>
</ul>
<p>在尾调用优化中，这些属性不再有用，因为相关的信息可能以及被移除了。因此，严格模式(strict mode)禁止这些属性，并且尾调用优化只在严格模式下有效。</p>
<p>如果尾调用优化生效，流程图就会变成这样：<br><img src="https://s1.ax1x.com/2020/09/20/wTuntx.png" alt="alt"><br>我们可以很清楚的看到，尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，只要直接用内层函数的调用记录取代外层函数的调用记录就可以了，调用栈中始终只保持了一条调用帧。</p>
<p>这就叫做<strong>尾调用优化</strong>，如果所有的函数都是尾调用的话，那么在调用栈中的调用帧始终只有一条，这样会节省很大一部分的内存，这也是尾调用优化的意义。</p>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>讲尾递归之前先来看看什么是递归，当一个函数调用自身，就叫做递归，就像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个操作就叫做递归，但是注意了，这里没有结束条件，是死递归，所以会报栈溢出错误的，写代码时千万注意给递归添加结束条件。</p>
<p>那么什么是尾递归？前面我们知道了尾调用的概念，当一个函数尾调用自身，就叫做尾递归，就像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么尾递归相比递归而言，有哪些不同呢？ 我们通过下面这个求阶乘的例子来看一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> num * factorial(num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>);            <span class="comment">// 120</span></span><br><span class="line">factorial(<span class="number">10</span>);           <span class="comment">// 3628800</span></span><br><span class="line">factorial(<span class="number">500000</span>);       <span class="comment">// Uncaught RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>
<p>上面是使用递归来计算阶乘的例子，操作系统为JS引擎调用栈分配的内存是有大小限制的，如果计算的数字足够大，超出了内存最大范围，就会出现栈溢出错误。这里500000并不是临界值，只是我用了一个足够造成栈溢出的数。</p>
<p>如果用尾递归来计算阶乘呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num, total</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">    <span class="keyword">return</span> factorial(num - <span class="number">1</span>, num * total);</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>);                <span class="comment">// 120</span></span><br><span class="line">factorial(<span class="number">10</span>, <span class="number">1</span>);               <span class="comment">// 3628800</span></span><br><span class="line">factorial(<span class="number">500000</span>, <span class="number">1</span>);           <span class="comment">// 分情况</span></span><br></pre></td></tr></table></figure>
<p>注意，虽然说这里启用了严格模式，但是经测试，在 Chrome 和 Firefox 下，还是会报栈溢出错误，并没有进行尾调用优化，Safari 浏览器进行了尾调用优化，factorial(500000, 1) 结果为 Infinity ，因为结果超出了JS可表示的数字范围，如果在node v6版本下执行，需要加 –harmony_tailcalls 参数（node–harmony_tailcalls test.js），但是node最新版本已经移除了 –harmony_tailcalls 功能。</p>
<p>通过尾递归，我们把复杂度从 O(n) 降低到了 O(1) ，如果数据足够大的话，会节省很多的计算时间。由此可见，尾调用优化对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。</p>
<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。<br>要做到这一点，需要把函数内部所有用到的中间变量改写为函数的参数，就像上面的 factorial() 函数改写一样。这样做的缺点就是语义不明显，要计算阶乘的函数，为什么还要另外传入一个参数叫total？<br>解决这个问题的办法有两个：</p>
<ul>
<li>ES6参数默认值<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">    <span class="keyword">return</span> factorial(num - <span class="number">1</span>, num * total);</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>);                <span class="comment">// 120</span></span><br><span class="line">factorial(<span class="number">10</span>);               <span class="comment">// 3628800</span></span><br></pre></td></tr></table></figure></li>
<li>用一个符合语义的函数去调用改写后的尾递归函数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span> (<span class="params">num, total</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">    <span class="keyword">return</span> tailFactorial(num - <span class="number">1</span>, num * total);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tailFactorial(num, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>);                <span class="comment">// 120</span></span><br><span class="line">factorial(<span class="number">10</span>);               <span class="comment">// 3628800</span></span><br></pre></td></tr></table></figure>
看完了求阶乘的例子，再来看一下经典的爬楼梯问题：</li>
</ul>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶100层呢？</p>
<p>一般递归实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(n - <span class="number">1</span>) + fn(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尾递归优化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n, n1 = <span class="number">1</span>, n2 = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(n - <span class="number">1</span>, n2, n1 + n2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在这里我们主要讨论了尾调用和尾递归。要注意的是，经过测试，Chrome 和 Firefox 并没有对尾调用进行优化，Safari 对尾调用进行了优化，Node 高版本也已经去除了通过 –harmony_tailcalls 参数启用尾调用优化，这些问题在实际使用过程中要注意，如果你有任何的问题，也欢迎评论区留言讨论。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>成长</title>
    <url>/2021/02/07/%E6%88%90%E9%95%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="我的二十二年"><a href="#我的二十二年" class="headerlink" title="我的二十二年"></a>我的二十二年</h2><a id="more"></a>
<p><strong>宋集·宋集卫生院</strong>：1999.10.30（公历）1999.9.22（农历）出生</p>
<p><strong>崔庄·家</strong>：农村，没有什么玩具，啥也没玩过，但很幸福，一直到04年开始上学</p>
<p><strong>宋集·宋集幼儿园</strong>： 在镇上，04年和05年断断续续地上，其实没咋学，都在玩，被幼儿园校车接走时总是会哭，不能离开妈妈，呜呜呜</p>
<p><strong>崔庄·崔敬小学</strong>：2005.9~2011.6，农村小学，周围都是麦田，走路上下学，学习成绩一般，喜欢玩</p>
<p><strong>宋集·宋集中学</strong>：2011.9~2014.6</p>
<ul>
<li>初一，学习成绩前五，住校；</li>
<li>初二，学习成绩第一，住校，物理课代表</li>
<li>初三，学习成绩第二，走读，上学期当物理课代表，下学期当数学课代表</li>
</ul>
<p><strong>西平·西平高中</strong>：2014.9~2017.6，前两个月住校，后面走读</p>
<ul>
<li>高一：按照中考成绩，进入29班（火箭班），倒数，第一次月考，前70/2000，上学期中期根据前五次成绩进行文理分班，选择理科，进入30班（宏志班），倒数第三，此后成绩一直在班级倒数，学校一百多名</li>
<li>高二：开始逆袭，用一年时间从班级倒数到班级前列</li>
<li>高三：上学期某次考试取得三年最好成绩，班级前五，学校前十，也得到了高中时代唯一的一个奖状，此后成绩逐渐稳定，维持在班级中上游，全年担任生物课代表</li>
<li>高考611，河南省前5000/86.58万，最终选择四川大学计算机类</li>
<li>高中三年，身体和心理状态不佳，经常感冒，焦虑，常常请假，感谢妈妈的三年陪伴和班主任的照顾</li>
</ul>
<blockquote>
<p>从小学到高中，没培养什么爱好，对音乐有兴趣，但是没有条件和时间学习</p>
</blockquote>
<p><strong>成都·四川大学</strong>：2017.9~2021.6，目前（写这篇文章时，2021.2.7）大四在读，6月份毕业，大学四年，成绩中等，200/400，学习之余，空闲时间很多，参加很多课外活动，喜欢旅游，去了都江堰、青城山、熊猫基地等，也去了重庆、杭州，懂得了 <strong><em>人生不只有学习，还有远方</em></strong>。后面准备秋招拿到小米offer，做前端。</p>
<p><strong>北京·小米</strong>：目前在小米实习，我的工作生涯也从小米开始，加油啊，前端工程师。<strong>永远相信美好的事情即将发生</strong>。</p>
<p><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/city.png" alt="city"></p>
<blockquote>
<p>注：上面圆圈大小不代表城市规模和大小</p>
</blockquote>
<p>从小到大，视野越来越开阔，也发现自己不知道的事情也越来越多，愿我们<strong>不负韶华，砥砺前行</strong>。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表</title>
    <url>/2020/09/21/%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<strong>散列函数</strong>，存放记录的数组叫做散列表。</p>
<a id="more"></a>
<h2 id="HashTable类的模拟实现"><a href="#HashTable类的模拟实现" class="headerlink" title="HashTable类的模拟实现"></a>HashTable类的模拟实现</h2><p>下面我们来模拟实现自己的HashTable类，也叫HashMap类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultToString</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NULL&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UNDEFINED&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">&quot;string&quot;</span> || item <span class="keyword">instanceof</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;item&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValuePair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(key, value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`[#<span class="subst">$&#123;<span class="built_in">this</span>.key&#125;</span>: <span class="subst">$&#123;<span class="built_in">this</span>.value&#125;</span>&#125;]`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(toStrFn = defaultToString) &#123;</span><br><span class="line">        <span class="built_in">this</span>.toStrFn = toStrFn;</span><br><span class="line">        <span class="built_in">this</span>.table = &#123;&#125;;</span><br><span class="line">    &#125;            </span><br><span class="line">    <span class="comment">// 散列函数</span></span><br><span class="line">    loseloseHashCode(key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> tableKey = <span class="built_in">this</span>.toStrFn(key);</span><br><span class="line">        <span class="keyword">let</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tableKey.length; i++) &#123;</span><br><span class="line">            hash += tableKey.charCodeAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash % <span class="number">37</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取某一个键的hash值</span></span><br><span class="line">    HashCode(key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.loseloseHashCode(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将键和值加入散列表</span></span><br><span class="line">    put(key, value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> position = <span class="built_in">this</span>.HashCode(key);</span><br><span class="line">            <span class="built_in">this</span>.table[position] = <span class="keyword">new</span> ValuePair(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从散列表中获取一个值</span></span><br><span class="line">    get(key) &#123;</span><br><span class="line">        <span class="keyword">const</span> valuePair = <span class="built_in">this</span>.table[<span class="built_in">this</span>.HashCode(key)];</span><br><span class="line">        <span class="keyword">return</span> valuePair == <span class="literal">null</span> ? <span class="literal">undefined</span> : valuePair.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从散列表移除一个值</span></span><br><span class="line">    remove(key) &#123;</span><br><span class="line">        <span class="keyword">const</span> hash = <span class="built_in">this</span>.HashCode(key);</span><br><span class="line">        <span class="keyword">const</span> valuePair = <span class="built_in">this</span>.table[hash];</span><br><span class="line">        <span class="keyword">if</span> (valuePair != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.table[hash];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不再演示HashTable类中方法的使用了，有兴趣的可以自己做个demo测试一下，如果有任何的问题，欢迎评论区留言。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕代码之call、apply和bind</title>
    <url>/2020/09/17/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E4%B9%8Bcall%E3%80%81apply%E5%92%8Cbind/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="三兄弟的作用"><a href="#三兄弟的作用" class="headerlink" title="三兄弟的作用"></a>三兄弟的作用</h2><p>call、apply和bind三个方法都是为了改变函数运行时上下文(即this指向)而存在的，来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> language = &#123;</span><br><span class="line">    name: <span class="string">&quot;java&quot;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is the best language in the world!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> weber = &#123;</span><br><span class="line">    name: <span class="string">&quot;javascript&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//谁是世界上最好的语言？</span></span><br><span class="line">language.getName();</span><br><span class="line">language.getName.call(weber);</span><br><span class="line">language.getName.apply(weber);</span><br><span class="line">language.getName.bind(weber)();</span><br></pre></td></tr></table></figure>
<p>执行上面的代码，结果为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">java is the best language <span class="keyword">in</span> the world!</span><br><span class="line">javascript is the best language <span class="keyword">in</span> the world!</span><br><span class="line">javascript is the best language <span class="keyword">in</span> the world!</span><br><span class="line">javascript is the best language <span class="keyword">in</span> the world!</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="三兄弟的区别"><a href="#三兄弟的区别" class="headerlink" title="三兄弟的区别"></a>三兄弟的区别</h2><ul>
<li>call、apply和bind方法接收的第一个参数都是要绑定的this对象。</li>
<li>apply方法的第二个参数是一个参数数组，call和bind方法的第二个及之后的参数作为函数实参按顺序传入。</li>
<li>bind方法不会立即调用，call和apply方法都会立即调用。</li>
</ul>
<p>来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> developer = &#123;</span><br><span class="line">    getSkills: <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> weber = &#123;</span><br><span class="line">    skiller: [<span class="string">&quot;HTML&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line">developer.getSkills.call(weber, <span class="string">&quot;HTML5&quot;</span>, <span class="string">&quot;CSS3&quot;</span>, <span class="string">&quot;javascript&quot;</span>);</span><br><span class="line">developer.getSkills.apply(weber, [<span class="string">&quot;HTML5&quot;</span>, <span class="string">&quot;CSS3&quot;</span>, <span class="string">&quot;javascript&quot;</span>]);</span><br><span class="line">developer.getSkills.bind(weber)(<span class="string">&quot;HTML5&quot;</span>, <span class="string">&quot;CSS3&quot;</span>, <span class="string">&quot;javascript&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>执行上面的代码，结果为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTML5 CSS3 javascript</span><br><span class="line">HTML5 CSS3 javascript</span><br><span class="line">HTML5 CSS3 javascript</span><br></pre></td></tr></table></figure>
<h2 id="call方法的模拟实现"><a href="#call方法的模拟实现" class="headerlink" title="call方法的模拟实现"></a>call方法的模拟实现</h2><p>首先要理清思路：</p>
<ul>
<li>函数定义在哪里？call方法是可以被所有方法调用的，所以毫无疑问要定义在Function的原型上。</li>
<li>函数接收参数？绑定函数被调用时只传入第二个参数及之后的参数。</li>
<li>如何显式绑定this？如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。</li>
</ul>
<p>理清了思路，开撸：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123; <span class="comment">//验证当前被调用的是否是方法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;not function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> cxt = context || <span class="built_in">window</span>;</span><br><span class="line">    cxt.fn = <span class="built_in">this</span>; <span class="comment">// 将当前被调用的方法定义在cxt.fn上，为了能以对象调用的形式绑定this</span></span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>); <span class="comment">//获取实参</span></span><br><span class="line">    <span class="keyword">const</span> res = cxt.fn(...args); <span class="comment">//以对象调用的形式调用fn，此时this指向cxt，也就是传入的需要绑定的this指向</span></span><br><span class="line">    <span class="keyword">delete</span> cxt.fn; <span class="comment">//删除该方法，不然会对传入对象造成污染（添加该方法）</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="apply方法的模拟实现"><a href="#apply方法的模拟实现" class="headerlink" title="apply方法的模拟实现"></a>apply方法的模拟实现</h2><p>apply方法实现的思路与call方法基本相同，我们只需要对参数进行不同处理即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123; <span class="comment">//验证当前被调用的是否是方法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;not function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> cxt = context || <span class="built_in">window</span>;</span><br><span class="line">    cxt.fn = <span class="built_in">this</span>; <span class="comment">// 将当前被调用的方法定义在cxt.fn上，为了能以对象调用的形式绑定this</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">arguments</span>[<span class="number">1</span>] ? cxt.fn(...arguments[<span class="number">1</span>]) : cxt.fn(); <span class="comment">//以对象调用的形式调用fn，此时this指向cxt，也就是传入的需要绑定的this指向</span></span><br><span class="line">    <span class="keyword">delete</span> cxt.fn; <span class="comment">//删除该方法，不然会对传入对象造成污染（添加该方法）</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="bind方法的模拟实现"><a href="#bind方法的模拟实现" class="headerlink" title="bind方法的模拟实现"></a>bind方法的模拟实现</h2><p>首先要理清思路：</p>
<ul>
<li>函数定义在哪里？bind方法是可以被所有方法调用的，所以毫无疑问要定义在Function的原型上。</li>
<li>函数接收参数？bind方法返回一个绑定函数，最终调用需要传入函数实参和绑定函数的实参。</li>
<li>如何显式绑定this？如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。</li>
</ul>
<p>我模拟实现的bind方法代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123; <span class="comment">//验证当前被调用的是否是方法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="built_in">this</span> + <span class="string">&quot;isn&#x27;t a function!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//处理函数使用new的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span> <span class="keyword">instanceof</span> fn ? <span class="keyword">new</span> _this(...args, ...arguments) : _this.myApply(context, args.concat(...arguments));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更多bind方法的实现详见：<br><a href="https://segmentfault.com/a/1190000017091983">面试官问：能否模拟实现JS的bind方法？</a><br><a href="https://www.jianshu.com/p/9d75886102a7">bind方法的实现</a></p>
<p>经测试，模拟实现的myCall、myApply和myBind方法和call、apply和bind方法效果一致。到这里，我们已经模拟实现了自己的三兄弟方法，如果你有任何的问题，欢迎评论区留言，你的支持是我前进的最大动力。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2020/09/28/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = len; j &gt;= <span class="number">2</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; j - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                [arr[i], arr[i + <span class="number">1</span>]] = [arr[i + <span class="number">1</span>], arr[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="alt"></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="alt"></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                [arr[j], arr[j - <span class="number">1</span>]] = [arr[j - <span class="number">1</span>], arr[j]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="alt"></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> temp = arr.splice(s, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> left = [];</span><br><span class="line">    <span class="keyword">let</span> right = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; temp) &#123;</span><br><span class="line">            left.push(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat(temp, quickSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="alt"><br>另一种快速排序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Partition</span>(<span class="params">arr, p, r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = p, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> x = arr[p];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[++i] &lt; x &amp;&amp; i &lt; r) ;</span><br><span class="line">        <span class="keyword">while</span> (arr[--j] &gt; x) ;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[p] = arr[j];</span><br><span class="line">    arr[j] = x;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">QuickSort</span>(<span class="params">arr, p, r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; r) &#123;</span><br><span class="line">        <span class="keyword">let</span> q = Partition(arr, p, r);</span><br><span class="line">        QuickSort(arr, p, q - <span class="number">1</span>);</span><br><span class="line">        QuickSort(arr, q + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(QuickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>新的征程</title>
    <url>/2020/09/20/%E6%96%B0%E7%9A%84%E5%BE%81%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="大四"><a href="#大四" class="headerlink" title="大四"></a>大四</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转眼间已经大四了，我的川大时间余额已不足一年，只觉三年的时光转瞬即逝，想抓住时间却已经悄悄溜走，仅剩的一年川大时光我一定会倍加珍惜。刚结束的大三，我觉得是我三年来最努力的一年，这一年，我积极备考英语六级，第一次把六级词汇书基本通背一遍，虽然最后成绩不是很理想，但终归好于裸考的四级，同样，在这一年，我大幅度压缩游戏时间，英雄联盟陪伴我好几年的游戏也最终放弃，上课时间也不断提醒自己少耍手机，这一年的奋斗也终于出了点效果，大三一年的成绩排名比大二进步多了，我也顺利申请了奖学金，虽然深知最多只有300元，但也觉得这来之不易的300元是对我积极努力的最好回报。如今，大四已经开学半月有余，我的生活学习节奏还算可以，紧追大三的步伐，努力学习知识不断充实自己。</p>
<a id="more"></a>
<h2 id="从放弃考研到学习前端"><a href="#从放弃考研到学习前端" class="headerlink" title="从放弃考研到学习前端"></a>从放弃考研到学习前端</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我最终下定决心放弃考研是在4月底，这时候，大三下的课程基本学完了，即使因为疫情没有返校，在家的这几个月也没有丝毫松懈，编译原理我大学生涯的最后一块难啃的专业必修课，也最终被拿下，虽然最后的成绩不尽人意，但我也无怨无悔，因为我知道，平时我真的是好好学了的。其实在大二暑假我才第一次接触前端，是在腾讯课堂上学习一门HTML和CSS入门课，那时候觉得做页面很炫酷，可以做出各种好看的效果，于是就深深爱上了前端，5月初，学校还是没有通知返校，我的内心开始逐渐焦虑，本想返校后开始好好学习前端，但学校迟迟不下通知，机不可失失不再来，我决定开始在家学习前端。5月，我重温了袁老师的HTML和CSS基础入门课，因为之前学过的缘故，所以看的很快，5月中旬，我开始学习javascript，跟着《javascript入门经典》把js基础知识过了一遍，这时候，我在微信上结识了陶务华，已经工作了的他给我发了很多教程，感谢他的帮助，我得以迅速入门前端，也认识到前端不只是学习HTML、CSS和javascript这么简单，还有很多的技术工具需要去学习。跟着陶大哥的视频教程，我逐渐学到了HTML5、CSS3、jQuery等稍微进阶的知识，我的前端水平也进一步提高，后来我又接触到了服务器端开发Node.js、Express和art-template模板，也开始学习前后端交互，学习Ajax和jQuery下的Ajax，然后接触到了MongoDB数据库，后来开始学习Vue框架以及webpack打包和Gulp构建，自己的前端水平继续提高，到现在，我基本上前端知识都接触到了，但是大都研究不深入，只是懂了点皮毛，后面我准备分专题开始逐渐深入了解前端世界。</p>
<h2 id="简历和面试"><a href="#简历和面试" class="headerlink" title="简历和面试"></a>简历和面试</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前几天，我刚刚投出了人生的第一份简历，现在还再初筛中，面试对我来说是陌生的，尤其是技术面试，不过慢慢来嘛，再难也要一步一个脚印往前走，难道不是吗？</p>
<h2 id="关于前端"><a href="#关于前端" class="headerlink" title="关于前端"></a>关于前端</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能很多人对前端很陌生，甚至不知道还有前端工程师这个职业，下面我就来简单介绍一下。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://baike.baidu.com/item/%E5%89%8D%E7%AB%AF/5956545">前端</a>即网站前台部分，运行在PC端，移动端等浏览器上展现给用户浏览的网页。随着互联网技术的发展，HTML5，CSS3，前端框架的应用，跨平台响应式网页设计能够适应各种屏幕分辨率，合适的动效设计，给用户带来极高的用户体验，当然现在的前端也不仅仅限于PC电脑端，移动端如APP和微信小程序它们的前台页面也叫前端。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://baike.baidu.com/item/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91">前端开发</a>是创建Web页面（也就是咱们常说的网页）或app（也就是咱们手机上的软件，如QQ、微信等）等前端界面呈现给用户的过程，通过HTML，CSS及JavaScript（这些都是开发网页所需的技术）以及衍生出来的各种技术、框架、解决方案，来实现互联网产品的用户界面交互。它从网页制作演变而来，名称上有很明显的时代特征。在互联网的演化进程中，网页制作是Web1.0时代的产物，早期网站主要内容都是静态，以图片和文字为主，用户使用网站的行为也以浏览为主。随着互联网技术的发展和HTML5、CSS3的应用，现代网页更加美观，交互效果显著，功能更加强大。移动互联网带来了大量高性能的移动终端设备以及快速的无线网络，HTML5、node.jS的广泛应用，各类框架类库层出不穷。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://baike.baidu.com/item/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88">前端工程师</a>，顾名思义，是使用前端技术进行页面开发的一类职业，它是互联网时代软件产品研发中不可缺少的一种专业研发角色。从狭义上讲，前端工程师使用 HTML、CSS、JavaScript 等专业技能和工具将产品UI设计稿实现成网站产品，涵盖用户PC端、移动端网页，处理视觉和交互问题。从广义上来讲，所有用户终端产品与视觉和交互有关的部分，都是前端工程师的专业领域。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;像我们熟知的一些公司，如阿里巴巴、腾讯、百度、美团、抖音（字节跳动旗下）等，他们都叫做互联网公司或者叫软件公司，这类公司是急需前端人才的，毕竟产品的好坏只有通过页面展示出来才能知晓。</p>
<h2 id="新的征程"><a href="#新的征程" class="headerlink" title="新的征程"></a>新的征程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新的征程已经开始，唯有不断奋斗，追逐梦想才是人存在的意义，加油吧，少年，美好的未来在等着我们！</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2020/09/21/%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种遵从<strong>后进先出</strong>（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。</p>
<a id="more"></a>
<h2 id="创建一个基于数组的Stack类"><a href="#创建一个基于数组的Stack类" class="headerlink" title="创建一个基于数组的Stack类"></a>创建一个基于数组的Stack类</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向栈添加元素</span></span><br><span class="line">    push(element) &#123;</span><br><span class="line">        <span class="built_in">this</span>.items.push(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从栈移除元素</span></span><br><span class="line">    pop() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    peek() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.items.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取栈的大小</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空栈元素</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建一个基于JavaScript对象的Stack类"><a href="#创建一个基于JavaScript对象的Stack类" class="headerlink" title="创建一个基于JavaScript对象的Stack类"></a>创建一个基于JavaScript对象的Stack类</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向栈中插入元素</span></span><br><span class="line">    push(element) &#123;</span><br><span class="line">        <span class="built_in">this</span>.items[<span class="built_in">this</span>.count] = element;</span><br><span class="line">        <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取栈的大小</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从栈中弹出元素</span></span><br><span class="line">    pop() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.count--;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">this</span>.items[<span class="built_in">this</span>.count];</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.count];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    peek() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.count - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空栈元素</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建toString方法</span></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.items[<span class="number">0</span>]&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">this</span>.count; i++) &#123;</span><br><span class="line">            objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>, <span class="subst">$&#123;<span class="built_in">this</span>.items[i]&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不再演示Stack类中方法的使用了，有兴趣的可以自己做个demo测试一下，如果有任何的问题，欢迎评论区留言。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数组扁平化</title>
    <url>/2020/09/28/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="使用递归实现数组扁平化"><a href="#使用递归实现数组扁平化" class="headerlink" title="使用递归实现数组扁平化"></a>使用递归实现数组扁平化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.flat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="built_in">this</span>.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">            arr = arr.concat(item.flat());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]]];</span><br><span class="line"><span class="built_in">console</span>.log(arr.flat()); <span class="comment">//[2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="递归扩展：爬楼梯"><a href="#递归扩展：爬楼梯" class="headerlink" title="递归扩展：爬楼梯"></a>递归扩展：爬楼梯</h2><p>有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">climbStairs</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(climbStairs(<span class="number">5</span>)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h2 id="递归扩展：二分查找"><a href="#递归扩展：二分查找" class="headerlink" title="递归扩展：二分查找"></a>递归扩展：二分查找</h2><p>二分查找，是在一个有序的序列里查找某一个值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">arr, target, low = <span class="number">0</span>, high = arr.length - <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> <span class="string">`没有找到<span class="subst">$&#123;target&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> current = arr[n];</span><br><span class="line">    <span class="keyword">if</span> (current === target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`找到了<span class="subst">$&#123;target&#125;</span>, 在第<span class="subst">$&#123;n+<span class="number">1</span>&#125;</span>个`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(arr, target, n + <span class="number">1</span>, high);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(arr, target, low, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return `没有找到$&#123;target&#125;`;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">35</span>, <span class="number">55</span>];</span><br><span class="line"><span class="built_in">console</span>.log(binarySearch(arr, <span class="number">9</span>)); <span class="comment">// 找到了9, 在第5个</span></span><br><span class="line"><span class="built_in">console</span>.log(binarySearch(arr, <span class="number">7</span>)); <span class="comment">// 没有找到7</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎</title>
    <url>/2020/09/16/%E6%AC%A2%E8%BF%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="欢迎大家来到我的个人网站"><a href="#欢迎大家来到我的个人网站" class="headerlink" title="欢迎大家来到我的个人网站"></a>欢迎大家来到我的个人网站</h1><p>希望和大家一起交流前端，有什么问题可以随时联系我，不管是技术还是生活，希望大家每天都能开开心心的学习，开开心心的生活！</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>本地存储</title>
    <url>/2020/09/29/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右，是网景公司的前雇员 Lou Montulli 在1993年3月的发明。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。</p>
<a id="more"></a>
<h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>localStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。</p>
<h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><p>sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。</p>
<h2 id="三者的异同"><a href="#三者的异同" class="headerlink" title="三者的异同"></a>三者的异同</h2><table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">Cookie</th>
<th align="center">localStorage</th>
<th align="center">sessionStorage</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据的生命期</td>
<td align="center">一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td>
<td align="center">除非被清除，否则永久保存</td>
<td align="center">仅在当前会话下有效，关闭页面或浏览器后被清除</td>
</tr>
<tr>
<td align="center">存放数据大小</td>
<td align="center">4K左右</td>
<td align="center">一般为5MB</td>
<td align="center">一般为5MB</td>
</tr>
<tr>
<td align="center">与服务器端通信</td>
<td align="center">每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>
<td align="center">仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>
<td align="center">仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>
</tr>
<tr>
<td align="center">易用性</td>
<td align="center">需要程序员自己封装，源生的Cookie接口不友好</td>
<td align="center">源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>
<td align="center">源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>
</tr>
</tbody></table>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>因为每个 HTTP 请求都会带着 Cookie 的信息，所以 Cookie 当然是能精简就精简，比较常用的一个应用场景就是判断用户是否登录。针对登录过的用户，服务器端会在他登录时往 Cookie 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录。曾经还使用 Cookie 来保存用户在电商网站的购物车信息，如今有了 localStorage，似乎在这个方面也可以给 Cookie 放个假。而另一方面 localStorage 接替了 Cookie 管理购物车的工作，同时也能胜任其他一些工作。比如HTML5游戏通常会产生一些本地数据，localStorage 也是非常适用的。如果遇到一些内容特别多的表单，为了优化用户体验，我们可能要把表单页面拆分成多个子页面，然后按步骤引导用户填写，这时候 sessionStorage 的作用就发挥出来了。</p>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有 XSS 的风险，它们就能对你的 localStorage 肆意妄为，所以千万不要用它们存储你系统中的敏感数据。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>赋值、浅拷贝和深拷贝</title>
    <url>/2020/09/19/%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>赋值是将某一数值或对象赋给某个变量的过程，分为两类:</p>
<ul>
<li>基本数据类型：赋值，赋值之后两个变量互不影响。</li>
<li>引用数据类型：赋址，两个变量具有相同的引用，指向同一个对象，相互之间有影响。<a id="more"></a>
来看下面两个例子：<br>先看基本数据类型<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;java&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">//java</span></span><br><span class="line">a = <span class="string">&quot;javascript&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// java</span></span><br></pre></td></tr></table></figure>
上面代码的输出为：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line">javascript</span><br><span class="line">java</span><br></pre></td></tr></table></figure>
如果是引用数据类型呢？<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;javascript&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;I love javascript&quot;</span>,</span><br><span class="line">        price: <span class="number">45</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>
上面代码的输出为：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: <span class="string">&quot;javascript&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;I love javascript&quot;</span>,</span><br><span class="line">        price: <span class="number">45</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果这时候改变a的值，像下面这样：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a.name = <span class="string">&quot;java&quot;</span>;</span><br><span class="line">a.book.title = <span class="string">&quot;I love java&quot;</span>;</span><br><span class="line">a.book.price = <span class="number">55</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>
输出的结果为：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: <span class="string">&quot;java&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;I love java&quot;</span>,</span><br><span class="line">        price: <span class="number">55</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    name: <span class="string">&quot;java&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;I love java&quot;</span>,</span><br><span class="line">        price: <span class="number">55</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到a和b的值都改变了，但是通常在开发中我们并不希望改变变量 a 之后会影响到变量 b，这时就需要用到浅拷贝和深拷贝。</li>
</ul>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。<br><img src="https://s1.ax1x.com/2020/09/19/w50M2d.png" alt="alt"></p>
<p>上图中，SourceObj 是原对象，其中包含基本类型属性 field1 和引用类型属性 refObj。浅拷贝之后基本类型数据  field2 和 filed1 是不同属性，互不影响。但引用类型 refObj 仍然是同一个，改变之后会对另一个对象产生影响。</p>
<p>那么浅拷贝有哪些应用场景呢？</p>
<ul>
<li><p>Object.assign()<br>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，它将返回目标对象，来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;java&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;I love java&quot;</span>,</span><br><span class="line">        price: <span class="number">45</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;java&quot;,</span></span><br><span class="line"><span class="comment">//     book: &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love java&quot;,</span></span><br><span class="line"><span class="comment">//         price: 45</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">a.name = <span class="string">&quot;javascript&quot;</span>;</span><br><span class="line">a.book.title = <span class="string">&quot;I love javascript&quot;</span>;</span><br><span class="line">a.book.price = <span class="number">55</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;javascript&quot;,</span></span><br><span class="line"><span class="comment">//     book: &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love javascript&quot;,</span></span><br><span class="line"><span class="comment">//         price: 55</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;java&quot;,</span></span><br><span class="line"><span class="comment">//     book: &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love javascript&quot;,</span></span><br><span class="line"><span class="comment">//         price: 55</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码改变对象 a 之后，对象 b 的基本属性保持不变。但是当改变对象 a 中的对象 book 时，对象 b 也跟着发生了变化，因为它们指向的是同一块内存地址。</p>
</li>
<li><p>展开语法Spread</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;java&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;I love java&quot;</span>,</span><br><span class="line">        price: <span class="number">45</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;java&quot;,</span></span><br><span class="line"><span class="comment">//     book: &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love java&quot;,</span></span><br><span class="line"><span class="comment">//         price: 45</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">a.name = <span class="string">&quot;javascript&quot;</span>;</span><br><span class="line">a.book.title = <span class="string">&quot;I love javascript&quot;</span>;</span><br><span class="line">a.book.price = <span class="number">55</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;javascript&quot;,</span></span><br><span class="line"><span class="comment">//     book: &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love javascript&quot;,</span></span><br><span class="line"><span class="comment">//         price: 55</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;java&quot;,</span></span><br><span class="line"><span class="comment">//     book: &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love javascript&quot;,</span></span><br><span class="line"><span class="comment">//         price: 55</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>通过代码可以看出实际效果和 Object.assign() 是一样的。</p>
</li>
<li><p>Array.prototype.slice()<br>slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝，原始数组不会被改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>, <span class="string">&quot;1&quot;</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = a.slice(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// [&quot;1&quot;, [2, 3]]</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;99&quot;</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// [0, &quot;99&quot;, [4, 3]]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">//  [&quot;1&quot;, [4, 3]]</span></span><br></pre></td></tr></table></figure>
<p>通过，改变 a[1] 之后 b[0] 的值并没有发生变化，但改变 a[2][0] 之后，相应的 b[1][0] 的值也发生变化。说明 slice() 方法是浅拷贝，相应的还有concat等，在实际工作中使用数组对象等引用数据类型时要特别注意。</p>
</li>
<li><p>jQuery.extend()</p>
</li>
</ul>
<p>使用jQuery语法前记得先引入jQuery，来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;java&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;I love java&quot;</span>,</span><br><span class="line">        price: <span class="number">45</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;&#125;;</span><br><span class="line">$.extend(b, a); <span class="comment">//jQuery.extend(b, a);</span></span><br><span class="line"><span class="built_in">console</span>.log(a); </span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;java&quot;,</span></span><br><span class="line"><span class="comment">//     book : &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love java&quot;,</span></span><br><span class="line"><span class="comment">//         price: 45</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;java&quot;,</span></span><br><span class="line"><span class="comment">//     book : &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love java&quot;,</span></span><br><span class="line"><span class="comment">//         price: 45</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">a.name = <span class="string">&quot;javascript&quot;</span>;</span><br><span class="line">a.book.title = <span class="string">&quot;I love javascript&quot;</span>;</span><br><span class="line">a.book.price = <span class="number">55</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;javascript&quot;,</span></span><br><span class="line"><span class="comment">//     book : &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love javascript&quot;,</span></span><br><span class="line"><span class="comment">//         price: 55</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;java&quot;,</span></span><br><span class="line"><span class="comment">//     book : &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love javascript&quot;,</span></span><br><span class="line"><span class="comment">//         price: 55</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。</p>
<p><img src="https://s1.ax1x.com/2020/09/19/w5jYPf.png" alt="alt"></p>
<p>那么深拷贝有什么使用场景呢？</p>
<ul>
<li>JSON.parse(JSON.stringify(object))<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;java&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;I love java&quot;</span>,</span><br><span class="line">        price: <span class="number">45</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;java&quot;,</span></span><br><span class="line"><span class="comment">//     book: &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love java&quot;,</span></span><br><span class="line"><span class="comment">//         price: 45</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">a.name = <span class="string">&quot;javascript&quot;</span>;</span><br><span class="line">a.book.title = <span class="string">&quot;I love javascript&quot;</span>;</span><br><span class="line">a.book.price = <span class="number">55</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;javascript&quot;,</span></span><br><span class="line"><span class="comment">//     book: &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love javascript&quot;,</span></span><br><span class="line"><span class="comment">//         price: 55</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;java&quot;,</span></span><br><span class="line"><span class="comment">//     book: &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love java&quot;,</span></span><br><span class="line"><span class="comment">//         price: 45</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
完全改变变量 a 之后对 b 没有任何影响，这就是深拷贝的魔力。那么对数组深拷贝效果如何？来看下面的例子：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>, <span class="string">&quot;1&quot;</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify( a.slice(<span class="number">1</span>) ));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// [&quot;1&quot;, [2, 3]]</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;99&quot;</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// [0, &quot;99&quot;, [4, 3]]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">//  [&quot;1&quot;, [2, 3]]</span></span><br></pre></td></tr></table></figure>
可以发现，对数组深拷贝之后，改变原数组不会影响到拷贝之后的数组。但是这种方法有如下的几个问题：</li>
<li>会忽略 undefined</li>
<li>会忽略 symbol</li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
<li>不能正确处理new Date()</li>
<li>不能处理正则</li>
</ul>
<p>undefined、symbol 和函数这三种情况，会直接忽略：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&quot;javascript&quot;</span>,</span><br><span class="line">    a: <span class="literal">undefined</span>,</span><br><span class="line">    b: <span class="built_in">Symbol</span>(<span class="string">&quot;javascript&quot;</span>),</span><br><span class="line">    c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	name: &quot;javascript&quot;, </span></span><br><span class="line"><span class="comment">// 	a: undefined, </span></span><br><span class="line"><span class="comment">//      b: Symbol(javascript), </span></span><br><span class="line"><span class="comment">//      c: ƒ ()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(newObj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;javascript&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>循环引用情况下，会报错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        c: <span class="number">2</span>,</span><br><span class="line">   		d: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a = obj.b;</span><br><span class="line">obj.b.c = obj.a;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="comment">// Uncaught TypeError: Converting circular structure to JSON</span></span><br></pre></td></tr></table></figure>
<p>new Date() 情况下，转换结果不正确:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// Sat Sep 19 2020 15:29:37 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line"><span class="comment">// &quot;&quot;2020-09-19T07:29:50.597Z&quot;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(<span class="keyword">new</span> <span class="built_in">Date</span>()));</span><br><span class="line"><span class="comment">// &quot;2020-09-19T07:30:14.480Z&quot;</span></span><br></pre></td></tr></table></figure>
<p>将 new Date() 的结果转换为字符串或时间戳就ok了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> date = (<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf();</span><br><span class="line"><span class="built_in">console</span>.log(date);</span><br><span class="line"><span class="comment">// 1600500782999</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(date);</span><br><span class="line"><span class="comment">// &quot;1600500782999&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(date));</span><br><span class="line"><span class="comment">// 1600500782999</span></span><br></pre></td></tr></table></figure>
<p>正则情况下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&quot;javascript&quot;</span>,</span><br><span class="line">    a: <span class="regexp">/&#x27;456&#x27;/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;javascript&quot;, </span></span><br><span class="line"><span class="comment">//     a: /&#x27;456&#x27;/</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;javascript&quot;, </span></span><br><span class="line"><span class="comment">//     a: &#123;&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">和原数据是否指向同一对象</th>
<th align="center">第一层数据为基本数据类型</th>
<th align="center">原数据中包含子对象</th>
</tr>
</thead>
<tbody><tr>
<td align="center">赋值</td>
<td align="center">是</td>
<td align="center">改变会使原数据一同改变</td>
<td align="center">改变会使原数据一同改变</td>
</tr>
<tr>
<td align="center">浅拷贝</td>
<td align="center">否</td>
<td align="center">改变不会使原数据一同改变</td>
<td align="center">改变会使原数据一同改变</td>
</tr>
<tr>
<td align="center">深拷贝</td>
<td align="center">否</td>
<td align="center">改变不会使原数据一同改变</td>
<td align="center">改变不会使原数据一同改变</td>
</tr>
</tbody></table>
<p>到这里，赋值、浅拷贝和深拷贝我们已经梳理完毕了，如果你有任何的问题，欢迎评论区留言，你的支持是我前进最大的动力。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/2020/09/30/%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指“协议，域名，端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/tongyuan.png" alt="alt"></p>
<p>同源策略的限制内容有：</p>
<ul>
<li>Cookie、LocalStorage、IndexedDB 等存储性内容</li>
<li>DOM 节点</li>
<li>AJAX 请求发送后，结果被浏览器拦截了</li>
</ul>
<p>跨域就是由浏览器同源策略引起的，是指页面请求的接口地址，必须与页面url地址同源。这是为了防止某域名下的接口被其他域名下的网页非法调用，是浏览器对JavaScript施加的安全限制。当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/tongyuan2.png" alt="alt"></p>
<p>需要注意三点：</p>
<ul>
<li>如果是协议和端口造成的跨域问题“前台”是无能为力的。</li>
<li>在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配。</li>
<li>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会？因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</li>
</ul>
<p>下面来说说有哪些跨域解决方案。</p>
<h2 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h2><p>利用script标签（类似的标签还有 iframe、img ，他们都含有 src属性，link 标签借助 href 也可跨域）可跨域的特点，在跨域脚本中可以直接回调当前脚本的函数。</p>
<p>jsonp 和 Ajax 相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但 Ajax 属于同源策略，jsonp 属于非同源策略（跨域请求）。</p>
<p>jsonp 优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持 get 方法具有局限性，不安全可能会遭受 XSS 攻击，而且严重依赖后端的协助。</p>
<p>jsonp实现原理：</p>
<ul>
<li>声明一个回调函数，其函数名(如 show )当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的 data )。</li>
<li>创建一个 script 标签，把那个跨域的 API 数据接口地址，赋值给script 的 src ,还要在这个地址中向服务器传递该函数名（可以通过问号传参：?callback=show）。</li>
<li>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串，例如：传递进去的函数名是show ，它准备好的数据是 show(‘I love you’)。</li>
<li>最后服务器把准备的数据通过 HTTP 协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</li>
</ul>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>服务器设置HTTP响应头中Access-Control-Allow-Origin值，解除跨域限制，该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。通过CORS解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。</p>
<ul>
<li>只要同时满足以下两大条件，就属于简单请求：<br>条件1：使用下列方法之一：GET HEAD POST<br>条件2：Content-Type 的值仅限于下列三者之一：<br>text/plain<br>multipart/form-data<br>application/x-www-form-urlencoded<br>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</li>
<li>不符合以上条件的请求就是复杂请求了。复杂请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。例如我们用PUT向后台请求时，属于复杂请求。</li>
</ul>
<p>和 jsonp 一样，CORS 也严重依赖后端的协助。</p>
<h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h2><p>postMessage 是 HTML5 XMLHttpRequest Level 2 中的API，且是为数不多可以跨域操作的 window 属性之一，它可用于解决以下方面的问题：</p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的iframe消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<p>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p>
<blockquote>
<p>otherWindow.postMessage(message, targetOrigin, [transfer]);</p>
</blockquote>
<ul>
<li>message: 将要发送到其他 window 的数据。</li>
<li>targetOrigin：通过窗口的 origin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配 targetOrigin 提供的值，那么消息就不会被发送，只有三者完全匹配，消息才会被发送。</li>
<li>transfer(可选)：是一串和 message 同时传递的 Transferable 对象，这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li>
</ul>
<h2 id="webSocket"><a href="#webSocket" class="headerlink" title="webSocket"></a>webSocket</h2><p>Websocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket 和 HTTP 都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。原生 WebSocket API 使用起来不太方便，我们使用<code>Socket.io</code>，它很好地封装了 webSocket 接口，提供了更简单、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。</p>
<h2 id="Node中间件正向代理"><a href="#Node中间件正向代理" class="headerlink" title="Node中间件正向代理"></a>Node中间件正向代理</h2><p><strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong></p>
<p>代理服务器，需要做以下几个步骤：</p>
<ul>
<li>接受客户端请求 </li>
<li>将请求转发给服务器</li>
<li>拿到服务器响应数据</li>
<li>将响应转发给客户端</li>
</ul>
<h2 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h2><p>实现原理类似于 Node 中间件正向代理，需要你搭建一个中转 nginx服务器，用于转发请求。使用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。通过nginx配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。</p>
<p>正向代理和反向代理的比较：</p>
<ul>
<li>从用途上来讲：正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。</li>
<li>从安全性来讲：正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。</li>
<li>从使用方来看：正向代理是浏览器端进行配置的，与服务器端无关，甚至可以对服务端隐藏。反向代理是服务器端配置的，对浏览器端是透明的。</li>
</ul>
<h2 id="window-name-iframe"><a href="#window-name-iframe" class="headerlink" title="window.name + iframe"></a><code>window.name</code> + iframe</h2><p>window.name属性的独特之处：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。通过iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的window.name 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<h2 id="window-location-hash-iframe"><a href="#window-location-hash-iframe" class="headerlink" title="window.location.hash + iframe"></a><code>window.location.hash</code> + iframe</h2><p>a.html 欲与 c.html 跨域相互通信，通过中间页 b.html 来实现。 三个页面，不同域之间利用 iframe 的 window.location.hash 传值，相同域之间直接 js 访问来通信。一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给b.html ，最后 b.html 将结果放到 a.html 的 hash 值中。</p>
<h2 id="document-domain-ifame"><a href="#document-domain-ifame" class="headerlink" title="document.domain + ifame"></a><code>document.domain</code> + ifame</h2><p>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>CORS 支持所有类型的 HTTP 请求，是跨域 HTTP 请求的根本解决方案。</li>
<li>jsonp 只支持 GET 请求，jsonp 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</li>
<li>不管是 Node 中间件正向代理还是 nginx 反向代理，主要是通过同源策略对服务器不加限制。</li>
<li>日常工作中，用得比较多的跨域方案是 CORS 和 nginx 反向代理。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/09/21/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。相比于传统的数组，链表的一个好处在于，添加或删除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。在数组中，我们可以直接访问任何位置的任何元素，而想要访问链表中间的一个元素，则需要从起点（表头）开始迭代链表直到找到所需的元素。</p>
<a id="more"></a>
<h2 id="LinkedList类的模拟实现"><a href="#LinkedList类的模拟实现" class="headerlink" title="LinkedList类的模拟实现"></a>LinkedList类的模拟实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建相等性比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultEquals</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a === b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建Node（节点）类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">        <span class="built_in">this</span>.element = element;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(equalsFn = defaultEquals) &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="built_in">this</span>.equalsFn = equalsFn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向链表尾部添加元素</span></span><br><span class="line">    push(element) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">        <span class="keyword">let</span> current;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">while</span> (current.next != <span class="literal">null</span>) &#123; <span class="comment">// 获取最后一项</span></span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = node; <span class="comment">// 将其next赋为新元素，建立链接</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环迭代链表直到目标位置</span></span><br><span class="line">    getElementAt(index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="built_in">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">let</span> node = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; index &amp;&amp; node != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">                node = node.next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从链表中移除元素</span></span><br><span class="line">    removeAt(index) &#123;</span><br><span class="line">        <span class="comment">// 检查越界值</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="comment">// 移除第一项</span></span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.head = current.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// let previous;</span></span><br><span class="line">                <span class="comment">// for (let i = 0; i &lt; index; i++) &#123;</span></span><br><span class="line">                <span class="comment">//     previous = current;</span></span><br><span class="line">                <span class="comment">//     current = current.next;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">// previous.next = current.next;</span></span><br><span class="line">                <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>);</span><br><span class="line">                current = previous.next;</span><br><span class="line">                <span class="comment">// 将previous与current的下一项链接起来：跳过current，从而移除它</span></span><br><span class="line">                previous.next = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.count--;</span><br><span class="line">            <span class="keyword">return</span> current.element;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在任意位置插入元素</span></span><br><span class="line">    insert(element, index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="built_in">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; <span class="comment">// 在第一个位置添加</span></span><br><span class="line">                <span class="keyword">const</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">                node.next = current;</span><br><span class="line">                <span class="built_in">this</span>.head = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">const</span> current = previous.next;</span><br><span class="line">                node.next = current;</span><br><span class="line">                previous.next = node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.count++; <span class="comment">// 更新链表的长度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个元素的位置</span></span><br><span class="line">    indexOf(element) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.count &amp;&amp; current != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.equalsFn(element, current.element)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从链表中移除元素</span></span><br><span class="line">    remove(element) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="built_in">this</span>.indexOf(element);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.removeAt(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取链表的大小</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查链表是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size() === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取链表头部</span></span><br><span class="line">    getHead() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建toString方法</span></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.head.element&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="built_in">this</span>.head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">this</span>.size() &amp;&amp; current != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">            objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>, <span class="subst">$&#123;current.element&#125;</span>`</span>;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个节点的链接；而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素。</p>
<h2 id="DoublyLinkedList类的模拟实现"><a href="#DoublyLinkedList类的模拟实现" class="headerlink" title="DoublyLinkedList类的模拟实现"></a>DoublyLinkedList类的模拟实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建新的节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element, next, prev) &#123;</span><br><span class="line">        <span class="built_in">super</span>(element, next);</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(equalsFn = defaultEquals) &#123;</span><br><span class="line">        <span class="built_in">super</span>(equalsFn);</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在任意位置插入新元素</span></span><br><span class="line">    insert(element, index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="built_in">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = <span class="keyword">new</span> DoublyNode(element);</span><br><span class="line">            <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.head = node;</span><br><span class="line">                    <span class="built_in">this</span>.tail = node;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.next = <span class="built_in">this</span>.head;</span><br><span class="line">                    current.prev = node;</span><br><span class="line">                    <span class="built_in">this</span>.head = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="built_in">this</span>.count) &#123; <span class="comment">// 最后一项</span></span><br><span class="line">                current = <span class="built_in">this</span>.tail;</span><br><span class="line">                current.next = node;</span><br><span class="line">                node.prev = current;</span><br><span class="line">                <span class="built_in">this</span>.tail = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>);</span><br><span class="line">                current = previous.next;</span><br><span class="line">                node.next = current;</span><br><span class="line">                previous.next = node;</span><br><span class="line">                current.prev = node;</span><br><span class="line">                node.prev = previous;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.count++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从任意位置移除元素</span></span><br><span class="line">    removeAt(index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.head = current.next;</span><br><span class="line">                <span class="comment">// 如果只有一项，更新tail</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.count === <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.tail = <span class="literal">undefined</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.head.prev = <span class="literal">undefined</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="built_in">this</span>.count - <span class="number">1</span>) &#123; <span class="comment">// 最后一项</span></span><br><span class="line">                current = <span class="built_in">this</span>.tail;</span><br><span class="line">                <span class="built_in">this</span>.tail = current.prev;</span><br><span class="line">                <span class="built_in">this</span>.tail.next = <span class="literal">undefined</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = <span class="built_in">this</span>.getElementAt(index);</span><br><span class="line">                <span class="keyword">const</span> previous = current.prev;</span><br><span class="line">                <span class="comment">// 将previous与current的下一项链接起来——跳过current</span></span><br><span class="line">                previous.next = current.next;</span><br><span class="line">                current.next.prev = previous;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.count--;</span><br><span class="line">            <span class="keyword">return</span> current.element;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表的链表的唯一区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用undefined，而是指向第一个元素。双向循环链表有指向head元素的tail.next和指向tail元素的head.prev。</p>
<h2 id="CircularLinkedList类的模拟实现"><a href="#CircularLinkedList类的模拟实现" class="headerlink" title="CircularLinkedList类的模拟实现"></a>CircularLinkedList类的模拟实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(equalsFn = defaultEquals) &#123;</span><br><span class="line">        <span class="built_in">super</span>(equalsFn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在任意位置插入新元素</span></span><br><span class="line">    insert(element, index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="built_in">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">            <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.head = node;</span><br><span class="line">                    node.next = <span class="built_in">this</span>.head;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.next = current;</span><br><span class="line">                    current = <span class="built_in">this</span>.getElementAt(<span class="built_in">this</span>.size());</span><br><span class="line">                    <span class="comment">// 更新最后一个元素</span></span><br><span class="line">                    <span class="built_in">this</span>.head = node;</span><br><span class="line">                    current.next = <span class="built_in">this</span>.head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>);</span><br><span class="line">                node.next = previous.next;</span><br><span class="line">                previous.next = node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.count--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从任意位置移除元素</span></span><br><span class="line">    removeAt(index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.size() === <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.head = <span class="literal">undefined</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> removed = <span class="built_in">this</span>.head;</span><br><span class="line">                    current = <span class="built_in">this</span>.getElementAt(<span class="built_in">this</span>.size());</span><br><span class="line">                    <span class="built_in">this</span>.head = <span class="built_in">this</span>.head.next;</span><br><span class="line">                    current.next = <span class="built_in">this</span>.head;</span><br><span class="line">                    current = removed;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不需要修改循环链表最后一个元素</span></span><br><span class="line">                <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>);</span><br><span class="line">                current = previous.next;</span><br><span class="line">                previous.next = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.count--;</span><br><span class="line">            <span class="keyword">return</span> current.element;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="有序链表"><a href="#有序链表" class="headerlink" title="有序链表"></a>有序链表</h2><p>有序链表是指保持有序的链表结构。除了使用排序算法之外，我们还可以将元素插入到正确的位置来保证链表的有序性。</p>
<h2 id="SortedLinkedList类的模拟实现"><a href="#SortedLinkedList类的模拟实现" class="headerlink" title="SortedLinkedList类的模拟实现"></a>SortedLinkedList类的模拟实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明Compare常量</span></span><br><span class="line"><span class="keyword">const</span> Compare = &#123;</span><br><span class="line">    LESS_THAN: <span class="number">-1</span>,</span><br><span class="line">    BIGGER_THAN: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建相等性比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultCompare</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(equalsFn = defaultEquals, compareFn = defaultCompare) &#123;</span><br><span class="line">        <span class="built_in">super</span>(equalsFn);</span><br><span class="line">        <span class="built_in">this</span>.compareFn = compareFn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有序插入元素</span></span><br><span class="line">    insert(element, index = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.insert(element, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> pos = <span class="built_in">this</span>.getIndexNextSortedElement(element);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.insert(element, pos);</span><br><span class="line">    &#125;</span><br><span class="line">    getIndexNextSortedElement(element) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="built_in">this</span>.size() &amp;&amp; current; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> comp = <span class="built_in">this</span>.compareFn(element, current.element);</span><br><span class="line">            <span class="keyword">if</span> (comp === Compare.LESS_THAN) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="利用链表创建栈"><a href="#利用链表创建栈" class="headerlink" title="利用链表创建栈"></a>利用链表创建栈</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.it</span><br><span class="line">        ems = <span class="keyword">new</span> DoublyLinkedList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向栈添加元素</span></span><br><span class="line">    push(element) &#123;</span><br><span class="line">        <span class="built_in">this</span>.items.push(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从栈移除元素</span></span><br><span class="line">    pop() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.removeAt(<span class="built_in">this</span>.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    peek() &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.getElementAt(<span class="built_in">this</span>.size() - <span class="number">1</span>).element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取栈的大小</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空栈元素</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="built_in">this</span>.items.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建toString方法</span></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了栈，我们还可以使用LinkedList类及其变种作为内部的数据结构来创建其他的数据结构，例如队列、双端队列等，这里就不再赘述，有兴趣的可以自己实现一下。这里也不再演示这些链表中方法的使用了，有兴趣的可以自己做个demo测试一下，如果有任何的问题，欢迎评论区留言。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2020/09/21/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是遵循<strong>先进先出</strong>（FIFO，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。</p>
<a id="more"></a>
<h2 id="Queue类的模拟实现"><a href="#Queue类的模拟实现" class="headerlink" title="Queue类的模拟实现"></a>Queue类的模拟实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向队列添加元素</span></span><br><span class="line">    enqueue(element) &#123;</span><br><span class="line">        <span class="built_in">this</span>.items[<span class="built_in">this</span>.count] = element;</span><br><span class="line">        <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从队列移除元素 </span></span><br><span class="line">    dequeue() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount];</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount];</span><br><span class="line">        <span class="built_in">this</span>.lowestCount++;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看队列头元素</span></span><br><span class="line">    peek() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查队列是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count - <span class="built_in">this</span>.lowestCount === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取队列的长度</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count - <span class="built_in">this</span>.lowestCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空队列</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建toString方法</span></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount]&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">this</span>.lowestCount + <span class="number">1</span>; i &lt; <span class="built_in">this</span>.count; i++) &#123;</span><br><span class="line">            objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>, <span class="subst">$&#123;<span class="built_in">this</span>.items[i]&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>双端队列是一种允许我们同时从前端和后端添加和删除元素的特殊队列。</p>
<h2 id="Deque类的模拟实现"><a href="#Deque类的模拟实现" class="headerlink" title="Deque类的模拟实现"></a>Deque类的模拟实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deque</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向双端队列的前端添加元素</span></span><br><span class="line">    addFront(element) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.addBack(element);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.lowestCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.lowestCount--;</span><br><span class="line">            <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount] = element;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">this</span>.count; i &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.items[i] = <span class="built_in">this</span>.items[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.count++;</span><br><span class="line">            <span class="built_in">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.items[<span class="number">0</span>] = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向双端队列的后端添加元素</span></span><br><span class="line">    addBack(element) &#123;</span><br><span class="line">        <span class="built_in">this</span>.items[<span class="built_in">this</span>.count] = element;</span><br><span class="line">        <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从双端队列的前端移除元素</span></span><br><span class="line">    removeFront() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount];</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount];</span><br><span class="line">        <span class="built_in">this</span>.lowestCount++;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从双端队列的后端移除元素</span></span><br><span class="line">    removeBack() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.count--;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">this</span>.items[<span class="built_in">this</span>.count];</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.count];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看双端队列前端头元素</span></span><br><span class="line">    peekFront() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看双端队列后端头元素</span></span><br><span class="line">    peekBack() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.count - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取双端队列的大小</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count - <span class="built_in">this</span>.lowestCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查双端队列是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size() === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空双端队列</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建toString方法</span></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount]&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">this</span>.lowestCount + <span class="number">1</span>; i &lt; <span class="built_in">this</span>.count; i++) &#123;</span><br><span class="line">            objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="built_in">this</span>.items[i]&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不再演示Queue类和Deque类中方法的使用了，有兴趣的可以自己做个demo测试一下，如果有任何的问题，欢迎评论区留言。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2020/09/20/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合是由一种<strong>无序</strong>且<strong>唯一</strong>（即不能重复）的项组成的。</p>
<a id="more"></a>
<h2 id="Set类的模拟实现"><a href="#Set类的模拟实现" class="headerlink" title="Set类的模拟实现"></a>Set类的模拟实现</h2><p>虽然ES2015给我们提供了原生的Set类，但是并没有实现并集、交集、差集、子集等数学运算，这里我们模拟实现自己的Set类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果元素在集合中，返回true，否则返回false</span></span><br><span class="line">    has(element) &#123;</span><br><span class="line">        <span class="keyword">return</span> element <span class="keyword">in</span> <span class="built_in">this</span>.items;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向集合添加一个元素</span></span><br><span class="line">    add(element) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.has(element)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.items[element] = element;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从集合移除一个元素</span></span><br><span class="line">    <span class="keyword">delete</span>(element) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.has(element)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.items[element];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除集合中的所有元素</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回集合所包含元素的数量。它与数组的length属性类似</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items).length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个包含集合中所有值（元素）的数组</span></span><br><span class="line">    values() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.values(<span class="built_in">this</span>.items);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 并集</span></span><br><span class="line">    union(otherSet) &#123;</span><br><span class="line">        <span class="keyword">const</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="built_in">this</span>.values().forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            unionSet.add(value);</span><br><span class="line">        &#125;);</span><br><span class="line">        otherSet.values().forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            unionSet.add(value);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> unionSet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交集</span></span><br><span class="line">    intersection(otherSet) &#123;</span><br><span class="line">        <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="keyword">const</span> values = <span class="built_in">this</span>.values();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span>  i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (otherSet.has(values[i])) &#123;</span><br><span class="line">                intersectionSet.add(values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersectionSet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改进版交集</span></span><br><span class="line">    intersectionPlus(otherSet) &#123;</span><br><span class="line">        <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="keyword">const</span> values = <span class="built_in">this</span>.values();</span><br><span class="line">        <span class="keyword">const</span> otherValues = otherSet.values();</span><br><span class="line">        <span class="keyword">let</span> biggerSet = values;</span><br><span class="line">        <span class="keyword">let</span> smallerSet = otherValues;</span><br><span class="line">        <span class="keyword">if</span> (otherValues.length - values.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            biggerSet = otherValues;</span><br><span class="line">            smallerSet = values;</span><br><span class="line">        &#125;</span><br><span class="line">        smallerSet.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (biggerSet.includes(value)) &#123;</span><br><span class="line">                intersectionSet.add(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> intersectionSet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 差集</span></span><br><span class="line">    difference(otherSet) &#123;</span><br><span class="line">        <span class="keyword">const</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="built_in">this</span>.values().forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!otherSet.has(value)) &#123;</span><br><span class="line">                differenceSet.add(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> differenceSet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子集</span></span><br><span class="line">    isSubsetOf(otherSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.size() &gt; otherSet.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> isSubset = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.values().every(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!otherSet.has(value)) &#123;</span><br><span class="line">                isSubset = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> isSubset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不再演示Set类中方法的使用了，有兴趣的可以自己做个demo测试一下，如果有任何的问题，欢迎评论区留言。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖和节流</title>
    <url>/2020/09/16/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>防抖和节流都是前端性能优化的方式。在前端开发中，我们经常会需要绑定一些持续触发的事件，如input、scroll、mousemove、resize等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数，这时候我们就会用到防抖和节流，让我们先看一个简单的例子：</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #count &#123;</span><br><span class="line">            height: <span class="number">150</span>px;</span><br><span class="line">            line-height: <span class="number">150</span>px;</span><br><span class="line">            text-align: center;</span><br><span class="line">            color: #fff;</span><br><span class="line">            background-color: #ccc;</span><br><span class="line">            font-size: <span class="number">80</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;count&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            oDiv.innerHTML = num++;</span><br><span class="line">        &#125;</span><br><span class="line">        oDiv.onmousemove = count;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，div 元素绑定了 mousemove 事件，当鼠标在 div（灰色）区域中移动的时候会持续地去触发该事件导致频繁执行函数。效果如下:</p>
<p><img src="https://s1.ax1x.com/2020/09/20/wTEIun.gif" alt="alt"></p>
<p>可以看到，在没有通过其它操作的情况下，函数被频繁地执行导致页面上数据变化特别快。所以，接下来让我们来看看防抖和节流是如何去解决这个问题的。</p>
<h2 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h2><p>在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms，然后：</p>
<ul>
<li>如果在200ms内没有再次触发滚动事件，那么就执行函数</li>
<li>如果在200ms内再次触发滚动事件，那么当前的计时取消，重新开始计时</li>
</ul>
<blockquote>
<p>如果短时间内大量触发同一事件，只会执行一次函数。</p>
</blockquote>
<p>可设计如下的防抖函数，使得触发事件后count函数不会立即执行，而是在1s后执行，如果在1s内又触发了事件，则会重新计算函数执行时间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer); <span class="comment">//延迟时间内再次触发则清空计时器</span></span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(fn, delay); <span class="comment">//开启新的计时器</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">oDiv.onmousemove = debounce(count, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img src="https://s1.ax1x.com/2020/09/20/wTAL6A.gif" alt="alt"></p>
<p>到这里，已经把防抖实现了，现在给出定义：</p>
<p><strong>对于短时间内连续触发的事件（如上面的mousemove事件），防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行一次。</strong></p>
<blockquote>
<p>还有一种防抖函数，触发事件后函数会立即执行，然后延迟时间内不触发事件才能继续执行函数，这里不再赘述，详情请看<a href="https://www.jianshu.com/p/c8b86b09daf0">防抖和节流</a>。</p>
</blockquote>
<h2 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h2><p>所谓节流，就是指<strong>连续触发事件但是在设定的延迟时间只执行一次函数</strong>，节流会稀释函数的执行频率。</p>
<p>对于上面的mousemove事件，可设计如下的节流函数，在持续触发事件的过程中，count函数不会立即执行，并且每 1s 执行一次，在停止触发事件后，函数还会再执行一次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> valid = <span class="literal">true</span>; <span class="comment">//设置一个状态位来表示fn函数是否处于工作状态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!valid) <span class="keyword">return</span> <span class="literal">false</span>； <span class="comment">//fn函数不工作</span></span><br><span class="line">        valid = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//工作时间，执行fn函数并且在间隔期内把状态位设为无效 </span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">            fn(); </span><br><span class="line">            valid = <span class="literal">true</span>; </span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">oDiv.onmousemove = throttle(count, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="https://s1.ax1x.com/2020/09/20/wTAOOI.gif" alt="alt"></p>
<p>从上面的动图可以看出，如果在灰色区域一直移动鼠标，那么会以1s的时间间隔，逐渐计数。</p>
<blockquote>
<p>当然节流函数不止上面这一种实现方案，例如可以完全不借setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。也可以直接将setTimeout返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样。详情请看<a href="https://www.jianshu.com/p/c8b86b09daf0">防抖和节流</a>。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>防抖和节流都是前端性能优化的方式，防抖是控制次数，而节流是控制频率。一种常见的应用场景是浏览器的搜索引擎，对于搜索框input事件，例如要支持输入实时搜索可以使用节流方案（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求，防抖和节流可以有效避免浏览器向服务器发出过多无用的请求。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>this指向</title>
    <url>/2020/09/17/this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="从一道面试题开始说起"><a href="#从一道面试题开始说起" class="headerlink" title="从一道面试题开始说起"></a>从一道面试题开始说起</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    number: <span class="number">3</span>,</span><br><span class="line">    fn1: (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> number;</span><br><span class="line">        <span class="built_in">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">        number = number * <span class="number">2</span>;</span><br><span class="line">        number = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> num = <span class="built_in">this</span>.number;</span><br><span class="line">            <span class="built_in">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(num);</span><br><span class="line">            number *= <span class="number">3</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(number);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> fn1 = obj.fn1;</span><br><span class="line">fn1.call(<span class="literal">null</span>);</span><br><span class="line">obj.fn1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.number);</span><br></pre></td></tr></table></figure>
<p>首先思考一下结果是什么，然后再在浏览器中执行一遍，如果两者一致，且你每一步的依据都很明确，那么恭喜你，你对this指向已经很清楚了，下面的内容你可以选择看或者不看，如果你感觉很晕，或者对自己的答案不确定，那么请继续往下阅读。我相信，你看完这篇文章，一定对this指向有更清晰的理解，这道题就留到最后讲解。那么，让我们开始吧！</p>
<a id="more"></a>
<h2 id="this是什么？"><a href="#this是什么？" class="headerlink" title="this是什么？"></a>this是什么？</h2><p>this在前端工作中使用的频率很高，合理的使用this可以让我们写出简洁且复用性高的代码，而且this作为前端面试中的高频考点，了解清楚是很有必要的。首先我们需要明确的一点是this不是指向自身，this是一个指针，指向调用函数的对象。为了能一眼看出this的指向，我们首先需要知道this的绑定规则有哪些：</p>
<ul>
<li>默认绑定</li>
<li>隐式绑定</li>
<li>显式绑定（硬绑定）</li>
<li>new绑定</li>
</ul>
<p>是不是感觉脑阔疼，没事，我们一个一个来梳理清楚。</p>
<h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><p>默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用，来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">sayHi();</span><br></pre></td></tr></table></figure>
<p>在调用sayHi()时，应用了默认绑定，this指向全局对象（非严格模式下），严格模式下，this指向undefined，undefined上没有this对象，会抛出错误。上面的代码，如果在浏览器环境中运行，那么结果就是 Hello, Tom，但是如果在node环境中运行，结果就是Hello, undefined，这是因为node中name并不是挂在全局对象上的。</p>
<blockquote>
<p>本文中，如不特殊说明，默认为浏览器环境执行结果。</p>
</blockquote>
<h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">person.sayHi();</span><br></pre></td></tr></table></figure>
<p>执行上面的代码，控制台打印的结果是Hello, Bob。sayHi函数声明在外部，严格来说并不属于person，但是在调用sayHi时,调用位置会使用person的上下文来引用函数，隐式绑定会把函数调用中的this(即此例sayHi函数中的this)绑定到这个上下文对象（即此例中的person）。</p>
<blockquote>
<p>需要注意的是：对象属性链中只有最后一层会影响到调用位置。</p>
</blockquote>
<p>来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    friend: person2</span><br><span class="line">&#125;;</span><br><span class="line">person1.friend.sayHi();</span><br></pre></td></tr></table></figure>
<p>执行上面的代码，控制台打印的结果是Hello, Tom。因为只有最后一层会确定this指向的是什么，不管有多少层，<strong>在判断this的时候，我们只关注最后一层</strong>，即此处的friend。</p>
<p>隐式绑定有一个大陷阱，绑定很容易丢失(或者说容易给我们造成误导，我们以为this指向的是什么，但是实际上并非如此)，来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = person.sayHi;</span><br><span class="line">Hi();</span><br></pre></td></tr></table></figure>
<p>结果是：Hello, Tom。这是为什么呢？Hi直接指向了sayHi的引用，在调用的时候，跟person没有半毛钱的关系，针对此类问题，我建议大家只需牢牢记住这个格式：**XXX.fn()**，fn()前如果什么都没有，那么肯定不是隐式绑定。</p>
<p>除了上面这种丢失之外，另一种常见的隐式绑定的丢失是发生在回调函数中(事件回调也是其中一种)，我们来看下面一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jerry&#x27;</span>,</span><br><span class="line">    sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;Hello,&#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name=<span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">person1.sayHi();</span><br><span class="line"><span class="built_in">setTimeout</span>(person2.sayHi, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    person2.sayHi();</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Hello, Tom</span><br><span class="line">Hello, Tom</span><br><span class="line">Hello, Bob</span><br></pre></td></tr></table></figure>
<ul>
<li>第一条输出很容易理解，setTimeout的回调函数中，this使用的是默认绑定，非严格模式下，执行的是全局对象。</li>
<li>第二条输出是不是有点迷惑了？说好XXX.fun()的时候，fun中的this指向的是XXX呢，为什么这次却不是这样了！Why？其实这里我们可以这样理解：setTimeout(fn, delay){ fn(); }，相当于是将person2.sayHi赋值给了一个变量，最后执行了变量，这个时候，sayHi中的this显然和person2就没有关系了。</li>
<li>第三条虽然也是在setTimeout的回调中，但是我们可以看出，这是执行的是person2.sayHi()使用的是隐式绑定，因此这是this指向的是person2，跟当前的作用域没有任何关系。</li>
</ul>
<p>读到这里，或许你已经有点疲倦了，但是答应我，别放弃，好吗？再坚持一下，就可以掌握这个知识点了。</p>
<p><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/this.png" alt="alt"></p>
<h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><p>显式绑定比较好理解，就是通过call、apply和bind的方式，显式的指定this所指向的对象。</p>
<blockquote>
<p>注意:《你不知道的Javascript》中将bind单独作为硬绑定讲解。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = person.sayHi;</span><br><span class="line">Hi.call(person); <span class="comment">// Hi.apply(person)</span></span><br></pre></td></tr></table></figure>
<p>结果为：Hello, Bob。因为使用显式绑定明确将this绑定在了person上。</p>
<p>那么，使用了显式绑定，是不是就意味着不会出现隐式绑定所遇到的绑定丢失呢？显然不是这样的，不信，来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;;</span><br><span class="line">Hi.call(person, person.sayHi); </span><br></pre></td></tr></table></figure>
<p>结果是：Hello, Tom。原因很简单，Hi.call(person, person.sayHi)的确是将this绑定到Hi中的this了。但是在执行fn的时候，相当于直接调用了sayHi方法(记住: person.sayHi已经被赋值给fn了，像前面介绍的隐式绑定丢失的情况一样)，没有指定this的值，对应的是默认绑定。</p>
<p>现在，我们希望绑定不会丢失，要怎么做？很简单，调用fn的时候，也给它显式绑定，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello,&#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Hi.call(person, person.sayHi);</span><br></pre></td></tr></table></figure>
<p>现在，输出的结果为：Hello, Bob。因为person被绑定到Hi函数中的this上，fn又将这个对象绑定给了sayHi的函数。这时，sayHi中的this指向的就是person对象。</p>
<h2 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h2><p>革命胜利的曙光已经出现，下面我们来看最后一种绑定——new绑定。</p>
<p>javascript和C++不一样，并没有类，在javascript中，构造函数只是使用new操作符时被调用的函数，这些函数和普通的函数并没有什么不同，它不属于某个类，也不可能实例化出一个类。任何一个函数都可以使用new来调用，因此其实并不存在构造函数，而只有对于函数的“构造调用”。</p>
<p>使用new来调用函数，会自动执行下面的操作：</p>
<ol>
<li>创建一个空对象，构造函数中的this指向这个空对象；</li>
<li>这个新对象被执行 &#91;&#91;原型&#93;&#93; 连接；</li>
<li>执行构造函数方法，属性和方法被添加到this引用的对象中</li>
<li>如果构造函数中没有返回其它对象，那么返回this，即创建的这个的新对象，否则，返回构造函数中返回的对象。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> target = &#123;&#125;; <span class="comment">//创建的新对象</span></span><br><span class="line">    <span class="comment">//第一个参数是构造函数</span></span><br><span class="line">    <span class="keyword">let</span> [<span class="keyword">constructor</span>, ...args] = [...arguments];</span><br><span class="line">    //执行[[原型]]连接;target 是 <span class="keyword">constructor</span> 的实例</span><br><span class="line">    target.__proto__ = <span class="keyword">constructor</span>.prototype;</span><br><span class="line">    //执行构造函数，将属性或方法添加到创建的空对象上</span><br><span class="line">    let result = <span class="keyword">constructor</span>.apply(target, args);</span><br><span class="line">    if (result &amp;&amp; (typeof (result) == &quot;object&quot; || typeof (result) == &quot;function&quot;)) &#123;</span><br><span class="line">        <span class="comment">//如果构造函数执行的结构返回的是一个对象，那么返回这个对象</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果构造函数返回的不是一个对象，返回创建的新对象</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因此，我们使用new来调用函数的时候，就会把这个函数的this绑定到实例对象上，如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Hi = <span class="keyword">new</span> sayHi(<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hello, &#x27;</span>, Hi.name);</span><br></pre></td></tr></table></figure>
输出结果为 Hello, Tom，原因是因为在var Hi = new sayHi(‘Yevtte’);这一步，会将sayHi中的this绑定到Hi对象上。</li>
</ol>
<h2 id="绑定优先级"><a href="#绑定优先级" class="headerlink" title="绑定优先级"></a>绑定优先级</h2><p>现在我们已经知道了this有四种绑定规则，但是如果同时应用了多种规则，怎么办？显然，我们需要了解哪一种绑定方式的优先级更高，这四种绑定的优先级为：<strong>new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</strong>。这个规则是如何得到的，大家如果有兴趣，可以自己写个demo去测试，或者记住上面的结论即可。</p>
<h2 id="绑定例外的情况"><a href="#绑定例外的情况" class="headerlink" title="绑定例外的情况"></a>绑定例外的情况</h2><p>凡事都有例外，this的规则也是这样。如果我们将null或者是undefined作为this的绑定对象传入call、apply或者是bind，这些值在调用时会被忽略，实际应用的是默认绑定规则，来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hello, &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">bar.call(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>输出的结果是：Hello, Tom，因为这时实际应用的是默认绑定规则。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数是ES6中新增的，它和普通函数有一些区别，箭头函数没有自己的this，它的this继承于外层代码库中的this。箭头函数在使用时，需要注意以下几点：</p>
<ul>
<li>箭头函数体内的this对象，继承的是外层代码块的this。</li>
<li>箭头函数不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>箭头函数不可以使用arguments对象，该对象在箭头函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li>箭头函数中不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</li>
<li>箭头函数没有自己的this，所以不能用call()、apply()、bind()这些方法去改变this的指向。</li>
</ul>
<p>下面我们通过一个例子来看看箭头函数的this指向什么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    hi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    say: <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> hi = obj.hi();      <span class="comment">//输出obj对象</span></span><br><span class="line">hi();                   <span class="comment">//输出obj对象</span></span><br><span class="line"><span class="keyword">let</span> sayHi = obj.sayHi();</span><br><span class="line"><span class="keyword">let</span> fun1 = sayHi();     <span class="comment">//输出window</span></span><br><span class="line">fun1();                 <span class="comment">//输出window</span></span><br><span class="line">obj.say();              <span class="comment">//输出window</span></span><br></pre></td></tr></table></figure>
<p>那么这是为什么呢？如果说箭头函数中的this是定义时所在的对象，那么输出的结果不是大家预期的，按照这个定义，say中的this应该是obj才对。不要慌，我们来分析一下上面代码的执行结果：</p>
<ol>
<li>obj.hi()：对应了this的隐式绑定规则，this绑定在obj上，所以输出obj，很好理解；</li>
<li>hi()：这一步执行的就是箭头函数，箭头函数继承上一个代码库的this，刚刚我们得出上一层的this是obj，显然这里的this就是obj；</li>
<li>执行sayHi()：这一步也很好理解，我们前面说过这种隐式绑定丢失的情况，这个时候this执行的是默认绑定，this指向的是全局对象window.</li>
<li>fun1()：这一步执行的是箭头函数，如果按照之前的理解，this指向的是箭头函数定义时所在的对象，那么这显然是说不通。OK，按照箭头函数的this是继承于外层代码库的this就很好理解了。外层代码库我们刚刚分析了，this指向的是window，因此这的输出结果是window.</li>
<li>obj.say()：执行的是箭头函数，当前的代码块obj中是不存在this的，只能往上找，就找到了全局的this，指向的是window。</li>
</ol>
<p>现在是不是清晰多了，那么箭头函数的this是静态的吗？依旧使用前面创建的obj对象，我们来看看下面代码的执行结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = obj.sayHi();</span><br><span class="line"><span class="keyword">let</span> fun1 = sayHi();          <span class="comment">//输出window</span></span><br><span class="line">fun1();                      <span class="comment">//输出window</span></span><br><span class="line"><span class="keyword">let</span> fun2 = sayHi.bind(obj)();<span class="comment">//输出obj</span></span><br><span class="line">fun2();                      <span class="comment">//输出obj</span></span><br></pre></td></tr></table></figure>
<p>可以看出，fun1和fun2对应的是同样的箭头函数，但是this的输出结果是不一样的。所以，请大家牢牢记住一点：<strong>箭头函数没有自己的this，箭头函数中的this继承于外层代码库中的this</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于this的规则，至此，就告一段落了，但是想要一眼就能看出this所绑定的对象，还需要不断的训练。下面我们总结一下如何准确判断this的指向：</p>
<ul>
<li>函数是否在new中调用(new绑定)，如果是，那么this绑定的是新创建的对象。</li>
<li>函数是否通过call或apply调用，或者使用了bind(即硬绑定)，如果是，那么this绑定的就是指定的对象。</li>
<li>函数是否在某个上下文对象中调用(隐式绑定)，如果是的话，this绑定的是那个上下文对象，一般是obj.foo()。</li>
<li>如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到undefined，否则绑定到全局对象。</li>
<li>如果把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。</li>
<li>如果是箭头函数，箭头函数的this继承的是外层代码块的this。</li>
</ul>
<p>下面我们来看看文章开头的例子，我们来分析一下那段代码的执行过程：</p>
<ol>
<li>在定义obj的时候，fn对应的闭包就执行了，返回其中的函数，执行闭包中代码时，显然应用不了new绑定(因为没有出现new关键字)，显式绑定也没有（没有出现call、apply或bind关键字），隐式绑定有没有？很显然没有，因为没有出现XX.fn()，所以这里应用的就是默认绑定了，非严格模式下this绑定到了window上(浏览器执行环境)。<strong>这里很容易被迷惑的就是以为this指向的是obj，一定要注意，除非是箭头函数，否则this跟词法作用域是两回事，一定要牢记在心。</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.number * = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
window.number的值是10（var number定义的全局变量是挂在window上的）。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">number = number * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
number的值是NaN，注意我们这边定义了一个number，但是没有赋值，number的值是undefined，Number(undefined)-&gt;NaN。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">number = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
number的值被赋值成3。</li>
<li>myFun.call(null)：我们前面说了，call的第一个参数传null，调用的是默认绑定。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">this</span>.number;</span><br><span class="line">    <span class="built_in">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">    number *= <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
执行时：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="built_in">this</span>.number; <span class="comment">//num=10，此时this指向的是window</span></span><br><span class="line"><span class="built_in">this</span>.number * = <span class="number">2</span>;     <span class="comment">//window.number = 20</span></span><br><span class="line"><span class="built_in">console</span>.log(num);      <span class="comment">//输出结果为10</span></span><br><span class="line">number *= <span class="number">3</span>;           <span class="comment">//number=9，这个number对应的闭包中的number，闭包中的number的是3</span></span><br><span class="line"><span class="built_in">console</span>.log(number);   <span class="comment">//输出的结果是9</span></span><br></pre></td></tr></table></figure></li>
<li>obj.fn()：应用了隐式绑定，fn中的this对应的是obj。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="built_in">this</span>.number;<span class="comment">//num = 3，此时this指向的是obj</span></span><br><span class="line"><span class="built_in">this</span>.number *= <span class="number">2</span>;     <span class="comment">//obj.number = 6</span></span><br><span class="line"><span class="built_in">console</span>.log(num);     <span class="comment">//输出结果为3</span></span><br><span class="line">number *= <span class="number">3</span>;          <span class="comment">//number=27，这个number对应的闭包中的number;闭包中的number的此时是9</span></span><br><span class="line"><span class="built_in">console</span>.log(number);  <span class="comment">//输出的结果是27</span></span><br></pre></td></tr></table></figure></li>
<li>最后一步console.log(window.number)输出的结果是20。因此在严格模式下，那段代码控制台输出的结果为：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>撒花撒花，结束了，恭喜坚持读完的小伙伴们，你们成功get到了this这个知识点，但是想要完全掌握，还是要多回顾和练习。如果你们有什么问题，也欢迎评论区留言，大家一起进步。</p>
<p><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/end.png" alt="alt"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
