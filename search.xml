<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从闭包说起</title>
    <url>/2020/09/18/%E4%BB%8E%E9%97%AD%E5%8C%85%E8%AF%B4%E8%B5%B7/</url>
    <content><![CDATA[<h2 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure>
<p>输出结果为:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>只要对同步和异步的区别、变量块级作用域、闭包等关键知识理解到位，得出正确答案就不难，但这道题远没有这么简单，来看面试官的继续追问。</p>
<a id="more"></a>
<h2 id="追问1"><a href="#追问1" class="headerlink" title="追问1"></a>追问1</h2><p>如果我们约定，用箭头（-&gt;）表示其前后的两次输出之间有1秒的时间间隔，而逗号（,）表示其前后的两次输出之间的时间间隔可以忽略，代码实际运行的结果该如何描述？</p>
<ul>
<li>A: 5-&gt;5-&gt;5-&gt;5-&gt;5-&gt;5</li>
<li>B: 5-&gt;5,5,5,5,5</li>
</ul>
<p>选A还是选B呢，这就要求面试者对定时器的工作机制非常熟悉，在循环执行过程中，几乎同时设置了 5 个定时器，一般情况下，这些定时器都会在 1 秒之后同时触发，而循环完的输出是立即执行的，显而易见，正确的描述是 B 。</p>
<h2 id="追问2"><a href="#追问2" class="headerlink" title="追问2"></a>追问2</h2><p>如果期望代码的输出变成：5-&gt;0,1,2,3,4，该怎么改造代码？熟悉闭包的同学很快能给出下面的解决办法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123; </span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure>
<p>巧妙的利用 IIFE（Immediately Invoked Function Expression：声明即执行的函数表达式）来解决闭包造成的问题。但这对于初学者来说可能不太好懂，有没有更直观的做法？当然有，我们只需要对循环体稍做手脚，让负责输出的那段代码能拿到每次循环的 i 值即可。该怎么做呢？利用 JS 中基本类型（Primitive Type）的参数传递是按值传递（Pass by Value）的特征，不难改造出下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> output = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    output(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure>
<h2 id="追问3"><a href="#追问3" class="headerlink" title="追问3"></a>追问3</h2><p>还是最初的那道题，如果将var改成let，会发生什么？</p>
<p>let是ES6块级作用域中的概念，用let代替var后，会发现代码在实际运行中报错，这是因为最后那个输出使用的 i 在其所在的作用域中并不存在，i 只存在于for循环内部。</p>
<h2 id="追问4"><a href="#追问4" class="headerlink" title="追问4"></a>追问4</h2><p>如果期望代码的输出变成 0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5，并且要求原有的代码块中的循环和两处console.log不变，该怎么改造代码？新的需求可以精确的描述为：代码执行时，立即输出 0，之后每隔 1 秒依次输出 1,2,3,4，循环结束后在大概第 5 秒的时候输出 5（这里使用大概是为了避免钻牛角尖的同学陷进去，因为 JS 中的定时器触发时机有可能是不确定的）。</p>
<p>看到这里，有些同学会给出下面的可行解：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j);</span><br><span class="line">        &#125;, <span class="number">1000</span> * j));  <span class="comment">// 这里修改 0~4 的定时器时间</span></span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 这里增加定时器，超时设置为 5 秒</span></span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;, <span class="number">1000</span> * i);</span><br></pre></td></tr></table></figure>
<p>不得不承认，这种做法虽然粗暴有效，但是不算是能额外加分的方案。如果把这次的需求抽象为：在系列异步操作完成（每次循环都产生了 1 个异步操作）之后，再做其他的事情，代码该怎么组织？聪明的你是不是想起了什么？对，就是 Promise，来看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;   <span class="comment">// 这里 i 的声明不能改成 let，如果要改该怎么做？</span></span><br><span class="line">    (<span class="function">(<span class="params">j</span>) =&gt;</span> &#123;</span><br><span class="line">        tasks.push(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(j);</span><br><span class="line">                resolve();  <span class="comment">// 这里一定要 resolve，否则代码不会按预期 work</span></span><br><span class="line">            &#125;, <span class="number">1000</span> * j);   <span class="comment">// 定时器的超时时间逐步增加</span></span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);   </span><br></pre></td></tr></table></figure>
<p>当然，上面的代码还能进一步简化，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []; <span class="comment">// 这里存放异步操作的 Promise</span></span><br><span class="line"><span class="keyword">const</span> output = <span class="function">(<span class="params">i</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, <span class="number">1000</span> * i);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 生成全部的异步操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    tasks.push(output(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步操作完成之后，输出最后的 i</span></span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样看是不是逻辑清楚多了，使用 Promise 处理异步代码比回调机制让代码可读性更高，但是使用 Promise 的问题也很明显，即如果没有处理 Promise 的 reject，会导致错误被丢进黑洞，这显然是我们不愿看到的。</p>
<h2 id="追问5"><a href="#追问5" class="headerlink" title="追问5"></a>追问5</h2><p>既然Promise已经被拿下，能否使用 ES7 中的 async/await 特性来让这段代码变的更简洁？答案是肯定的，来看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟其他语言中的 sleep，实际上可以是任何异步操作</span></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">timeountMS</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, timeountMS);</span><br><span class="line">&#125;);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;  <span class="comment">// 声明即执行的 async 函数表达式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>好了，到这里，这道经典面试题我们已经剖析完毕了，相信读到这里，你收获的不仅仅是用 JS 精确控制代码输出的各种技巧，更是对于前端工程师的成长期许：扎实的语言基础、与时俱进的能力、强大的技术自驱力。生命不息，学习不止，让我们用知识不断充实丰富自己，如果你有任何的问题，也欢迎评论区留言，你的支持是我前进的最大动力！</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/2020/09/23/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。而二叉搜索树（BST）是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值。</p>
<a id="more"></a>
<h2 id="BinarySearchTree类的模拟实现"><a href="#BinarySearchTree类的模拟实现" class="headerlink" title="BinarySearchTree类的模拟实现"></a>BinarySearchTree类的模拟实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建节点Node类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(key) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Compare = &#123;</span><br><span class="line">    LESS_THAN: <span class="number">-1</span>,</span><br><span class="line">    BIGGER_THAN: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultCompare</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(compareFn = defaultCompare) &#123;</span><br><span class="line">        <span class="built_in">this</span>.compareFn = compareFn;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 向二叉搜索树中插入一个值 - 辅助方法</span></span><br><span class="line">    insertNode(node, key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> Node(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.insertNode(node.left, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> Node(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.insertNode(node.right, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向二叉搜索树中插入一个值</span></span><br><span class="line">    insert(key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root = <span class="keyword">new</span> Node(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.insertNode(<span class="built_in">this</span>.root, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中序遍历 - 辅助方法</span></span><br><span class="line">    inOrderTraverseNode(node, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.inOrderTraverseNode(node.left, callback);</span><br><span class="line">            callback(node.key);</span><br><span class="line">            <span class="built_in">this</span>.inOrderTraverseNode(node.right, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    inOrderTraverse(callback) &#123;</span><br><span class="line">        <span class="built_in">this</span>.inOrderTraverseNode(<span class="built_in">this</span>.root, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先序遍历 - 辅助方法</span></span><br><span class="line">    preOrderTraverseNode(node, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            callback(node.key);</span><br><span class="line">            <span class="built_in">this</span>.preOrderTraverseNode(node.left, callback);</span><br><span class="line">            <span class="built_in">this</span>.preOrderTraverseNode(node.right, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先序遍历</span></span><br><span class="line">    preOrderTraverse(callback) &#123;</span><br><span class="line">        <span class="built_in">this</span>.preOrderTraverseNode(<span class="built_in">this</span>.root, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序遍历 - 辅助方法</span></span><br><span class="line">    postOrderTraverseNode(node, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.postOrderTraverseNode(node.left, callback);</span><br><span class="line">            <span class="built_in">this</span>.postOrderTraverseNode(node.right, callback);</span><br><span class="line">            callback(node.key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    postOrderTraverse(callback) &#123;</span><br><span class="line">        <span class="built_in">this</span>.postOrderTraverseNode(<span class="built_in">this</span>.root, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搜索最小值 - 辅助方法</span></span><br><span class="line">    minNode(node) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = node;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 搜索最小值</span></span><br><span class="line">    min() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.minNode(<span class="built_in">this</span>.root);</span><br><span class="line">    &#125;          </span><br><span class="line">    <span class="comment">// 搜索最大值 - 辅助方法</span></span><br><span class="line">    maxNode(node) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = node;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 搜索最大值</span></span><br><span class="line">    max() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.maxNode(<span class="built_in">this</span>.root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搜索特定的值 - 辅助方法</span></span><br><span class="line">    searchNode(node, key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.searchNode(node.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.searchNode(node.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 搜索特定的值</span></span><br><span class="line">    search(key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.searchNode(<span class="built_in">this</span>.root, key);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 移除一个节点 - 辅助方法</span></span><br><span class="line">    removeNode(node, key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">            node.left = <span class="built_in">this</span>.removeNode(node.left, key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">            node.right = <span class="built_in">this</span>.removeNode(node.right, key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第一种情况：移除一个叶节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                node = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第二种情况：移除有一个左侧或右侧子节点的节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第三种情况：移除有两个子节点的节点</span></span><br><span class="line">            <span class="keyword">const</span> aux = <span class="built_in">this</span>.minNode(node.right);</span><br><span class="line">            node.key = aux.key;</span><br><span class="line">            node.right = <span class="built_in">this</span>.removeNode(node.right, aux.key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 移除一个节点</span></span><br><span class="line">    remove(key) &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="built_in">this</span>.removeNode(<span class="built_in">this</span>.root, key);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不再演示BinarySearchTree类中方法的使用了，有兴趣的可以自己做个demo测试一下，如果有任何的问题，欢迎评论区留言。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化</title>
    <url>/2020/09/18/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="前端性能优化七大手段"><a href="#前端性能优化七大手段" class="headerlink" title="前端性能优化七大手段"></a>前端性能优化七大手段</h2><ul>
<li><p>减少请求数量</p>
</li>
<li><p>减小资源大小</p>
</li>
<li><p>优化网络连接</p>
</li>
<li><p>优化资源加载</p>
</li>
<li><p>减少重绘回流</p>
</li>
<li><p>使用性能更好的API</p>
</li>
<li><p>webpack优化</p>
<a id="more"></a>
<h2 id="减小请求资源大小或数量"><a href="#减小请求资源大小或数量" class="headerlink" title="减小请求资源大小或数量"></a>减小请求资源大小或数量</h2></li>
<li><p>尽量和并压缩css和js文件，例如将css文件和并为一个，将js合并为一个。<br>原因：主要是为了减少http请求次数以及减少请求资源的大小。<br>打包工具：webpack、gulp、grunt……</p>
</li>
<li><p>尽量使用字体图标或者SVG图标来代替传统png图，因为字体图标或者SVG图标是矢量图，是代码编写出来的，放大缩小不会变形，而且渲染速度快。</p>
</li>
<li><p>采用图片的懒加载（延迟加载）。<br>目的：为了减少页面第一次加载过程中http的请求次数。<br>具体步骤：<br>1、页面开始加载时不去发送http请求，而是放置一张占位图;<br>2、当页面加载完时，并且图片在可视区域再去请求加载图片信息.</p>
</li>
<li><p>能用css做的效果，不要用js做，能用原生js做的，不要轻易去使用第三方插件，避免引入第三方大量的库，而自己却只是用里面的一个小功能。</p>
</li>
<li><p>使用雪碧图（精灵图），把所有相对较小的资源图片，绘制在一张大图上，只需要将大图下载下来，然后利用，使用图片定位来将小图展现在页面中（background-position: 百分比, 数值）。</p>
</li>
<li><p>减少对cookie的使用，最主要的就是要减少本地cookie存储内容的大小，因为客户端操作cookie的时候，这些信息总是在客户端和服务端传递，如果设置不当，每次发送一个请求都会携带cookie。</p>
</li>
<li><p>前端与后端进行数据交互时，对于多项数据尽可能基于json格式来进行传送，相对于使用xml来说传输更有优势，因为json格式数据处理方便，资源偏小。</p>
</li>
<li><p>前端与后端协商，合理使用keep-alive。</p>
</li>
<li><p>前端与服务器协商，使用响应资源的压缩。</p>
</li>
<li><p>避免使用iframe，因为使用iframe不仅不好管控样式，而且相当于在本页面又嵌套其他页面，还要加载这些嵌套页面的资源，使得性能消耗变大。</p>
</li>
<li><p>在基于ajax的get请求进行数据交互的时候，根据需求可以让其产生缓存（注意：这个缓存不是我们常看到的304状态码，去浏览器本地取数据），这样在下一次从相同地址获取是数据时，取得就是上一次缓存的数据（注意：很少使用，一般都会清空，根据需求来做）。</p>
</li>
</ul>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><ul>
<li>在js中尽量减少闭包的使用，因为使用闭包后，闭包所在的上下文不会被释放。</li>
<li>减少对DOM操作，主要是减少DOM的重绘与回流（重排）。<br>关于重排（回流）的分离读写：如果需要设置多个样式，把设置样式全放在一起设置，不要一条一条的设置，使用文档碎片或者字符串拼接做数据绑定（DOM的动态创建）。</li>
<li>在js中避免嵌套循环和“死循环”，因为一旦遇到死循环，浏览器就会直接卡掉。</li>
<li>减少css表达式的使用。</li>
<li>减少元素标签作为最后一个选择对象，因为css选择器解析规则是从右往左解析的。</li>
<li>尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小），注意：图层不要过多设置，否则不但效果没有达到反而更差了。</li>
<li>在js封装过程中，尽量做到低耦合高内聚，减少页面的冗余代码。</li>
<li>css中设置定位后，最好使用z-index改变盒子的层级，让盒子不在相同的平面上。</li>
<li>css导入的时候尽量减少@import导入式，因为@import是同步操作，只有把对应的样式导入后，才会继续向下执行其他的代码，而link是异步的操作。</li>
<li>使用window.requestAnimationFrame(js的帧动画)代替传统的定时器动画，如果想使用每隔一段时间执行动画，应该避免使用setInterval，尽量使用setTimeout代替setInterval定时器，因为setInterval定时器存在弊端：可能造成两个动画间隔时间缩短。</li>
<li>尽量减少使用递归，避免死递归，如果一定要使用递归建议使用尾递归。</li>
<li>基于script标签引用js文件时，可以使用defer或者async来异步加载。</li>
<li>在事件绑定中，尽可能使用事件委托，减少循环给DOM元素绑定事件处理函数。</li>
<li>减少Flash的使用。</li>
</ul>
<h2 id="存储优化"><a href="#存储优化" class="headerlink" title="存储优化"></a>存储优化</h2><ul>
<li>结合后端，利用浏览器的缓存技术，做一些缓存（让后端返回304，告诉浏览器去本地拉取数据，可以让一些不太会改变的静态资源做缓存，比如一些图片，js文件，css文件</li>
<li>利用h5的新特性（localStorage、sessionStorage）做一些简单数据的存储，避免向后台请求数据或者说在离线状态下做一些数据展示。</li>
</ul>
<h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><ul>
<li>采用异步编程和延迟分批加载获取页面中的数据，使用异步加载是数据主要是为了避免浏览器失去响应，如果你使用同步，加载数据很大并且很慢，那么页面会在一段时间内处于阻塞状态。<br>目的：为了解决请求数据不耽搁渲染，提高页面的渲染效率。<br>解决方法：动态绑定数据区域，先隐藏，等数据返回并且绑定后再让其显示，延迟分批加载类似图片懒加载，以减少第一次页面加载时候的http请求次数。</li>
<li>如果页面有出现音视频标签，可以不让页面加载的时候去加载这些资源（将音视频的preload设置为none即可），否则第一次加载会很慢，在页面加载完成后，并且音视频要播放的时候再去加载音视频资源。</li>
</ul>
<p>如果你有任何的问题，欢迎评论区留言，你的支持是我前进的最大动力。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>字典</title>
    <url>/2020/09/21/%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>我们已经知道，集合表示一组互不相同的元素（不重复的元素）。在字典中，存储的是[键, 值]对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值, 值]的形式存储元素，字典则以[键, 值]的形式来存储元素。字典也称作<strong>映射</strong>、<strong>符号表</strong>或<strong>关联数组</strong>。</p>
<a id="more"></a>
<h2 id="Dictionary类的模拟实现"><a href="#Dictionary类的模拟实现" class="headerlink" title="Dictionary类的模拟实现"></a>Dictionary类的模拟实现</h2><p>与Set类类似，ECMAScript 2015同样包含了一个Map类的实现，即我们所说的字典，下面我们以ECMAScript 2015中Map类的实现为基础，模拟实现自己的Dictionary类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultToString</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NULL&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UNDEFINED&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">&quot;string&quot;</span> || item <span class="keyword">instanceof</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;item&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValuePair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(key, value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`[#<span class="subst">$&#123;<span class="built_in">this</span>.key&#125;</span>: <span class="subst">$&#123;<span class="built_in">this</span>.value&#125;</span>&#125;]`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dictionary</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(toStrFn = defaultToString) &#123;</span><br><span class="line">        <span class="built_in">this</span>.toStrFn = toStrFn;</span><br><span class="line">        <span class="built_in">this</span>.table = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测一个键是否存在于字典中</span></span><br><span class="line">    hasKey(key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.table[<span class="built_in">this</span>.toStrFn(key)] != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在字典和ValuePair类中设置键和值</span></span><br><span class="line">    set(key, value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> tableKey = <span class="built_in">this</span>.toStrFn(key);</span><br><span class="line">            <span class="built_in">this</span>.table[tableKey] = <span class="keyword">new</span> ValuePair(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从字典中移除一个值</span></span><br><span class="line">    remove(key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.hasKey(key)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.table[<span class="built_in">this</span>.toStrFn(key)];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从字典中检索一个值</span></span><br><span class="line">    get(key) &#123;</span><br><span class="line">        <span class="keyword">const</span> valuePair = <span class="built_in">this</span>.table[<span class="built_in">this</span>.toStrFn(key)];</span><br><span class="line">        <span class="keyword">return</span> valuePair == <span class="literal">null</span> ? <span class="literal">undefined</span> : valuePair.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将字典中所有[键, 值]对返回</span></span><br><span class="line">    keyValues() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.values(<span class="built_in">this</span>.table);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将字典所包含的所有键名以数组形式返回</span></span><br><span class="line">    keys() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.keyValues().map(<span class="function"><span class="params">valuePair</span> =&gt;</span> valuePair.key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将字典所包含的所有数值以数组形式返回</span></span><br><span class="line">    values() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.keyValues().map(<span class="function"><span class="params">valuePair</span> =&gt;</span> valuePair.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代字典中所有的键值对</span></span><br><span class="line">    forEach(callbackFn) &#123;</span><br><span class="line">        <span class="keyword">const</span> valuePairs = <span class="built_in">this</span>.keyValues();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; valuePairs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> result = callbackFn(valuePairs[i].key, valuePairs[i].value);</span><br><span class="line">            <span class="keyword">if</span> (result === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回字典所包含值的数量</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.table).length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检验字典是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size() === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空字典</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="built_in">this</span>.table = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将字典转换为字符串</span></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> valuePairs = <span class="built_in">this</span>.keyValues();</span><br><span class="line">        <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;valuePairs[<span class="number">0</span>].toString()&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; valuePairs.length; i++) &#123;</span><br><span class="line">            objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>, <span class="subst">$&#123;valuePairs[i].toString()&#125;</span>`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不再演示Dictionary类中方法的使用了，有兴趣的可以自己做个demo测试一下，如果有任何的问题，欢迎评论区留言。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>双向数据绑定</title>
    <url>/2020/09/27/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="Vue中的双向数据绑定"><a href="#Vue中的双向数据绑定" class="headerlink" title="Vue中的双向数据绑定"></a>Vue中的双向数据绑定</h2><p> Vue 最核心的功能有两个，一是响应式的数据绑定系统，二是组件化。来看下面的代码：<br> <a id="more"></a><br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;text&quot;</span>&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123;text&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;node_modules/vue/dist/vue.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                text: <span class="string">&quot;hello, world!&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br> 在浏览器中运行可以看到，随文本框输入文字的变化，span 中会同步显示相同的文字内容.这就是 Vue 中 model =&gt; view 以及 view =&gt; model 的双向数据绑定，如下图所示：<br><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/data.png" alt="alt"></p>
<h2 id="实现简单的双向数据绑定"><a href="#实现简单的双向数据绑定" class="headerlink" title="实现简单的双向数据绑定"></a>实现简单的双向数据绑定</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;input&quot;</span>&gt;</span><br><span class="line">    &lt;span id=<span class="string">&quot;span&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">        <span class="keyword">let</span> inputEle = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> spanEle = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">        <span class="comment">// 数据劫持</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;text&#x27;</span>, &#123;</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            get() &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;获取数据了&#x27;</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            set(newVal) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;数据更新了&#x27;</span>);</span><br><span class="line">                inputEle.value = newVal;</span><br><span class="line">                spanEle.innerHTML = newVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 输入监听</span></span><br><span class="line">        input.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">            obj.text = e.target.value;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>在浏览器中运行此代码可以看到：随文本框输入文字的变化，span 中会同步显示相同的文字内容；在js或控制台显式的修改 obj.text 的值，视图会相应更新。这样就实现了 model =&gt; view 以及 view =&gt; model 的双向数据绑定，如下图所示：<br><img src="https://raw.githubusercontent.com/cxs2018/blog/master/img/data2.png" alt="alt"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>字节面试题1</title>
    <url>/2020/09/16/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E9%A2%981/</url>
    <content><![CDATA[<h2 id="用css2和css3分别写一下垂直居中和水平居中"><a href="#用css2和css3分别写一下垂直居中和水平居中" class="headerlink" title="用css2和css3分别写一下垂直居中和水平居中"></a>用css2和css3分别写一下垂直居中和水平居中</h2><p>css3新增了一些属性，像flex，这是css3中很重要的改变，所以除了flex以外的垂直水平居中的技巧都是属于css2的。</p>
<ul>
<li>css2的水平居中技巧<br>将元素display为行内元素，再text-align:center;即可<br>或者<br>将块级元素定义一个宽度，再margin: 0 auto;即可</li>
<li>css3的水平居中技巧<br>将元素display设为flex，再通过justify-content: center; 实现居中。</li>
<li>css2的垂直居中技巧<br>单行内容的垂直居中可以通过设置相同height值和line-height值来实现。<br>多行内容的垂直居中且高度可变可以通过设置上下相同的padding值来实现。<br>行级盒子：小图标和标题对齐设置vertical-align: middle。<br>绝对定位：top:50%; left:50%;的方法，需要已知块级的宽高</li>
<li>css3的垂直居中技巧<br>将元素display设为flex，再通过align-items:center;来实现。<a id="more"></a>
<h2 id="计算机网络的七层"><a href="#计算机网络的七层" class="headerlink" title="计算机网络的七层"></a>计算机网络的七层</h2>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层<br><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9128db37af494d42874fed85870f57ac~tplv-k3u1fbpfcp-zoom-1.image" alt="alt"><h2 id="TCP和UDP的区别是什么"><a href="#TCP和UDP的区别是什么" class="headerlink" title="TCP和UDP的区别是什么"></a>TCP和UDP的区别是什么</h2></li>
<li>TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)</li>
<li>UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快</li>
<li>TCP和UDP协议的一些应用例子：TCP一般用于文件传输（FTP HTTP 对数据准确性要求高，速度可以相对慢），发送或接收邮件（POP IMAP SMTP 对数据准确性要求高，非紧急应用），远程登录（TELNET SSH 对数据准确性有一定要求，有连接的概念）等等；UDP一般用于即时通信（QQ聊天 对数据准确性和丢包要求比较低，但速度必须快），在线视频（RTSP 速度一定要快，保证视频连续，但是偶尔花了一个图像帧，人们还是能接受的），网络语音电话（VoIP 语音数据包一般比较小，需要高速发送，偶尔断音或串音也没有问题）等等。<h2 id="TCP和UDP属于计算机网络的哪一层"><a href="#TCP和UDP属于计算机网络的哪一层" class="headerlink" title="TCP和UDP属于计算机网络的哪一层"></a>TCP和UDP属于计算机网络的哪一层</h2></li>
<li>网络层协议：IP协议、ICMP协议、ARP协议、RARP协议</li>
<li>传输层协议：TCP协议、UDP协议</li>
<li>应用层协议：FTP、Telnet、SMTP、HTTP、RIP、NFS、DNS<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2>HTTPS即加密的HTTP，HTTPS并不是一个新协议，而是HTTP+SSL（TLS）。原本HTTP先和TCP（假定传输层是TCP协议）直接通信，而加了SSL后，就变成HTTP先和SSL通信，再由SSL和TCP通信，相当于SSL被嵌在了HTTP和TCP之间。<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2></li>
<li>2XX系列：代表请求已成功被服务器接收、理解、并接受。</li>
<li>200状态码：表示请求已成功，请求所希望的响应头或数据体将随此响应返回</li>
<li>201状态码：表示请求成功并且服务器创建了新的资源，且其 URI 已经随Location 头信息返回。</li>
<li>3XX系列：代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。</li>
<li>301状态码：被请求的资源已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</li>
<li>302状态码：请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求。</li>
<li>304状态码：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</li>
<li>4XX系列：表示请求错误。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。</li>
<li>401状态码：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li>
<li>403状态码：服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。</li>
<li>404状态码：请求失败，请求所希望得到的资源未被在服务器上发现。</li>
<li>5xx系列：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。</li>
<li>500状态码：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。</li>
<li>503状态码：由于临时的服务器维护或者过载，服务器当前无法处理请求。<h2 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h2>闭包就是能够读取其他函数内部变量的函数。闭包的用途：可以读取函数内部的变量，并且让这些变量的值始终保持在内存中。<h2 id="NaN是什么，用typeof会输出什么"><a href="#NaN是什么，用typeof会输出什么" class="headerlink" title="NaN是什么，用typeof会输出什么"></a>NaN是什么，用typeof会输出什么</h2>Not a Number，Number。<h2 id="js的隐性转换和显性转换"><a href="#js的隐性转换和显性转换" class="headerlink" title="js的隐性转换和显性转换"></a>js的隐性转换和显性转换</h2></li>
<li>隐性转换： 1 + ‘1’ = ‘11’， 1 - ‘1’ = 0</li>
<li>显性转换：<br>Number(“24 cccc”);//结果：NaN<br>ParseInt(“24 cccc”);//结果：24<blockquote>
<p>注：Number的显性转换比较严格，若无法强转则直接报错</p>
</blockquote>
</li>
<li>1 + -‘1’ + 1 等于 0 ，’1’前面的负号把其数字化，变为-1，则后值为1</li>
<li>‘A’ - ‘B’ 等于 NaN<h2 id="跨域问题如何解决"><a href="#跨域问题如何解决" class="headerlink" title="跨域问题如何解决"></a>跨域问题如何解决</h2>同源策略：浏览器安全策略，同协议、ip、端口的脚本才会执行。只要协议、域名、端口有任何一个不同，都被当作是不同的域,js跨域是指通过js在不同的域之间进行数据传输或通信。</li>
<li>通过jsonp跨域：jsonp在页面上引入不同域上的js脚本文件实现请求不同域上的数据<br>(1) 通过script标签引入一个js文件<br>(2) js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入<blockquote>
<p>注：需要服务器端的页面进行相应的配合</p>
</blockquote>
</li>
<li>通过修改document.domain来跨子域</li>
<li>使用window.name来进行跨域: window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。<h2 id="babel是什么"><a href="#babel是什么" class="headerlink" title="babel是什么"></a>babel是什么</h2>可以实现将ES6编译为ES5代码。<h2 id="用js实现判断一个变量是否为整数的函数"><a href="#用js实现判断一个变量是否为整数的函数" class="headerlink" title="用js实现判断一个变量是否为整数的函数"></a>用js实现判断一个变量是否为整数的函数</h2>实现思路：先判断该变量是否为Number类型，以此来缩小范围，再判断该变量除以1后是否与原值全等，若全等则返回true，若不全等则返回false。<h2 id="进程和线程是什么"><a href="#进程和线程是什么" class="headerlink" title="进程和线程是什么"></a>进程和线程是什么</h2></li>
<li>线程是最小的执行单元，是操作系统能够进行运算调度的最小单位，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</li>
<li>进程指计算机中已运行的程序。<h2 id="死锁是什么"><a href="#死锁是什么" class="headerlink" title="死锁是什么"></a>死锁是什么</h2>当两个以上的运算单元，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，就称为死锁。<h2 id="Left-Join、Right-Join、Inner-Join-指的是什么"><a href="#Left-Join、Right-Join、Inner-Join-指的是什么" class="headerlink" title="Left Join、Right Join、Inner Join 指的是什么"></a>Left Join、Right Join、Inner Join 指的是什么</h2></li>
<li>Left Join关键字会从左表那里返回所有的行，即使在右表中没有匹配的行</li>
<li>Right Join关键字会右表那里返回所有的行，即使在左表中没有匹配的行</li>
<li>在表中存在至少一个匹配时，Inner Join关键字返回行<h2 id="js快速排序"><a href="#js快速排序" class="headerlink" title="js快速排序"></a>js快速排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">  if(arr.length&lt;&#x3D;1) &#123;</span><br><span class="line">  	return arr;</span><br><span class="line">  &#125;</span><br><span class="line">  var s &#x3D; Math.floor(arr.length&#x2F;2);</span><br><span class="line">  var temp &#x3D; arr.splice(s,1);</span><br><span class="line">  var left&#x3D;[];</span><br><span class="line">  var right&#x3D;[];</span><br><span class="line">  for(var i&#x3D;0;i&lt;arr.length;i++) &#123;</span><br><span class="line">    if(arr[i]&lt;temp) &#123;</span><br><span class="line">      left.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    if(arr[i]&gt;&#x3D;temp) &#123;</span><br><span class="line">      right.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return quickSort(left).concat(temp,quickSort(right));  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>尾调用和尾递归</title>
    <url>/2020/09/20/%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C%E5%B0%BE%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>尾调用是函数式编程中一个很重要的概念，当一个函数执行时的最后一个步骤是返回另一个函数的调用，这就叫做尾调用。函数调用可以是下面方式中的任意一种：</p>
<ul>
<li>函数调用：func(···)</li>
<li>方法调用：obj.method(···)</li>
<li>call调用：func.call(···)</li>
<li>apply调用：func.apply(···)</li>
</ul>
<p>并且只有下列表达式会包含尾调用：</p>
<ul>
<li>条件操作符：? :</li>
<li>逻辑或：||</li>
<li>逻辑与：&amp;&amp;</li>
<li>逗号：,<a id="more"></a>
来看下面的例子：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="params">x</span> =&gt;</span> x ? f() : g();</span><br></pre></td></tr></table></figure>
f() 和 g() 都在尾部。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function">() =&gt;</span> f() || g();</span><br></pre></td></tr></table></figure>
g() 有可能是尾调用，f() 不是，因为上述写法和下面的写法等效：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fResult = f(); <span class="comment">// not a tail call</span></span><br><span class="line">    <span class="keyword">if</span> (fResult) &#123;</span><br><span class="line">        <span class="keyword">return</span> fResult;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> g(); <span class="comment">// tail call</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
只有当 f() 的结果为false的时候，g() 才是尾调用。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function">() =&gt;</span> f() &amp;&amp; g();</span><br></pre></td></tr></table></figure>
g() 有可能是尾调用，f() 不是，因为上述写法和下面的写法等效：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fResult = f(); <span class="comment">// not a tail call</span></span><br><span class="line">    <span class="keyword">if</span> (fResult) &#123;</span><br><span class="line">        <span class="keyword">return</span> g(); <span class="comment">// tail call</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
只有当 f() 的结果为true的时候，g() 才是尾调用。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function">() =&gt;</span> (f() , g());</span><br></pre></td></tr></table></figure>
g() 是尾调用，因为上述写法和下面的写法等效：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> g();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
函数在调用的时候会在调用栈（call stack）中存有记录，每一条记录叫做一个调用帧（call frame），每调用一个函数，就向栈中push一条记录，函数执行结束后依次向外弹出，直到清空调用栈，参考下图：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">111</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123; foo(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span> (<span class="params"></span>) </span>&#123; bar(); &#125;</span><br><span class="line">baz();</span><br></pre></td></tr></table></figure>
<img src="https://s1.ax1x.com/2020/09/20/wTuuh6.png" alt="alt"><br>造成这种结果是因为每个函数在调用另一个函数的时候，并没有 return 该调用，所以JS引擎会认为你还没有执行完，会保留你的调用帧。</li>
</ul>
<p>baz() 里面调用了 bar() 函数，并没有 return 该调用，所以在调用栈中保持自己的调用帧，同时 bar() 函数的调用帧在调用栈中生成，同理，bar() 函数又调用了 foo() 函数，最后执行到 foo() 函数的时候，没有再调用其他函数，这里没有显示声明 return，所以这里默认 return undefined。</p>
<p>foo() 执行完了，销毁调用栈中自己的记录，依次销毁 bar() 和 baz() 的调用帧，最后完成整个流程。</p>
<p>如果对上面的例子做如下修改：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">111</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> foo(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> bar(); &#125;</span><br><span class="line">baz();</span><br></pre></td></tr></table></figure>
<p>这里要注意：<strong>尾调用优化只在严格模式下有效</strong>。</p>
<p>在非严格模式下，大多数引擎会包含下面两个属性，以便开发者检查调用栈：</p>
<ul>
<li>func.arguments: 表示对 func最近一次调用所包含的参数。</li>
<li>func.caller: 引用对 func最近一次调用的那个函数。</li>
</ul>
<p>在尾调用优化中，这些属性不再有用，因为相关的信息可能以及被移除了。因此，严格模式(strict mode)禁止这些属性，并且尾调用优化只在严格模式下有效。</p>
<p>如果尾调用优化生效，流程图就会变成这样：<br><img src="https://s1.ax1x.com/2020/09/20/wTuntx.png" alt="alt"><br>我们可以很清楚的看到，尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，只要直接用内层函数的调用记录取代外层函数的调用记录就可以了，调用栈中始终只保持了一条调用帧。</p>
<p>这就叫做<strong>尾调用优化</strong>，如果所有的函数都是尾调用的话，那么在调用栈中的调用帧始终只有一条，这样会节省很大一部分的内存，这也是尾调用优化的意义。</p>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>讲尾递归之前先来看看什么是递归，当一个函数调用自身，就叫做递归，就像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个操作就叫做递归，但是注意了，这里没有结束条件，是死递归，所以会报栈溢出错误的，写代码时千万注意给递归添加结束条件。</p>
<p>那么什么是尾递归？前面我们知道了尾调用的概念，当一个函数尾调用自身，就叫做尾递归，就像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么尾递归相比递归而言，有哪些不同呢？ 我们通过下面这个求阶乘的例子来看一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> num * factorial(num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>);            <span class="comment">// 120</span></span><br><span class="line">factorial(<span class="number">10</span>);           <span class="comment">// 3628800</span></span><br><span class="line">factorial(<span class="number">500000</span>);       <span class="comment">// Uncaught RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>
<p>上面是使用递归来计算阶乘的例子，操作系统为JS引擎调用栈分配的内存是有大小限制的，如果计算的数字足够大，超出了内存最大范围，就会出现栈溢出错误。这里500000并不是临界值，只是我用了一个足够造成栈溢出的数。</p>
<p>如果用尾递归来计算阶乘呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num, total</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">    <span class="keyword">return</span> factorial(num - <span class="number">1</span>, num * total);</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>);                <span class="comment">// 120</span></span><br><span class="line">factorial(<span class="number">10</span>, <span class="number">1</span>);               <span class="comment">// 3628800</span></span><br><span class="line">factorial(<span class="number">500000</span>, <span class="number">1</span>);           <span class="comment">// 分情况</span></span><br></pre></td></tr></table></figure>
<p>注意，虽然说这里启用了严格模式，但是经测试，在 Chrome 和 Firefox 下，还是会报栈溢出错误，并没有进行尾调用优化，Safari 浏览器进行了尾调用优化，factorial(500000, 1) 结果为 Infinity ，因为结果超出了JS可表示的数字范围，如果在node v6版本下执行，需要加 –harmony_tailcalls 参数（node–harmony_tailcalls test.js），但是node最新版本已经移除了 –harmony_tailcalls 功能。</p>
<p>通过尾递归，我们把复杂度从 O(n) 降低到了 O(1) ，如果数据足够大的话，会节省很多的计算时间。由此可见，尾调用优化对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。</p>
<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。<br>要做到这一点，需要把函数内部所有用到的中间变量改写为函数的参数，就像上面的 factorial() 函数改写一样。这样做的缺点就是语义不明显，要计算阶乘的函数，为什么还要另外传入一个参数叫total？<br>解决这个问题的办法有两个：</p>
<ul>
<li>ES6参数默认值<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">    <span class="keyword">return</span> factorial(num - <span class="number">1</span>, num * total);</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>);                <span class="comment">// 120</span></span><br><span class="line">factorial(<span class="number">10</span>);               <span class="comment">// 3628800</span></span><br></pre></td></tr></table></figure></li>
<li>用一个符合语义的函数去调用改写后的尾递归函数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span> (<span class="params">num, total</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">    <span class="keyword">return</span> tailFactorial(num - <span class="number">1</span>, num * total);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tailFactorial(num, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">factorial(<span class="number">5</span>);                <span class="comment">// 120</span></span><br><span class="line">factorial(<span class="number">10</span>);               <span class="comment">// 3628800</span></span><br></pre></td></tr></table></figure>
看完了求阶乘的例子，再来看一下经典的爬楼梯问题：</li>
</ul>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶100层呢？</p>
<p>一般递归实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(n - <span class="number">1</span>) + fn(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尾递归优化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n, n1 = <span class="number">1</span>, n2 = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(n - <span class="number">1</span>, n2, n1 + n2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在这里我们主要讨论了尾调用和尾递归。要注意的是，经过测试，Chrome 和 Firefox 并没有对尾调用进行优化，Safari 对尾调用进行了优化，Node 高版本也已经去除了通过 –harmony_tailcalls 参数启用尾调用优化，这些问题在实际使用过程中要注意，如果你有任何的问题，也欢迎评论区留言讨论。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕代码之call、apply和bind</title>
    <url>/2020/09/17/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E4%B9%8Bcall%E3%80%81apply%E5%92%8Cbind/</url>
    <content><![CDATA[<h2 id="三兄弟的作用"><a href="#三兄弟的作用" class="headerlink" title="三兄弟的作用"></a>三兄弟的作用</h2><p>call、apply和bind三个方法都是为了改变函数运行时上下文(即this指向)而存在的，来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> language = &#123;</span><br><span class="line">    name: <span class="string">&quot;java&quot;</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is the best language in the world!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> weber = &#123;</span><br><span class="line">    name: <span class="string">&quot;javascript&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//谁是世界上最好的语言？</span></span><br><span class="line">language.getName();</span><br><span class="line">language.getName.call(weber);</span><br><span class="line">language.getName.apply(weber);</span><br><span class="line">language.getName.bind(weber)();</span><br></pre></td></tr></table></figure>
<p>执行上面的代码，结果为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">java is the best language <span class="keyword">in</span> the world!</span><br><span class="line">javascript is the best language <span class="keyword">in</span> the world!</span><br><span class="line">javascript is the best language <span class="keyword">in</span> the world!</span><br><span class="line">javascript is the best language <span class="keyword">in</span> the world!</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="三兄弟的区别"><a href="#三兄弟的区别" class="headerlink" title="三兄弟的区别"></a>三兄弟的区别</h2><ul>
<li>call、apply和bind方法接收的第一个参数都是要绑定的this对象。</li>
<li>apply方法的第二个参数是一个参数数组，call和bind方法的第二个及之后的参数作为函数实参按顺序传入。</li>
<li>bind方法不会立即调用，call和apply方法都会立即调用。</li>
</ul>
<p>来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> developer = &#123;</span><br><span class="line">    getSkills: <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> weber = &#123;</span><br><span class="line">    skiller: [<span class="string">&quot;HTML&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line">developer.getSkills.call(weber, <span class="string">&quot;HTML5&quot;</span>, <span class="string">&quot;CSS3&quot;</span>, <span class="string">&quot;javascript&quot;</span>);</span><br><span class="line">developer.getSkills.apply(weber, [<span class="string">&quot;HTML5&quot;</span>, <span class="string">&quot;CSS3&quot;</span>, <span class="string">&quot;javascript&quot;</span>]);</span><br><span class="line">developer.getSkills.bind(weber)(<span class="string">&quot;HTML5&quot;</span>, <span class="string">&quot;CSS3&quot;</span>, <span class="string">&quot;javascript&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>执行上面的代码，结果为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTML5 CSS3 javascript</span><br><span class="line">HTML5 CSS3 javascript</span><br><span class="line">HTML5 CSS3 javascript</span><br></pre></td></tr></table></figure>
<h2 id="call方法的模拟实现"><a href="#call方法的模拟实现" class="headerlink" title="call方法的模拟实现"></a>call方法的模拟实现</h2><p>首先要理清思路：</p>
<ul>
<li>函数定义在哪里？call方法是可以被所有方法调用的，所以毫无疑问要定义在Function的原型上。</li>
<li>函数接收参数？绑定函数被调用时只传入第二个参数及之后的参数。</li>
<li>如何显式绑定this？如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。</li>
</ul>
<p>理清了思路，开撸：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123; <span class="comment">//验证当前被调用的是否是方法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;not function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> cxt = context || <span class="built_in">window</span>;</span><br><span class="line">    cxt.fn = <span class="built_in">this</span>; <span class="comment">// 将当前被调用的方法定义在cxt.fn上，为了能以对象调用的形式绑定this</span></span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>); <span class="comment">//获取实参</span></span><br><span class="line">    <span class="keyword">const</span> res = cxt.fn(...args); <span class="comment">//以对象调用的形式调用fn，此时this指向cxt，也就是传入的需要绑定的this指向</span></span><br><span class="line">    <span class="keyword">delete</span> cxt.fn; <span class="comment">//删除该方法，不然会对传入对象造成污染（添加该方法）</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="apply方法的模拟实现"><a href="#apply方法的模拟实现" class="headerlink" title="apply方法的模拟实现"></a>apply方法的模拟实现</h2><p>apply方法实现的思路与call方法基本相同，我们只需要对参数进行不同处理即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123; <span class="comment">//验证当前被调用的是否是方法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;not function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> cxt = context || <span class="built_in">window</span>;</span><br><span class="line">    cxt.fn = <span class="built_in">this</span>; <span class="comment">// 将当前被调用的方法定义在cxt.fn上，为了能以对象调用的形式绑定this</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">arguments</span>[<span class="number">1</span>] ? cxt.fn(...arguments[<span class="number">1</span>]) : cxt.fn(); <span class="comment">//以对象调用的形式调用fn，此时this指向cxt，也就是传入的需要绑定的this指向</span></span><br><span class="line">    <span class="keyword">delete</span> cxt.fn; <span class="comment">//删除该方法，不然会对传入对象造成污染（添加该方法）</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="bind方法的模拟实现"><a href="#bind方法的模拟实现" class="headerlink" title="bind方法的模拟实现"></a>bind方法的模拟实现</h2><p>首先要理清思路：</p>
<ul>
<li>函数定义在哪里？bind方法是可以被所有方法调用的，所以毫无疑问要定义在Function的原型上。</li>
<li>函数接收参数？bind方法返回一个绑定函数，最终调用需要传入函数实参和绑定函数的实参。</li>
<li>如何显式绑定this？如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。</li>
</ul>
<p>我模拟实现的bind方法代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123; <span class="comment">//验证当前被调用的是否是方法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="built_in">this</span> + <span class="string">&quot;isn&#x27;t a function!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//处理函数使用new的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span> <span class="keyword">instanceof</span> fn ? <span class="keyword">new</span> _this(...args, ...arguments) : _this.myApply(context, args.concat(...arguments));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更多bind方法的实现详见：<br><a href="https://segmentfault.com/a/1190000017091983">面试官问：能否模拟实现JS的bind方法？</a><br><a href="https://www.jianshu.com/p/9d75886102a7">bind方法的实现</a></p>
<p>经测试，模拟实现的myCall、myApply和myBind方法和call、apply和bind方法效果一致。到这里，我们已经模拟实现了自己的三兄弟方法，如果你有任何的问题，欢迎评论区留言，你的支持是我前进的最大动力。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表</title>
    <url>/2020/09/21/%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<strong>散列函数</strong>，存放记录的数组叫做散列表。</p>
<a id="more"></a>
<h2 id="HashTable类的模拟实现"><a href="#HashTable类的模拟实现" class="headerlink" title="HashTable类的模拟实现"></a>HashTable类的模拟实现</h2><p>下面我们来模拟实现自己的HashTable类，也叫HashMap类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultToString</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NULL&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UNDEFINED&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">&quot;string&quot;</span> || item <span class="keyword">instanceof</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;item&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValuePair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(key, value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`[#<span class="subst">$&#123;<span class="built_in">this</span>.key&#125;</span>: <span class="subst">$&#123;<span class="built_in">this</span>.value&#125;</span>&#125;]`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(toStrFn = defaultToString) &#123;</span><br><span class="line">        <span class="built_in">this</span>.toStrFn = toStrFn;</span><br><span class="line">        <span class="built_in">this</span>.table = &#123;&#125;;</span><br><span class="line">    &#125;            </span><br><span class="line">    <span class="comment">// 散列函数</span></span><br><span class="line">    loseloseHashCode(key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> tableKey = <span class="built_in">this</span>.toStrFn(key);</span><br><span class="line">        <span class="keyword">let</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tableKey.length; i++) &#123;</span><br><span class="line">            hash += tableKey.charCodeAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash % <span class="number">37</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取某一个键的hash值</span></span><br><span class="line">    HashCode(key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.loseloseHashCode(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将键和值加入散列表</span></span><br><span class="line">    put(key, value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> position = <span class="built_in">this</span>.HashCode(key);</span><br><span class="line">            <span class="built_in">this</span>.table[position] = <span class="keyword">new</span> ValuePair(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从散列表中获取一个值</span></span><br><span class="line">    get(key) &#123;</span><br><span class="line">        <span class="keyword">const</span> valuePair = <span class="built_in">this</span>.table[<span class="built_in">this</span>.HashCode(key)];</span><br><span class="line">        <span class="keyword">return</span> valuePair == <span class="literal">null</span> ? <span class="literal">undefined</span> : valuePair.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从散列表移除一个值</span></span><br><span class="line">    remove(key) &#123;</span><br><span class="line">        <span class="keyword">const</span> hash = <span class="built_in">this</span>.HashCode(key);</span><br><span class="line">        <span class="keyword">const</span> valuePair = <span class="built_in">this</span>.table[hash];</span><br><span class="line">        <span class="keyword">if</span> (valuePair != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.table[hash];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不再演示HashTable类中方法的使用了，有兴趣的可以自己做个demo测试一下，如果有任何的问题，欢迎评论区留言。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>新的征程</title>
    <url>/2020/09/20/%E6%96%B0%E7%9A%84%E5%BE%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="大四"><a href="#大四" class="headerlink" title="大四"></a>大四</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转眼间已经大四了，我的川大时间余额已不足一年，只觉三年的时光转瞬即逝，想抓住时间却已经悄悄溜走，仅剩的一年川大时光我一定会倍加珍惜。刚结束的大三，我觉得是我三年来最努力的一年，这一年，我积极备考英语六级，第一次把六级词汇书基本通背一遍，虽然最后成绩不是很理想，但终归好于裸考的四级，同样，在这一年，我大幅度压缩游戏时间，英雄联盟陪伴我好几年的游戏也最终放弃，上课时间也不断提醒自己少耍手机，这一年的奋斗也终于出了点效果，大三一年的成绩排名比大二进步多了，我也顺利申请了奖学金，虽然深知最多只有300元，但也觉得这来之不易的300元是对我积极努力的最好回报。如今，大四已经开学半月有余，我的生活学习节奏还算可以，紧追大三的步伐，努力学习知识不断充实自己。</p>
<a id="more"></a>
<h2 id="从放弃考研到学习前端"><a href="#从放弃考研到学习前端" class="headerlink" title="从放弃考研到学习前端"></a>从放弃考研到学习前端</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我最终下定决心放弃考研是在4月底，这时候，大三下的课程基本学完了，即使因为疫情没有返校，在家的这几个月也没有丝毫松懈，编译原理我大学生涯的最后一块难啃的专业必修课，也最终被拿下，虽然最后的成绩不尽人意，但我也无怨无悔，因为我知道，平时我真的是好好学了的。其实在大二暑假我才第一次接触前端，是在腾讯课堂上学习一门HTML和CSS入门课，那时候觉得做页面很炫酷，可以做出各种好看的效果，于是就深深爱上了前端，5月初，学校还是没有通知返校，我的内心开始逐渐焦虑，本想返校后开始好好学习前端，但学校迟迟不下通知，机不可失失不再来，我决定开始在家学习前端。5月，我重温了袁老师的HTML和CSS基础入门课，因为之前学过的缘故，所以看的很快，5月中旬，我开始学习javascript，跟着《javascript入门经典》把js基础知识过了一遍，这时候，我在微信上结识了陶务华，已经工作了的他给我发了很多教程，感谢他的帮助，我得以迅速入门前端，也认识到前端不只是学习HTML、CSS和javascript这么简单，还有很多的技术工具需要去学习。跟着陶大哥的视频教程，我逐渐学到了HTML5、CSS3、jQuery等稍微进阶的知识，我的前端水平也进一步提高，后来我又接触到了服务器端开发Node.js、Express和art-template模板，也开始学习前后端交互，学习Ajax和jQuery下的Ajax，然后接触到了MongoDB数据库，后来开始学习Vue框架以及webpack打包和Gulp构建，自己的前端水平继续提高，到现在，我基本上前端知识都接触到了，但是大都研究不深入，只是懂了点皮毛，后面我准备分专题开始逐渐深入了解前端世界。</p>
<h2 id="简历和面试"><a href="#简历和面试" class="headerlink" title="简历和面试"></a>简历和面试</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前几天，我刚刚投出了人生的第一份简历，现在还再初筛中，面试对我来说是陌生的，尤其是技术面试，不过慢慢来嘛，再难也要一步一个脚印往前走，难道不是吗？</p>
<h2 id="关于前端"><a href="#关于前端" class="headerlink" title="关于前端"></a>关于前端</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能很多人对前端很陌生，甚至不知道还有前端工程师这个职业，下面我就来简单介绍一下。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://baike.baidu.com/item/%E5%89%8D%E7%AB%AF/5956545">前端</a>即网站前台部分，运行在PC端，移动端等浏览器上展现给用户浏览的网页。随着互联网技术的发展，HTML5，CSS3，前端框架的应用，跨平台响应式网页设计能够适应各种屏幕分辨率，合适的动效设计，给用户带来极高的用户体验，当然现在的前端也不仅仅限于PC电脑端，移动端如APP和微信小程序它们的前台页面也叫前端。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://baike.baidu.com/item/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91">前端开发</a>是创建Web页面（也就是咱们常说的网页）或app（也就是咱们手机上的软件，如QQ、微信等）等前端界面呈现给用户的过程，通过HTML，CSS及JavaScript（这些都是开发网页所需的技术）以及衍生出来的各种技术、框架、解决方案，来实现互联网产品的用户界面交互。它从网页制作演变而来，名称上有很明显的时代特征。在互联网的演化进程中，网页制作是Web1.0时代的产物，早期网站主要内容都是静态，以图片和文字为主，用户使用网站的行为也以浏览为主。随着互联网技术的发展和HTML5、CSS3的应用，现代网页更加美观，交互效果显著，功能更加强大。移动互联网带来了大量高性能的移动终端设备以及快速的无线网络，HTML5、node.jS的广泛应用，各类框架类库层出不穷。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://baike.baidu.com/item/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88">前端工程师</a>，顾名思义，是使用前端技术进行页面开发的一类职业，它是互联网时代软件产品研发中不可缺少的一种专业研发角色。从狭义上讲，前端工程师使用 HTML、CSS、JavaScript 等专业技能和工具将产品UI设计稿实现成网站产品，涵盖用户PC端、移动端网页，处理视觉和交互问题。从广义上来讲，所有用户终端产品与视觉和交互有关的部分，都是前端工程师的专业领域。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;像我们熟知的一些公司，如阿里巴巴、腾讯、百度、美团、抖音（字节跳动旗下）等，他们都叫做互联网公司或者叫软件公司，这类公司是急需前端人才的，毕竟产品的好坏只有通过页面展示出来才能知晓。</p>
<h2 id="新的征程"><a href="#新的征程" class="headerlink" title="新的征程"></a>新的征程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新的征程已经开始，唯有不断奋斗，追逐梦想才是人存在的意义，加油吧，少年，美好的未来在等着我们！</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2020/09/21/%E6%A0%88/</url>
    <content><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种遵从<strong>后进先出</strong>（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。</p>
<a id="more"></a>
<h2 id="创建一个基于数组的Stack类"><a href="#创建一个基于数组的Stack类" class="headerlink" title="创建一个基于数组的Stack类"></a>创建一个基于数组的Stack类</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向栈添加元素</span></span><br><span class="line">    push(element) &#123;</span><br><span class="line">        <span class="built_in">this</span>.items.push(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从栈移除元素</span></span><br><span class="line">    pop() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    peek() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.items.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取栈的大小</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空栈元素</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建一个基于JavaScript对象的Stack类"><a href="#创建一个基于JavaScript对象的Stack类" class="headerlink" title="创建一个基于JavaScript对象的Stack类"></a>创建一个基于JavaScript对象的Stack类</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向栈中插入元素</span></span><br><span class="line">    push(element) &#123;</span><br><span class="line">        <span class="built_in">this</span>.items[<span class="built_in">this</span>.count] = element;</span><br><span class="line">        <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取栈的大小</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从栈中弹出元素</span></span><br><span class="line">    pop() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.count--;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">this</span>.items[<span class="built_in">this</span>.count];</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.count];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    peek() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.count - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空栈元素</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建toString方法</span></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.items[<span class="number">0</span>]&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">this</span>.count; i++) &#123;</span><br><span class="line">            objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>, <span class="subst">$&#123;<span class="built_in">this</span>.items[i]&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不再演示Stack类中方法的使用了，有兴趣的可以自己做个demo测试一下，如果有任何的问题，欢迎评论区留言。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎</title>
    <url>/2020/09/16/%E6%AC%A2%E8%BF%8E/</url>
    <content><![CDATA[<h1 id="欢迎大家来到我的个人网站"><a href="#欢迎大家来到我的个人网站" class="headerlink" title="欢迎大家来到我的个人网站"></a>欢迎大家来到我的个人网站</h1><p>希望和大家一起交流前端，有什么问题可以随时联系我，不管是技术还是生活，希望大家每天都能开开心心的学习，开开心心的生活！</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>赋值、浅拷贝和深拷贝</title>
    <url>/2020/09/19/%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>赋值是将某一数值或对象赋给某个变量的过程，分为两类:</p>
<ul>
<li>基本数据类型：赋值，赋值之后两个变量互不影响。</li>
<li>引用数据类型：赋址，两个变量具有相同的引用，指向同一个对象，相互之间有影响。<a id="more"></a>
来看下面两个例子：<br>先看基本数据类型<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;java&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">//java</span></span><br><span class="line">a = <span class="string">&quot;javascript&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// java</span></span><br></pre></td></tr></table></figure>
上面代码的输出为：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line">javascript</span><br><span class="line">java</span><br></pre></td></tr></table></figure>
如果是引用数据类型呢？<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;javascript&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;I love javascript&quot;</span>,</span><br><span class="line">        price: <span class="number">45</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>
上面代码的输出为：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: <span class="string">&quot;javascript&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;I love javascript&quot;</span>,</span><br><span class="line">        price: <span class="number">45</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果这时候改变a的值，像下面这样：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a.name = <span class="string">&quot;java&quot;</span>;</span><br><span class="line">a.book.title = <span class="string">&quot;I love java&quot;</span>;</span><br><span class="line">a.book.price = <span class="number">55</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure>
输出的结果为：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: <span class="string">&quot;java&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;I love java&quot;</span>,</span><br><span class="line">        price: <span class="number">55</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    name: <span class="string">&quot;java&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;I love java&quot;</span>,</span><br><span class="line">        price: <span class="number">55</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到a和b的值都改变了，但是通常在开发中我们并不希望改变变量 a 之后会影响到变量 b，这时就需要用到浅拷贝和深拷贝。</li>
</ul>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。<br><img src="https://s1.ax1x.com/2020/09/19/w50M2d.png" alt="alt"></p>
<p>上图中，SourceObj 是原对象，其中包含基本类型属性 field1 和引用类型属性 refObj。浅拷贝之后基本类型数据  field2 和 filed1 是不同属性，互不影响。但引用类型 refObj 仍然是同一个，改变之后会对另一个对象产生影响。</p>
<p>那么浅拷贝有哪些应用场景呢？</p>
<ul>
<li><p>Object.assign()<br>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，它将返回目标对象，来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;java&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;I love java&quot;</span>,</span><br><span class="line">        price: <span class="number">45</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;java&quot;,</span></span><br><span class="line"><span class="comment">//     book: &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love java&quot;,</span></span><br><span class="line"><span class="comment">//         price: 45</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">a.name = <span class="string">&quot;javascript&quot;</span>;</span><br><span class="line">a.book.title = <span class="string">&quot;I love javascript&quot;</span>;</span><br><span class="line">a.book.price = <span class="number">55</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;javascript&quot;,</span></span><br><span class="line"><span class="comment">//     book: &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love javascript&quot;,</span></span><br><span class="line"><span class="comment">//         price: 55</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;java&quot;,</span></span><br><span class="line"><span class="comment">//     book: &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love javascript&quot;,</span></span><br><span class="line"><span class="comment">//         price: 55</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码改变对象 a 之后，对象 b 的基本属性保持不变。但是当改变对象 a 中的对象 book 时，对象 b 也跟着发生了变化，因为它们指向的是同一块内存地址。</p>
</li>
<li><p>展开语法Spread</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;java&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;I love java&quot;</span>,</span><br><span class="line">        price: <span class="number">45</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;java&quot;,</span></span><br><span class="line"><span class="comment">//     book: &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love java&quot;,</span></span><br><span class="line"><span class="comment">//         price: 45</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">a.name = <span class="string">&quot;javascript&quot;</span>;</span><br><span class="line">a.book.title = <span class="string">&quot;I love javascript&quot;</span>;</span><br><span class="line">a.book.price = <span class="number">55</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;javascript&quot;,</span></span><br><span class="line"><span class="comment">//     book: &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love javascript&quot;,</span></span><br><span class="line"><span class="comment">//         price: 55</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;java&quot;,</span></span><br><span class="line"><span class="comment">//     book: &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love javascript&quot;,</span></span><br><span class="line"><span class="comment">//         price: 55</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>通过代码可以看出实际效果和 Object.assign() 是一样的。</p>
</li>
<li><p>Array.prototype.slice()<br>slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝，原始数组不会被改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>, <span class="string">&quot;1&quot;</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = a.slice(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// [&quot;1&quot;, [2, 3]]</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;99&quot;</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// [0, &quot;99&quot;, [4, 3]]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">//  [&quot;1&quot;, [4, 3]]</span></span><br></pre></td></tr></table></figure>
<p>通过，改变 a[1] 之后 b[0] 的值并没有发生变化，但改变 a[2][0] 之后，相应的 b[1][0] 的值也发生变化。说明 slice() 方法是浅拷贝，相应的还有concat等，在实际工作中使用数组对象等引用数据类型时要特别注意。</p>
</li>
<li><p>jQuery.extend()</p>
</li>
</ul>
<p>使用jQuery语法前记得先引入jQuery，来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;java&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;I love java&quot;</span>,</span><br><span class="line">        price: <span class="number">45</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;&#125;;</span><br><span class="line">$.extend(b, a); <span class="comment">//jQuery.extend(b, a);</span></span><br><span class="line"><span class="built_in">console</span>.log(a); </span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;java&quot;,</span></span><br><span class="line"><span class="comment">//     book : &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love java&quot;,</span></span><br><span class="line"><span class="comment">//         price: 45</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;java&quot;,</span></span><br><span class="line"><span class="comment">//     book : &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love java&quot;,</span></span><br><span class="line"><span class="comment">//         price: 45</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">a.name = <span class="string">&quot;javascript&quot;</span>;</span><br><span class="line">a.book.title = <span class="string">&quot;I love javascript&quot;</span>;</span><br><span class="line">a.book.price = <span class="number">55</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;javascript&quot;,</span></span><br><span class="line"><span class="comment">//     book : &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love javascript&quot;,</span></span><br><span class="line"><span class="comment">//         price: 55</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;java&quot;,</span></span><br><span class="line"><span class="comment">//     book : &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love javascript&quot;,</span></span><br><span class="line"><span class="comment">//         price: 55</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。</p>
<p><img src="https://s1.ax1x.com/2020/09/19/w5jYPf.png" alt="alt"></p>
<p>那么深拷贝有什么使用场景呢？</p>
<ul>
<li>JSON.parse(JSON.stringify(object))<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;java&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;I love java&quot;</span>,</span><br><span class="line">        price: <span class="number">45</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;java&quot;,</span></span><br><span class="line"><span class="comment">//     book: &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love java&quot;,</span></span><br><span class="line"><span class="comment">//         price: 45</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">a.name = <span class="string">&quot;javascript&quot;</span>;</span><br><span class="line">a.book.title = <span class="string">&quot;I love javascript&quot;</span>;</span><br><span class="line">a.book.price = <span class="number">55</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;javascript&quot;,</span></span><br><span class="line"><span class="comment">//     book: &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love javascript&quot;,</span></span><br><span class="line"><span class="comment">//         price: 55</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;java&quot;,</span></span><br><span class="line"><span class="comment">//     book: &#123;</span></span><br><span class="line"><span class="comment">//         title: &quot;I love java&quot;,</span></span><br><span class="line"><span class="comment">//         price: 45</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
完全改变变量 a 之后对 b 没有任何影响，这就是深拷贝的魔力。那么对数组深拷贝效果如何？来看下面的例子：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>, <span class="string">&quot;1&quot;</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify( a.slice(<span class="number">1</span>) ));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// [&quot;1&quot;, [2, 3]]</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;99&quot;</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// [0, &quot;99&quot;, [4, 3]]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">//  [&quot;1&quot;, [2, 3]]</span></span><br></pre></td></tr></table></figure>
可以发现，对数组深拷贝之后，改变原数组不会影响到拷贝之后的数组。但是这种方法有如下的几个问题：</li>
<li>会忽略 undefined</li>
<li>会忽略 symbol</li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
<li>不能正确处理new Date()</li>
<li>不能处理正则</li>
</ul>
<p>undefined、symbol 和函数这三种情况，会直接忽略：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&quot;javascript&quot;</span>,</span><br><span class="line">    a: <span class="literal">undefined</span>,</span><br><span class="line">    b: <span class="built_in">Symbol</span>(<span class="string">&quot;javascript&quot;</span>),</span><br><span class="line">    c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	name: &quot;javascript&quot;, </span></span><br><span class="line"><span class="comment">// 	a: undefined, </span></span><br><span class="line"><span class="comment">//      b: Symbol(javascript), </span></span><br><span class="line"><span class="comment">//      c: ƒ ()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(newObj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;javascript&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>循环引用情况下，会报错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        c: <span class="number">2</span>,</span><br><span class="line">   		d: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a = obj.b;</span><br><span class="line">obj.b.c = obj.a;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="comment">// Uncaught TypeError: Converting circular structure to JSON</span></span><br></pre></td></tr></table></figure>
<p>new Date() 情况下，转换结果不正确:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// Sat Sep 19 2020 15:29:37 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line"><span class="comment">// &quot;&quot;2020-09-19T07:29:50.597Z&quot;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(<span class="keyword">new</span> <span class="built_in">Date</span>()));</span><br><span class="line"><span class="comment">// &quot;2020-09-19T07:30:14.480Z&quot;</span></span><br></pre></td></tr></table></figure>
<p>将 new Date() 的结果转换为字符串或时间戳就ok了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> date = (<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf();</span><br><span class="line"><span class="built_in">console</span>.log(date);</span><br><span class="line"><span class="comment">// 1600500782999</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(date);</span><br><span class="line"><span class="comment">// &quot;1600500782999&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(date));</span><br><span class="line"><span class="comment">// 1600500782999</span></span><br></pre></td></tr></table></figure>
<p>正则情况下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&quot;javascript&quot;</span>,</span><br><span class="line">    a: <span class="regexp">/&#x27;456&#x27;/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;javascript&quot;, </span></span><br><span class="line"><span class="comment">//     a: /&#x27;456&#x27;/</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name: &quot;javascript&quot;, </span></span><br><span class="line"><span class="comment">//     a: &#123;&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">和原数据是否指向同一对象</th>
<th align="center">第一层数据为基本数据类型</th>
<th align="center">原数据中包含子对象</th>
</tr>
</thead>
<tbody><tr>
<td align="center">赋值</td>
<td align="center">是</td>
<td align="center">改变会使原数据一同改变</td>
<td align="center">改变会使原数据一同改变</td>
</tr>
<tr>
<td align="center">浅拷贝</td>
<td align="center">否</td>
<td align="center">改变不会使原数据一同改变</td>
<td align="center">改变会使原数据一同改变</td>
</tr>
<tr>
<td align="center">深拷贝</td>
<td align="center">否</td>
<td align="center">改变不会使原数据一同改变</td>
<td align="center">改变不会使原数据一同改变</td>
</tr>
</tbody></table>
<p>到这里，赋值、浅拷贝和深拷贝我们已经梳理完毕了，如果你有任何的问题，欢迎评论区留言，你的支持是我前进最大的动力。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/09/21/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。相比于传统的数组，链表的一个好处在于，添加或删除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。在数组中，我们可以直接访问任何位置的任何元素，而想要访问链表中间的一个元素，则需要从起点（表头）开始迭代链表直到找到所需的元素。</p>
<a id="more"></a>
<h2 id="LinkedList类的模拟实现"><a href="#LinkedList类的模拟实现" class="headerlink" title="LinkedList类的模拟实现"></a>LinkedList类的模拟实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建相等性比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultEquals</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a === b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建Node（节点）类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">        <span class="built_in">this</span>.element = element;</span><br><span class="line">        <span class="built_in">this</span>.next = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(equalsFn = defaultEquals) &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="built_in">this</span>.equalsFn = equalsFn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向链表尾部添加元素</span></span><br><span class="line">    push(element) &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">        <span class="keyword">let</span> current;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">while</span> (current.next != <span class="literal">null</span>) &#123; <span class="comment">// 获取最后一项</span></span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = node; <span class="comment">// 将其next赋为新元素，建立链接</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环迭代链表直到目标位置</span></span><br><span class="line">    getElementAt(index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="built_in">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">let</span> node = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; index &amp;&amp; node != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">                node = node.next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从链表中移除元素</span></span><br><span class="line">    removeAt(index) &#123;</span><br><span class="line">        <span class="comment">// 检查越界值</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="comment">// 移除第一项</span></span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.head = current.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// let previous;</span></span><br><span class="line">                <span class="comment">// for (let i = 0; i &lt; index; i++) &#123;</span></span><br><span class="line">                <span class="comment">//     previous = current;</span></span><br><span class="line">                <span class="comment">//     current = current.next;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">// previous.next = current.next;</span></span><br><span class="line">                <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>);</span><br><span class="line">                current = previous.next;</span><br><span class="line">                <span class="comment">// 将previous与current的下一项链接起来：跳过current，从而移除它</span></span><br><span class="line">                previous.next = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.count--;</span><br><span class="line">            <span class="keyword">return</span> current.element;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在任意位置插入元素</span></span><br><span class="line">    insert(element, index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="built_in">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123; <span class="comment">// 在第一个位置添加</span></span><br><span class="line">                <span class="keyword">const</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">                node.next = current;</span><br><span class="line">                <span class="built_in">this</span>.head = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">const</span> current = previous.next;</span><br><span class="line">                node.next = current;</span><br><span class="line">                previous.next = node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.count++; <span class="comment">// 更新链表的长度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个元素的位置</span></span><br><span class="line">    indexOf(element) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.count &amp;&amp; current != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.equalsFn(element, current.element)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从链表中移除元素</span></span><br><span class="line">    remove(element) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="built_in">this</span>.indexOf(element);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.removeAt(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取链表的大小</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查链表是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size() === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取链表头部</span></span><br><span class="line">    getHead() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建toString方法</span></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.head.element&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="built_in">this</span>.head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">this</span>.size() &amp;&amp; current != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">            objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>, <span class="subst">$&#123;current.element&#125;</span>`</span>;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个节点的链接；而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素。</p>
<h2 id="DoublyLinkedList类的模拟实现"><a href="#DoublyLinkedList类的模拟实现" class="headerlink" title="DoublyLinkedList类的模拟实现"></a>DoublyLinkedList类的模拟实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建新的节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element, next, prev) &#123;</span><br><span class="line">        <span class="built_in">super</span>(element, next);</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(equalsFn = defaultEquals) &#123;</span><br><span class="line">        <span class="built_in">super</span>(equalsFn);</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在任意位置插入新元素</span></span><br><span class="line">    insert(element, index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="built_in">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = <span class="keyword">new</span> DoublyNode(element);</span><br><span class="line">            <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.head = node;</span><br><span class="line">                    <span class="built_in">this</span>.tail = node;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.next = <span class="built_in">this</span>.head;</span><br><span class="line">                    current.prev = node;</span><br><span class="line">                    <span class="built_in">this</span>.head = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="built_in">this</span>.count) &#123; <span class="comment">// 最后一项</span></span><br><span class="line">                current = <span class="built_in">this</span>.tail;</span><br><span class="line">                current.next = node;</span><br><span class="line">                node.prev = current;</span><br><span class="line">                <span class="built_in">this</span>.tail = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>);</span><br><span class="line">                current = previous.next;</span><br><span class="line">                node.next = current;</span><br><span class="line">                previous.next = node;</span><br><span class="line">                current.prev = node;</span><br><span class="line">                node.prev = previous;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.count++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从任意位置移除元素</span></span><br><span class="line">    removeAt(index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.head = current.next;</span><br><span class="line">                <span class="comment">// 如果只有一项，更新tail</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.count === <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.tail = <span class="literal">undefined</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.head.prev = <span class="literal">undefined</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="built_in">this</span>.count - <span class="number">1</span>) &#123; <span class="comment">// 最后一项</span></span><br><span class="line">                current = <span class="built_in">this</span>.tail;</span><br><span class="line">                <span class="built_in">this</span>.tail = current.prev;</span><br><span class="line">                <span class="built_in">this</span>.tail.next = <span class="literal">undefined</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = <span class="built_in">this</span>.getElementAt(index);</span><br><span class="line">                <span class="keyword">const</span> previous = current.prev;</span><br><span class="line">                <span class="comment">// 将previous与current的下一项链接起来——跳过current</span></span><br><span class="line">                previous.next = current.next;</span><br><span class="line">                current.next.prev = previous;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.count--;</span><br><span class="line">            <span class="keyword">return</span> current.element;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表的链表的唯一区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用undefined，而是指向第一个元素。双向循环链表有指向head元素的tail.next和指向tail元素的head.prev。</p>
<h2 id="CircularLinkedList类的模拟实现"><a href="#CircularLinkedList类的模拟实现" class="headerlink" title="CircularLinkedList类的模拟实现"></a>CircularLinkedList类的模拟实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(equalsFn = defaultEquals) &#123;</span><br><span class="line">        <span class="built_in">super</span>(equalsFn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在任意位置插入新元素</span></span><br><span class="line">    insert(element, index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="built_in">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">            <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.head = node;</span><br><span class="line">                    node.next = <span class="built_in">this</span>.head;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node.next = current;</span><br><span class="line">                    current = <span class="built_in">this</span>.getElementAt(<span class="built_in">this</span>.size());</span><br><span class="line">                    <span class="comment">// 更新最后一个元素</span></span><br><span class="line">                    <span class="built_in">this</span>.head = node;</span><br><span class="line">                    current.next = <span class="built_in">this</span>.head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>);</span><br><span class="line">                node.next = previous.next;</span><br><span class="line">                previous.next = node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.count--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从任意位置移除元素</span></span><br><span class="line">    removeAt(index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="built_in">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.size() === <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.head = <span class="literal">undefined</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> removed = <span class="built_in">this</span>.head;</span><br><span class="line">                    current = <span class="built_in">this</span>.getElementAt(<span class="built_in">this</span>.size());</span><br><span class="line">                    <span class="built_in">this</span>.head = <span class="built_in">this</span>.head.next;</span><br><span class="line">                    current.next = <span class="built_in">this</span>.head;</span><br><span class="line">                    current = removed;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不需要修改循环链表最后一个元素</span></span><br><span class="line">                <span class="keyword">const</span> previous = <span class="built_in">this</span>.getElementAt(index - <span class="number">1</span>);</span><br><span class="line">                current = previous.next;</span><br><span class="line">                previous.next = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.count--;</span><br><span class="line">            <span class="keyword">return</span> current.element;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="有序链表"><a href="#有序链表" class="headerlink" title="有序链表"></a>有序链表</h2><p>有序链表是指保持有序的链表结构。除了使用排序算法之外，我们还可以将元素插入到正确的位置来保证链表的有序性。</p>
<h2 id="SortedLinkedList类的模拟实现"><a href="#SortedLinkedList类的模拟实现" class="headerlink" title="SortedLinkedList类的模拟实现"></a>SortedLinkedList类的模拟实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明Compare常量</span></span><br><span class="line"><span class="keyword">const</span> Compare = &#123;</span><br><span class="line">    LESS_THAN: <span class="number">-1</span>,</span><br><span class="line">    BIGGER_THAN: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建相等性比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultCompare</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(equalsFn = defaultEquals, compareFn = defaultCompare) &#123;</span><br><span class="line">        <span class="built_in">super</span>(equalsFn);</span><br><span class="line">        <span class="built_in">this</span>.compareFn = compareFn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有序插入元素</span></span><br><span class="line">    insert(element, index = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.insert(element, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> pos = <span class="built_in">this</span>.getIndexNextSortedElement(element);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.insert(element, pos);</span><br><span class="line">    &#125;</span><br><span class="line">    getIndexNextSortedElement(element) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="built_in">this</span>.size() &amp;&amp; current; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> comp = <span class="built_in">this</span>.compareFn(element, current.element);</span><br><span class="line">            <span class="keyword">if</span> (comp === Compare.LESS_THAN) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="利用链表创建栈"><a href="#利用链表创建栈" class="headerlink" title="利用链表创建栈"></a>利用链表创建栈</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.it</span><br><span class="line">        ems = <span class="keyword">new</span> DoublyLinkedList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向栈添加元素</span></span><br><span class="line">    push(element) &#123;</span><br><span class="line">        <span class="built_in">this</span>.items.push(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从栈移除元素</span></span><br><span class="line">    pop() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.removeAt(<span class="built_in">this</span>.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看栈顶元素</span></span><br><span class="line">    peek() &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.getElementAt(<span class="built_in">this</span>.size() - <span class="number">1</span>).element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取栈的大小</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空栈元素</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="built_in">this</span>.items.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建toString方法</span></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了栈，我们还可以使用LinkedList类及其变种作为内部的数据结构来创建其他的数据结构，例如队列、双端队列等，这里就不再赘述，有兴趣的可以自己实现一下。这里也不再演示这些链表中方法的使用了，有兴趣的可以自己做个demo测试一下，如果有任何的问题，欢迎评论区留言。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2020/09/21/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是遵循<strong>先进先出</strong>（FIFO，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。</p>
<a id="more"></a>
<h2 id="Queue类的模拟实现"><a href="#Queue类的模拟实现" class="headerlink" title="Queue类的模拟实现"></a>Queue类的模拟实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向队列添加元素</span></span><br><span class="line">    enqueue(element) &#123;</span><br><span class="line">        <span class="built_in">this</span>.items[<span class="built_in">this</span>.count] = element;</span><br><span class="line">        <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从队列移除元素 </span></span><br><span class="line">    dequeue() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount];</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount];</span><br><span class="line">        <span class="built_in">this</span>.lowestCount++;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看队列头元素</span></span><br><span class="line">    peek() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查队列是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count - <span class="built_in">this</span>.lowestCount === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取队列的长度</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count - <span class="built_in">this</span>.lowestCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空队列</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建toString方法</span></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount]&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">this</span>.lowestCount + <span class="number">1</span>; i &lt; <span class="built_in">this</span>.count; i++) &#123;</span><br><span class="line">            objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>, <span class="subst">$&#123;<span class="built_in">this</span>.items[i]&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>双端队列是一种允许我们同时从前端和后端添加和删除元素的特殊队列。</p>
<h2 id="Deque类的模拟实现"><a href="#Deque类的模拟实现" class="headerlink" title="Deque类的模拟实现"></a>Deque类的模拟实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deque</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向双端队列的前端添加元素</span></span><br><span class="line">    addFront(element) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.addBack(element);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.lowestCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.lowestCount--;</span><br><span class="line">            <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount] = element;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">this</span>.count; i &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.items[i] = <span class="built_in">this</span>.items[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.count++;</span><br><span class="line">            <span class="built_in">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.items[<span class="number">0</span>] = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向双端队列的后端添加元素</span></span><br><span class="line">    addBack(element) &#123;</span><br><span class="line">        <span class="built_in">this</span>.items[<span class="built_in">this</span>.count] = element;</span><br><span class="line">        <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从双端队列的前端移除元素</span></span><br><span class="line">    removeFront() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount];</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount];</span><br><span class="line">        <span class="built_in">this</span>.lowestCount++;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从双端队列的后端移除元素</span></span><br><span class="line">    removeBack() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.count--;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">this</span>.items[<span class="built_in">this</span>.count];</span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.count];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看双端队列前端头元素</span></span><br><span class="line">    peekFront() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看双端队列后端头元素</span></span><br><span class="line">    peekBack() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.items[<span class="built_in">this</span>.count - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取双端队列的大小</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count - <span class="built_in">this</span>.lowestCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查双端队列是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size() === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空双端队列</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.lowestCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建toString方法</span></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> objString = <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.items[<span class="built_in">this</span>.lowestCount]&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">this</span>.lowestCount + <span class="number">1</span>; i &lt; <span class="built_in">this</span>.count; i++) &#123;</span><br><span class="line">            objString = <span class="string">`<span class="subst">$&#123;objString&#125;</span>,<span class="subst">$&#123;<span class="built_in">this</span>.items[i]&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不再演示Queue类和Deque类中方法的使用了，有兴趣的可以自己做个demo测试一下，如果有任何的问题，欢迎评论区留言。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖和节流</title>
    <url>/2020/09/16/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>防抖和节流都是前端性能优化的方式。在前端开发中，我们经常会需要绑定一些持续触发的事件，如input、scroll、mousemove、resize等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数，这时候我们就会用到防抖和节流，让我们先看一个简单的例子：</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #count &#123;</span><br><span class="line">            height: <span class="number">150</span>px;</span><br><span class="line">            line-height: <span class="number">150</span>px;</span><br><span class="line">            text-align: center;</span><br><span class="line">            color: #fff;</span><br><span class="line">            background-color: #ccc;</span><br><span class="line">            font-size: <span class="number">80</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;count&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            oDiv.innerHTML = num++;</span><br><span class="line">        &#125;</span><br><span class="line">        oDiv.onmousemove = count;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，div 元素绑定了 mousemove 事件，当鼠标在 div（灰色）区域中移动的时候会持续地去触发该事件导致频繁执行函数。效果如下:</p>
<p><img src="https://s1.ax1x.com/2020/09/20/wTEIun.gif" alt="alt"></p>
<p>可以看到，在没有通过其它操作的情况下，函数被频繁地执行导致页面上数据变化特别快。所以，接下来让我们来看看防抖和节流是如何去解决这个问题的。</p>
<h2 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h2><p>在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms，然后：</p>
<ul>
<li>如果在200ms内没有再次触发滚动事件，那么就执行函数</li>
<li>如果在200ms内再次触发滚动事件，那么当前的计时取消，重新开始计时</li>
</ul>
<blockquote>
<p>如果短时间内大量触发同一事件，只会执行一次函数。</p>
</blockquote>
<p>可设计如下的防抖函数，使得触发事件后count函数不会立即执行，而是在1s后执行，如果在1s内又触发了事件，则会重新计算函数执行时间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer); <span class="comment">//延迟时间内再次触发则清空计时器</span></span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(fn, delay); <span class="comment">//开启新的计时器</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">oDiv.onmousemove = debounce(count, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img src="https://s1.ax1x.com/2020/09/20/wTAL6A.gif" alt="alt"></p>
<p>到这里，已经把防抖实现了，现在给出定义：</p>
<p><strong>对于短时间内连续触发的事件（如上面的mousemove事件），防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行一次。</strong></p>
<blockquote>
<p>还有一种防抖函数，触发事件后函数会立即执行，然后延迟时间内不触发事件才能继续执行函数，这里不再赘述，详情请看<a href="https://www.jianshu.com/p/c8b86b09daf0">防抖和节流</a>。</p>
</blockquote>
<h2 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h2><p>所谓节流，就是指<strong>连续触发事件但是在设定的延迟时间只执行一次函数</strong>，节流会稀释函数的执行频率。</p>
<p>对于上面的mousemove事件，可设计如下的节流函数，在持续触发事件的过程中，count函数不会立即执行，并且每 1s 执行一次，在停止触发事件后，函数还会再执行一次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> valid = <span class="literal">true</span>; <span class="comment">//设置一个状态位来表示fn函数是否处于工作状态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!valid) <span class="keyword">return</span> <span class="literal">false</span>； <span class="comment">//fn函数不工作</span></span><br><span class="line">        valid = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//工作时间，执行fn函数并且在间隔期内把状态位设为无效 </span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">            fn(); </span><br><span class="line">            valid = <span class="literal">true</span>; </span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">oDiv.onmousemove = throttle(count, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="https://s1.ax1x.com/2020/09/20/wTAOOI.gif" alt="alt"></p>
<p>从上面的动图可以看出，如果在灰色区域一直移动鼠标，那么会以1s的时间间隔，逐渐计数。</p>
<blockquote>
<p>当然节流函数不止上面这一种实现方案，例如可以完全不借setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。也可以直接将setTimeout返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样。详情请看<a href="https://www.jianshu.com/p/c8b86b09daf0">防抖和节流</a>。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>防抖和节流都是前端性能优化的方式，防抖是控制次数，而节流是控制频率。一种常见的应用场景是浏览器的搜索引擎，对于搜索框input事件，例如要支持输入实时搜索可以使用节流方案（间隔一段时间就必须查询相关内容），或者实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求，防抖和节流可以有效避免浏览器向服务器发出过多无用的请求。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2020/09/20/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合是由一种<strong>无序</strong>且<strong>唯一</strong>（即不能重复）的项组成的。</p>
<a id="more"></a>
<h2 id="Set类的模拟实现"><a href="#Set类的模拟实现" class="headerlink" title="Set类的模拟实现"></a>Set类的模拟实现</h2><p>虽然ES2015给我们提供了原生的Set类，但是并没有实现并集、交集、差集、子集等数学运算，这里我们模拟实现自己的Set类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果元素在集合中，返回true，否则返回false</span></span><br><span class="line">    has(element) &#123;</span><br><span class="line">        <span class="keyword">return</span> element <span class="keyword">in</span> <span class="built_in">this</span>.items;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向集合添加一个元素</span></span><br><span class="line">    add(element) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.has(element)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.items[element] = element;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从集合移除一个元素</span></span><br><span class="line">    <span class="keyword">delete</span>(element) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.has(element)) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.items[element];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除集合中的所有元素</span></span><br><span class="line">    clear() &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回集合所包含元素的数量。它与数组的length属性类似</span></span><br><span class="line">    size() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.items).length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个包含集合中所有值（元素）的数组</span></span><br><span class="line">    values() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.values(<span class="built_in">this</span>.items);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 并集</span></span><br><span class="line">    union(otherSet) &#123;</span><br><span class="line">        <span class="keyword">const</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="built_in">this</span>.values().forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            unionSet.add(value);</span><br><span class="line">        &#125;);</span><br><span class="line">        otherSet.values().forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            unionSet.add(value);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> unionSet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交集</span></span><br><span class="line">    intersection(otherSet) &#123;</span><br><span class="line">        <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="keyword">const</span> values = <span class="built_in">this</span>.values();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span>  i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (otherSet.has(values[i])) &#123;</span><br><span class="line">                intersectionSet.add(values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersectionSet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改进版交集</span></span><br><span class="line">    intersectionPlus(otherSet) &#123;</span><br><span class="line">        <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="keyword">const</span> values = <span class="built_in">this</span>.values();</span><br><span class="line">        <span class="keyword">const</span> otherValues = otherSet.values();</span><br><span class="line">        <span class="keyword">let</span> biggerSet = values;</span><br><span class="line">        <span class="keyword">let</span> smallerSet = otherValues;</span><br><span class="line">        <span class="keyword">if</span> (otherValues.length - values.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            biggerSet = otherValues;</span><br><span class="line">            smallerSet = values;</span><br><span class="line">        &#125;</span><br><span class="line">        smallerSet.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (biggerSet.includes(value)) &#123;</span><br><span class="line">                intersectionSet.add(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> intersectionSet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 差集</span></span><br><span class="line">    difference(otherSet) &#123;</span><br><span class="line">        <span class="keyword">const</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        <span class="built_in">this</span>.values().forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!otherSet.has(value)) &#123;</span><br><span class="line">                differenceSet.add(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> differenceSet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子集</span></span><br><span class="line">    isSubsetOf(otherSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.size() &gt; otherSet.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> isSubset = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.values().every(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!otherSet.has(value)) &#123;</span><br><span class="line">                isSubset = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> isSubset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不再演示Set类中方法的使用了，有兴趣的可以自己做个demo测试一下，如果有任何的问题，欢迎评论区留言。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>this指向</title>
    <url>/2020/09/17/this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<h2 id="从一道面试题开始说起"><a href="#从一道面试题开始说起" class="headerlink" title="从一道面试题开始说起"></a>从一道面试题开始说起</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    number: <span class="number">3</span>,</span><br><span class="line">    fn1: (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> number;</span><br><span class="line">        <span class="built_in">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">        number = number * <span class="number">2</span>;</span><br><span class="line">        number = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> num = <span class="built_in">this</span>.number;</span><br><span class="line">            <span class="built_in">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(num);</span><br><span class="line">            number *= <span class="number">3</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(number);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> fn1 = obj.fn1;</span><br><span class="line">fn1.call(<span class="literal">null</span>);</span><br><span class="line">obj.fn1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.number);</span><br></pre></td></tr></table></figure>
<p>首先思考一下结果是什么，然后再在浏览器中执行一遍，如果两者一致，且你每一步的依据都很明确，那么恭喜你，你对this指向已经很清楚了，下面的内容你可以选择看或者不看，如果你感觉很晕，或者对自己的答案不确定，那么请继续往下阅读。我相信，你看完这篇文章，一定对this指向有更清晰的理解，这道题就留到最后讲解。那么，让我们开始吧！</p>
<a id="more"></a>
<h2 id="this是什么？"><a href="#this是什么？" class="headerlink" title="this是什么？"></a>this是什么？</h2><p>this在前端工作中使用的频率很高，合理的使用this可以让我们写出简洁且复用性高的代码，而且this作为前端面试中的高频考点，了解清楚是很有必要的。首先我们需要明确的一点是this不是指向自身，this是一个指针，指向调用函数的对象。为了能一眼看出this的指向，我们首先需要知道this的绑定规则有哪些：</p>
<ul>
<li>默认绑定</li>
<li>隐式绑定</li>
<li>显式绑定（硬绑定）</li>
<li>new绑定</li>
</ul>
<p>是不是感觉脑阔疼，没事，我们一个一个来梳理清楚。</p>
<h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><p>默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用，来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">sayHi();</span><br></pre></td></tr></table></figure>
<p>在调用sayHi()时，应用了默认绑定，this指向全局对象（非严格模式下），严格模式下，this指向undefined，undefined上没有this对象，会抛出错误。上面的代码，如果在浏览器环境中运行，那么结果就是 Hello, Tom，但是如果在node环境中运行，结果就是Hello, undefined，这是因为node中name并不是挂在全局对象上的。</p>
<blockquote>
<p>本文中，如不特殊说明，默认为浏览器环境执行结果。</p>
</blockquote>
<h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">person.sayHi();</span><br></pre></td></tr></table></figure>
<p>执行上面的代码，控制台打印的结果是Hello, Bob。sayHi函数声明在外部，严格来说并不属于person，但是在调用sayHi时,调用位置会使用person的上下文来引用函数，隐式绑定会把函数调用中的this(即此例sayHi函数中的this)绑定到这个上下文对象（即此例中的person）。</p>
<blockquote>
<p>需要注意的是：对象属性链中只有最后一层会影响到调用位置。</p>
</blockquote>
<p>来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    friend: person2</span><br><span class="line">&#125;;</span><br><span class="line">person1.friend.sayHi();</span><br></pre></td></tr></table></figure>
<p>执行上面的代码，控制台打印的结果是Hello, Tom。因为只有最后一层会确定this指向的是什么，不管有多少层，<strong>在判断this的时候，我们只关注最后一层</strong>，即此处的friend。</p>
<p>隐式绑定有一个大陷阱，绑定很容易丢失(或者说容易给我们造成误导，我们以为this指向的是什么，但是实际上并非如此)，来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = person.sayHi;</span><br><span class="line">Hi();</span><br></pre></td></tr></table></figure>
<p>结果是：Hello, Tom。这是为什么呢？Hi直接指向了sayHi的引用，在调用的时候，跟person没有半毛钱的关系，针对此类问题，我建议大家只需牢牢记住这个格式：**XXX.fn()**，fn()前如果什么都没有，那么肯定不是隐式绑定。</p>
<p>除了上面这种丢失之外，另一种常见的隐式绑定的丢失是发生在回调函数中(事件回调也是其中一种)，我们来看下面一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jerry&#x27;</span>,</span><br><span class="line">    sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;Hello,&#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name=<span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">person1.sayHi();</span><br><span class="line"><span class="built_in">setTimeout</span>(person2.sayHi, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    person2.sayHi();</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Hello, Tom</span><br><span class="line">Hello, Tom</span><br><span class="line">Hello, Bob</span><br></pre></td></tr></table></figure>
<ul>
<li>第一条输出很容易理解，setTimeout的回调函数中，this使用的是默认绑定，非严格模式下，执行的是全局对象。</li>
<li>第二条输出是不是有点迷惑了？说好XXX.fun()的时候，fun中的this指向的是XXX呢，为什么这次却不是这样了！Why？其实这里我们可以这样理解：setTimeout(fn, delay){ fn(); }，相当于是将person2.sayHi赋值给了一个变量，最后执行了变量，这个时候，sayHi中的this显然和person2就没有关系了。</li>
<li>第三条虽然也是在setTimeout的回调中，但是我们可以看出，这是执行的是person2.sayHi()使用的是隐式绑定，因此这是this指向的是person2，跟当前的作用域没有任何关系。</li>
</ul>
<p>读到这里，或许你已经有点疲倦了，但是答应我，别放弃，好吗？再坚持一下，就可以掌握这个知识点了。</p>
<p><img src="https://s1.ax1x.com/2020/09/18/wfHnY9.png" alt="alt"></p>
<h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><p>显式绑定比较好理解，就是通过call、apply和bind的方式，显式的指定this所指向的对象。</p>
<blockquote>
<p>注意:《你不知道的Javascript》中将bind单独作为硬绑定讲解。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = person.sayHi;</span><br><span class="line">Hi.call(person); <span class="comment">// Hi.apply(person)</span></span><br></pre></td></tr></table></figure>
<p>结果为：Hello, Bob。因为使用显式绑定明确将this绑定在了person上。</p>
<p>那么，使用了显式绑定，是不是就意味着不会出现隐式绑定所遇到的绑定丢失呢？显然不是这样的，不信，来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello, &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;;</span><br><span class="line">Hi.call(person, person.sayHi); </span><br></pre></td></tr></table></figure>
<p>结果是：Hello, Tom。原因很简单，Hi.call(person, person.sayHi)的确是将this绑定到Hi中的this了。但是在执行fn的时候，相当于直接调用了sayHi方法(记住: person.sayHi已经被赋值给fn了，像前面介绍的隐式绑定丢失的情况一样)，没有指定this的值，对应的是默认绑定。</p>
<p>现在，我们希望绑定不会丢失，要怎么做？很简单，调用fn的时候，也给它显式绑定，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello,&#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Hi.call(person, person.sayHi);</span><br></pre></td></tr></table></figure>
<p>现在，输出的结果为：Hello, Bob。因为person被绑定到Hi函数中的this上，fn又将这个对象绑定给了sayHi的函数。这时，sayHi中的this指向的就是person对象。</p>
<h2 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h2><p>革命胜利的曙光已经出现，下面我们来看最后一种绑定——new绑定。</p>
<p>javascript和C++不一样，并没有类，在javascript中，构造函数只是使用new操作符时被调用的函数，这些函数和普通的函数并没有什么不同，它不属于某个类，也不可能实例化出一个类。任何一个函数都可以使用new来调用，因此其实并不存在构造函数，而只有对于函数的“构造调用”。</p>
<p>使用new来调用函数，会自动执行下面的操作：</p>
<ol>
<li>创建一个空对象，构造函数中的this指向这个空对象；</li>
<li>这个新对象被执行 &#91;&#91;原型&#93;&#93; 连接；</li>
<li>执行构造函数方法，属性和方法被添加到this引用的对象中</li>
<li>如果构造函数中没有返回其它对象，那么返回this，即创建的这个的新对象，否则，返回构造函数中返回的对象。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> target = &#123;&#125;; <span class="comment">//创建的新对象</span></span><br><span class="line">    <span class="comment">//第一个参数是构造函数</span></span><br><span class="line">    <span class="keyword">let</span> [<span class="keyword">constructor</span>, ...args] = [...arguments];</span><br><span class="line">    //执行[[原型]]连接;target 是 <span class="keyword">constructor</span> 的实例</span><br><span class="line">    target.__proto__ = <span class="keyword">constructor</span>.prototype;</span><br><span class="line">    //执行构造函数，将属性或方法添加到创建的空对象上</span><br><span class="line">    let result = <span class="keyword">constructor</span>.apply(target, args);</span><br><span class="line">    if (result &amp;&amp; (typeof (result) == &quot;object&quot; || typeof (result) == &quot;function&quot;)) &#123;</span><br><span class="line">        <span class="comment">//如果构造函数执行的结构返回的是一个对象，那么返回这个对象</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果构造函数返回的不是一个对象，返回创建的新对象</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因此，我们使用new来调用函数的时候，就会把这个函数的this绑定到实例对象上，如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Hi = <span class="keyword">new</span> sayHi(<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hello, &#x27;</span>, Hi.name);</span><br></pre></td></tr></table></figure>
输出结果为 Hello, Tom，原因是因为在var Hi = new sayHi(‘Yevtte’);这一步，会将sayHi中的this绑定到Hi对象上。</li>
</ol>
<h2 id="绑定优先级"><a href="#绑定优先级" class="headerlink" title="绑定优先级"></a>绑定优先级</h2><p>现在我们已经知道了this有四种绑定规则，但是如果同时应用了多种规则，怎么办？显然，我们需要了解哪一种绑定方式的优先级更高，这四种绑定的优先级为：<strong>new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</strong>。这个规则是如何得到的，大家如果有兴趣，可以自己写个demo去测试，或者记住上面的结论即可。</p>
<h2 id="绑定例外的情况"><a href="#绑定例外的情况" class="headerlink" title="绑定例外的情况"></a>绑定例外的情况</h2><p>凡事都有例外，this的规则也是这样。如果我们将null或者是undefined作为this的绑定对象传入call、apply或者是bind，这些值在调用时会被忽略，实际应用的是默认绑定规则，来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hello, &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">bar.call(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>输出的结果是：Hello, Tom，因为这时实际应用的是默认绑定规则。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数是ES6中新增的，它和普通函数有一些区别，箭头函数没有自己的this，它的this继承于外层代码库中的this。箭头函数在使用时，需要注意以下几点：</p>
<ul>
<li>箭头函数体内的this对象，继承的是外层代码块的this。</li>
<li>箭头函数不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>箭头函数不可以使用arguments对象，该对象在箭头函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li>箭头函数中不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</li>
<li>箭头函数没有自己的this，所以不能用call()、apply()、bind()这些方法去改变this的指向。</li>
</ul>
<p>下面我们通过一个例子来看看箭头函数的this指向什么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    hi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    say: <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> hi = obj.hi();      <span class="comment">//输出obj对象</span></span><br><span class="line">hi();                   <span class="comment">//输出obj对象</span></span><br><span class="line"><span class="keyword">let</span> sayHi = obj.sayHi();</span><br><span class="line"><span class="keyword">let</span> fun1 = sayHi();     <span class="comment">//输出window</span></span><br><span class="line">fun1();                 <span class="comment">//输出window</span></span><br><span class="line">obj.say();              <span class="comment">//输出window</span></span><br></pre></td></tr></table></figure>
<p>那么这是为什么呢？如果说箭头函数中的this是定义时所在的对象，那么输出的结果不是大家预期的，按照这个定义，say中的this应该是obj才对。不要慌，我们来分析一下上面代码的执行结果：</p>
<ol>
<li>obj.hi()：对应了this的隐式绑定规则，this绑定在obj上，所以输出obj，很好理解；</li>
<li>hi()：这一步执行的就是箭头函数，箭头函数继承上一个代码库的this，刚刚我们得出上一层的this是obj，显然这里的this就是obj；</li>
<li>执行sayHi()：这一步也很好理解，我们前面说过这种隐式绑定丢失的情况，这个时候this执行的是默认绑定，this指向的是全局对象window.</li>
<li>fun1()：这一步执行的是箭头函数，如果按照之前的理解，this指向的是箭头函数定义时所在的对象，那么这显然是说不通。OK，按照箭头函数的this是继承于外层代码库的this就很好理解了。外层代码库我们刚刚分析了，this指向的是window，因此这的输出结果是window.</li>
<li>obj.say()：执行的是箭头函数，当前的代码块obj中是不存在this的，只能往上找，就找到了全局的this，指向的是window。</li>
</ol>
<p>现在是不是清晰多了，那么箭头函数的this是静态的吗？依旧使用前面创建的obj对象，我们来看看下面代码的执行结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = obj.sayHi();</span><br><span class="line"><span class="keyword">let</span> fun1 = sayHi();          <span class="comment">//输出window</span></span><br><span class="line">fun1();                      <span class="comment">//输出window</span></span><br><span class="line"><span class="keyword">let</span> fun2 = sayHi.bind(obj)();<span class="comment">//输出obj</span></span><br><span class="line">fun2();                      <span class="comment">//输出obj</span></span><br></pre></td></tr></table></figure>
<p>可以看出，fun1和fun2对应的是同样的箭头函数，但是this的输出结果是不一样的。所以，请大家牢牢记住一点：<strong>箭头函数没有自己的this，箭头函数中的this继承于外层代码库中的this</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于this的规则，至此，就告一段落了，但是想要一眼就能看出this所绑定的对象，还需要不断的训练。下面我们总结一下如何准确判断this的指向：</p>
<ul>
<li>函数是否在new中调用(new绑定)，如果是，那么this绑定的是新创建的对象。</li>
<li>函数是否通过call或apply调用，或者使用了bind(即硬绑定)，如果是，那么this绑定的就是指定的对象。</li>
<li>函数是否在某个上下文对象中调用(隐式绑定)，如果是的话，this绑定的是那个上下文对象，一般是obj.foo()。</li>
<li>如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到undefined，否则绑定到全局对象。</li>
<li>如果把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。</li>
<li>如果是箭头函数，箭头函数的this继承的是外层代码块的this。</li>
</ul>
<p>下面我们来看看文章开头的例子，我们来分析一下那段代码的执行过程：</p>
<ol>
<li>在定义obj的时候，fn对应的闭包就执行了，返回其中的函数，执行闭包中代码时，显然应用不了new绑定(因为没有出现new关键字)，显式绑定也没有（没有出现call、apply或bind关键字），隐式绑定有没有？很显然没有，因为没有出现XX.fn()，所以这里应用的就是默认绑定了，非严格模式下this绑定到了window上(浏览器执行环境)。<strong>这里很容易被迷惑的就是以为this指向的是obj，一定要注意，除非是箭头函数，否则this跟词法作用域是两回事，一定要牢记在心。</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.number * = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
window.number的值是10（var number定义的全局变量是挂在window上的）。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">number = number * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
number的值是NaN，注意我们这边定义了一个number，但是没有赋值，number的值是undefined，Number(undefined)-&gt;NaN。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">number = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
number的值被赋值成3。</li>
<li>myFun.call(null)：我们前面说了，call的第一个参数传null，调用的是默认绑定。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">this</span>.number;</span><br><span class="line">    <span class="built_in">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">    number *= <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
执行时：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="built_in">this</span>.number; <span class="comment">//num=10，此时this指向的是window</span></span><br><span class="line"><span class="built_in">this</span>.number * = <span class="number">2</span>;     <span class="comment">//window.number = 20</span></span><br><span class="line"><span class="built_in">console</span>.log(num);      <span class="comment">//输出结果为10</span></span><br><span class="line">number *= <span class="number">3</span>;           <span class="comment">//number=9，这个number对应的闭包中的number，闭包中的number的是3</span></span><br><span class="line"><span class="built_in">console</span>.log(number);   <span class="comment">//输出的结果是9</span></span><br></pre></td></tr></table></figure></li>
<li>obj.fn()：应用了隐式绑定，fn中的this对应的是obj。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="built_in">this</span>.number;<span class="comment">//num = 3，此时this指向的是obj</span></span><br><span class="line"><span class="built_in">this</span>.number *= <span class="number">2</span>;     <span class="comment">//obj.number = 6</span></span><br><span class="line"><span class="built_in">console</span>.log(num);     <span class="comment">//输出结果为3</span></span><br><span class="line">number *= <span class="number">3</span>;          <span class="comment">//number=27，这个number对应的闭包中的number;闭包中的number的此时是9</span></span><br><span class="line"><span class="built_in">console</span>.log(number);  <span class="comment">//输出的结果是27</span></span><br></pre></td></tr></table></figure></li>
<li>最后一步console.log(window.number)输出的结果是20。因此在严格模式下，那段代码控制台输出的结果为：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>撒花撒花，结束了，恭喜坚持读完的小伙伴们，你们成功get到了this这个知识点，但是想要完全掌握，还是要多回顾和练习。如果你们有什么问题，也欢迎评论区留言，大家一起进步。</p>
<p><img src="https://s1.ax1x.com/2020/09/18/wfHuWR.png" alt="alt"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
